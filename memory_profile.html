<!DOCTYPE html>
<!-- saved from url=(0032)http://localhost:53542/ui/source -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  
  <title>___go_build_ip_addr_counter_go inuse_space</title>
  <style type="text/css">
* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}
html, body {
  height: 100%;
}
body {
  font-family: 'Roboto', -apple-system, BlinkMacSystemFont, 'Segoe UI', Helvetica, Arial, sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol';
  font-size: 13px;
  line-height: 1.4;
  display: flex;
  flex-direction: column;
}
a {
  color: #2a66d9;
}
.header {
  display: flex;
  align-items: center;
  height: 44px;
  min-height: 44px;
  background-color: #eee;
  color: #212121;
  padding: 0 1rem;
}
.header > div {
  margin: 0 0.125em;
}
.header .title h1 {
  font-size: 1.75em;
  margin-right: 1rem;
  margin-bottom: 4px;
}
.header .title a {
  color: #212121;
  text-decoration: none;
}
.header .title a:hover {
  text-decoration: underline;
}
.header .description {
  width: 100%;
  text-align: right;
  white-space: nowrap;
}
@media screen and (max-width: 799px) {
  .header input {
    display: none;
  }
}
#detailsbox {
  display: none;
  position: fixed;
  top: 40px;
  right: 20px;
  background-color: #ffffff;
  box-shadow: 0 1px 5px rgba(0,0,0,.3);
  line-height: 24px;
  padding: 1em;
  text-align: left;
}
.header input {
  background: white url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' style='pointer-events:none;display:block;width:100%25;height:100%25;fill:%23757575'%3E%3Cpath d='M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61.0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z'/%3E%3C/svg%3E") no-repeat 4px center/20px 20px;
  border: 1px solid #d1d2d3;
  border-radius: 2px 0 0 2px;
  padding: 0.25em;
  padding-left: 28px;
  margin-left: 1em;
  font-family: 'Roboto', 'Noto', sans-serif;
  font-size: 1em;
  line-height: 24px;
  color: #212121;
}
.downArrow {
  border-top: .36em solid #ccc;
  border-left: .36em solid transparent;
  border-right: .36em solid transparent;
  margin-bottom: .05em;
  margin-left: .5em;
  transition: border-top-color 200ms;
}
.menu-item {
  height: 100%;
  text-transform: uppercase;
  font-family: 'Roboto Medium', -apple-system, BlinkMacSystemFont, 'Segoe UI', Helvetica, Arial, sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol';
  position: relative;
}
.menu-item .menu-name:hover {
  opacity: 0.75;
}
.menu-item .menu-name:hover .downArrow {
  border-top-color: #666;
}
.menu-name {
  height: 100%;
  padding: 0 0.5em;
  display: flex;
  align-items: center;
  justify-content: center;
}
.menu-name a {
  text-decoration: none;
  color: #212121;
}
.submenu {
  display: none;
  margin-top: -4px;
  min-width: 10em;
  position: absolute;
  left: 0px;
  background-color: white;
  box-shadow: 0 1px 5px rgba(0,0,0,.3);
  font-size: 100%;
  text-transform: none;
  white-space: nowrap;
}
.menu-item, .submenu {
  user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  -webkit-user-select: none;
}
.submenu hr {
  border: 0;
  border-top: 2px solid #eee;
}
.submenu a {
  display: block;
  padding: .5em 1em;
  text-decoration: none;
}
.submenu a:hover, .submenu a.active {
  color: white;
  background-color: #6b82d6;
}
.submenu a.disabled {
  color: gray;
  pointer-events: none;
}
.menu-check-mark {
  position: absolute;
  left: 2px;
}
.menu-delete-btn {
  position: absolute;
  right: 2px;
}

.help {
  padding-left: 1em;
}


#dialog-overlay {
  display: none;
  position: fixed;
  left: 0px;
  top: 0px;
  width: 100%;
  height: 100%;
  background-color: rgba(1,1,1,0.1);
}

.dialog {
  
  display: none;
  position: fixed;
  margin: 0px;
  top: 60px;
  left: 50%;
  transform: translateX(-50%);
  font-size: 125%;
  background-color: #ffffff;
  box-shadow: 0 1px 5px rgba(0,0,0,.3);
}
.dialog-header {
  font-size: 120%;
  border-bottom: 1px solid #CCCCCC;
  width: 100%;
  text-align: center;
  background: #EEEEEE;
  user-select: none;
}
.dialog-footer {
  border-top: 1px solid #CCCCCC;
  width: 100%;
  text-align: right;
  padding: 10px;
}
.dialog-error {
  margin: 10px;
  color: red;
}
.dialog input {
  margin: 10px;
  font-size: inherit;
}
.dialog button {
  margin-left: 10px;
  font-size: inherit;
}
#save-dialog, #delete-dialog {
  width: 50%;
  max-width: 20em;
}
#delete-prompt {
  padding: 10px;
}

#content {
  overflow-y: scroll;
  padding: 1em;
}
#top {
  overflow-y: scroll;
}
#graph {
  overflow: hidden;
}
#graph svg {
  width: 100%;
  height: auto;
  padding: 10px;
}
#content.source .filename {
  margin-top: 0;
  margin-bottom: 1em;
  font-size: 120%;
}
#content.source pre {
  margin-bottom: 3em;
}
table {
  border-spacing: 0px;
  width: 100%;
  padding-bottom: 1em;
  white-space: nowrap;
}
table thead {
  font-family: 'Roboto Medium', -apple-system, BlinkMacSystemFont, 'Segoe UI', Helvetica, Arial, sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol';
}
table tr th {
  position: sticky;
  top: 0;
  background-color: #ddd;
  text-align: right;
  padding: .3em .5em;
}
table tr td {
  padding: .3em .5em;
  text-align: right;
}
#top table tr th:nth-child(6),
#top table tr th:nth-child(7),
#top table tr td:nth-child(6),
#top table tr td:nth-child(7) {
  text-align: left;
}
#top table tr td:nth-child(6) {
  width: 100%;
  text-overflow: ellipsis;
  overflow: hidden;
  white-space: nowrap;
}
#flathdr1, #flathdr2, #cumhdr1, #cumhdr2, #namehdr {
  cursor: ns-resize;
}
.hilite {
  background-color: #ebf5fb;
  font-weight: bold;
}
 
.boxtext         { z-index: 2; }   
#current-details { z-index: 2; }   
#detailsbox      { z-index: 3; }   
.submenu         { z-index: 4; }
.dialog          { z-index: 5; }
</style>

  <style type="text/css">
body #content{
font-family: sans-serif;
}
h1 {
  font-size: 1.5em;
}
.legend {
  font-size: 1.25em;
}
.line, .nop, .unimportant {
  color: #aaaaaa;
}
.inlinesrc {
  color: #000066;
}
.livesrc {
cursor: pointer;
}
.livesrc:hover {
background-color: #eeeeee;
}
.asm {
color: #008800;
display: none;
}
</style>
  <script type="text/javascript">
function pprof_toggle_asm(e) {
  var target;
  if (!e) e = window.event;
  if (e.target) target = e.target;
  else if (e.srcElement) target = e.srcElement;

  if (target) {
    var asm = target.nextSibling;
    if (asm && asm.className == "asm") {
      asm.style.display = (asm.style.display == "block" ? "" : "block");
      e.preventDefault();
      return false;
    }
  }
}
</script>
</head>
<body>
<div class="header">
  <div class="title">
    <h1><a href="http://localhost:53542/ui/">pprof</a></h1>
  </div>

  <div id="view" class="menu-item">
    <div class="menu-name">
      View
      <i class="downArrow"></i>
    </div>
    <div class="submenu">
      <a title="Outputs top entries in text form" href="http://localhost:53542/ui/top" id="topbtn">Top</a>
      <a title="Display profile as a directed graph" href="http://localhost:53542/ui/" id="graphbtn">Graph</a>
      <a title="Display profile as a flame graph" href="http://localhost:53542/ui/flamegraph" id="flamegraph">Flame Graph</a>
      <a title="Output callers/callees of functions matching regexp" href="http://localhost:53542/ui/peek" id="peek">Peek</a>
      <a title="Output annotated source for functions matching regexp" href="http://localhost:53542/ui/source" id="list">Source</a>
      <a title="Output assembly listings annotated with samples" href="http://localhost:53542/ui/disasm" id="disasm">Disassemble</a>
    </div>
  </div>

  
  
  <div id="sample" class="menu-item">
    <div class="menu-name">
      Sample
      <i class="downArrow"></i>
    </div>
    <div class="submenu">
      
      <a href="http://localhost:53542/ui/source?si=alloc_objects" id="sampletype-alloc_objects">alloc_objects</a>
      
      <a href="http://localhost:53542/ui/source?si=alloc_space" id="sampletype-alloc_space">alloc_space</a>
      
      <a href="http://localhost:53542/ui/source?si=inuse_objects" id="sampletype-inuse_objects">inuse_objects</a>
      
      <a href="http://localhost:53542/ui/source?si=inuse_space" id="sampletype-inuse_space">inuse_space</a>
      
    </div>
  </div>
  

  <div id="refine" class="menu-item">
    <div class="menu-name">
      Refine
      <i class="downArrow"></i>
    </div>
    <div class="submenu">
      <a title="Restricts to samples going through a node matching regexp
Discard samples that do not include a node matching this regexp.
Matching includes the function name, filename or object name.
" href="http://localhost:53542/ui/source?" id="focus" class="disabled">Focus</a>
      <a title="Skips paths going through any nodes matching regexp
If set, discard samples that include a node matching this regexp.
Matching includes the function name, filename or object name.
" href="http://localhost:53542/ui/source?" id="ignore" class="disabled">Ignore</a>
      <a title="Skips nodes matching regexp
Discard nodes that match this location.
Other nodes from samples that include this location will be shown.
Matching includes the function name, filename or object name.
" href="http://localhost:53542/ui/source?" id="hide" class="disabled">Hide</a>
      <a title="Only show nodes matching regexp
If set, only show nodes that match this location.
Matching includes the function name, filename or object name.
" href="http://localhost:53542/ui/source?" id="show" class="disabled">Show</a>
      <a title="Drops functions above the highest matched frame.
If set, all frames above the highest match are dropped from every sample.
Matching includes the function name, filename or object name.
" href="http://localhost:53542/ui/source?" id="show-from" class="disabled">Show from</a>
      <hr>
      <a title="Show the entire profile" href="http://localhost:53542/ui/source?">Reset</a>
    </div>
  </div>

  <div id="config" class="menu-item">
    <div class="menu-name">
      Config
      <i class="downArrow"></i>
    </div>
    <div class="submenu">
      <a title="Save current settings" id="save-config">Save as ...</a>
      <hr>
      
      <a href="http://localhost:53542/ui/source?">
        <span class="menu-check-mark">✓</span>
        Default
        
      </a>
      
    </div>
  </div>

  <div id="download" class="menu-item">
    <div class="menu-name">
      <a href="http://localhost:53542/ui/download">Download</a>
    </div>
  </div>

  <div>
    <input id="search" type="text" placeholder="Search regexp" autocomplete="off" autocapitalize="none" size="40">
  </div>

  <div class="description">
    <a title="Show information about the profile and this view" href="http://localhost:53542/ui/source#" id="details">___go_build_ip_addr_counter_go inuse_space</a>
    <div id="detailsbox">
      <div>File: ___go_build_ip_addr_counter_go</div><div>Build ID: badf3f5db4ca9851a94cefaaa5084acd5246e94c</div><div>Type: inuse_space</div><div>Time: 2025-11-30 19:02:39 AST</div>
    </div>
  </div>

  
</div>

<div id="dialog-overlay"></div>

<div class="dialog" id="save-dialog">
  <div class="dialog-header">Save options as</div>
  <datalist id="config-list">
    
  </datalist>
  <input id="save-name" type="text" list="config-list" placeholder="New config">
  <div class="dialog-footer">
    <span class="dialog-error" id="save-error"></span>
    <button id="save-cancel">Cancel</button>
    <button id="save-confirm">Save</button>
  </div>
</div>

<div class="dialog" id="delete-dialog">
  <div class="dialog-header" id="delete-dialog-title">Delete config</div>
  <div id="delete-prompt"></div>
  <div class="dialog-footer">
    <span class="dialog-error" id="delete-error"></span>
    <button id="delete-cancel">Cancel</button>
    <button id="delete-confirm">Delete</button>
  </div>
</div>

<div id="errors"></div>

    <div id="content" class="source"><h2>main.main</h2><p class="filename">/home/mikhliuk/projects/lightspeed/ip_addr_counter.go</p>
<pre onclick="pprof_toggle_asm(event)">  Total:       512MB      512MB (flat, cum) 88.41%
<span class="line">     16</span> <span class="nop">           .          .           	workerBufSize  = 4 * 1024 * 1024 </span>
<span class="line">     17</span> <span class="nop">           .          .           	ipMaxLength    = uint8(19) </span>
<span class="line">     18</span> <span class="nop">           .          .           	octetMaxLength = uint8(3) </span>
<span class="line">     19</span> <span class="nop">           .          .           ) </span>
<span class="line">     20</span> <span class="nop">           .          .            </span>
<span class="line">     21</span> <span class="livesrc">           .          .           func main() { </span><span class="asm">                   .          .   4c9940:     LEAQ 0xffffff50(SP), R12                                                     <span class="unimportant">ip_addr_counter.go:21</span>
                   .          .   4c9948:     CMPQ R12, 0x10(R14)                                                          <span class="unimportant">ip_addr_counter.go:21</span>
                   .          .   4c994c:     JBE 0x4c9dd4                                                                 <span class="unimportant">ip_addr_counter.go:21</span>
                   .          .   4c9952:     PUSHQ BP                                                                     <span class="unimportant">ip_addr_counter.go:21</span>
                   .          .   4c9953:     MOVQ SP, BP                                                                  <span class="unimportant">ip_addr_counter.go:21</span>
                   .          .   4c9956:     SUBQ $0x128, SP                                                              <span class="unimportant">ip_addr_counter.go:21</span>
                   .          .   4c995d:     MOVUPS X15, 0x110(SP)                                                        <span class="unimportant">ip_addr_counter.go:21</span>
                   .          .   4c9966:     MOVUPS X15, 0x118(SP)                                                        <span class="unimportant">ip_addr_counter.go:21</span>
                   .          .   4c996f:     MOVB $0x0, 0x3f(SP)                                                          <span class="unimportant">ip_addr_counter.go:21</span>
                                     ⋮
                   .          .   4c9dd4:     CALL runtime.morestack_noctxt.abi0(SB)                                       <span class="unimportant">ip_addr_counter.go:21</span>
                   .          .   4c9dd9:     JMP main.main(SB)                                                            <span class="unimportant">ip_addr_counter.go:21</span>
</span>
<span class="line">     22</span> <span class="livesrc">           .          .           	if len(os.Args) &lt; 2 { </span><span class="asm">                   .          .   4c9974:             CMPQ os.Args+8(SB), $0x2                                             <span class="unimportant">ip_addr_counter.go:22</span>
                   .          .   4c997c:             JGE 0x4c99c8                                                         <span class="unimportant">ip_addr_counter.go:22</span>
</span>
<span class="line">     23</span> <span class="livesrc">           .          .           		fmt.Println("Usage: go run ip_addr_counter.go &lt;file&gt;") </span><span class="asm">                   .          .   4c997e:                     LEAQ 0xd09b(IP), DX                                          <span class="unimportant">ip_addr_counter.go:23</span>
                   .          .   4c9985:                     MOVQ DX, 0xe8(SP)                                            <span class="unimportant">ip_addr_counter.go:23</span>
                   .          .   4c998d:                     LEAQ 0x5906c(IP), DX                                         <span class="unimportant">ip_addr_counter.go:23</span>
                   .          .   4c9994:                     MOVQ DX, 0xf0(SP)                                            <span class="unimportant">ip_addr_counter.go:23</span>
</span>
<span class="line">     24</span> <span class="livesrc">           .          .           		return </span><span class="asm">                   .          .   4c99bf:                     ADDQ $0x128, SP                                              <span class="unimportant">ip_addr_counter.go:24</span>
                   .          .   4c99c6:                     POPQ BP                                                      <span class="unimportant">ip_addr_counter.go:24</span>
                   .          .   4c99c7:                     RET                                                          <span class="unimportant">ip_addr_counter.go:24</span>
</span>
<span class="line">     25</span> <span class="nop">           .          .           	} </span>
<span class="line">     26</span> <span class="nop">           .          .            </span>
<span class="line">     27</span> <span class="livesrc">           .          .           	f, _ := os.Create("mem_profile.prof") </span><span class="asm">                   .          .   4c99c8:             NOPL                                                                 <span class="unimportant">ip_addr_counter.go:27</span>
</span>
<span class="line">     28</span> <span class="livesrc">           .          .           	defer f.Close() </span><span class="asm">                   .          .   4c99e5:             LEAQ main.main.deferwrap1(SB), DX                                    <span class="unimportant">ip_addr_counter.go:28</span>
                   .          .   4c99ec:             MOVQ DX, 0xd8(SP)                                                    <span class="unimportant">ip_addr_counter.go:28</span>
                   .          .   4c99f4:             MOVQ AX, 0xe0(SP)                                                    <span class="unimportant">ip_addr_counter.go:28</span>
                   .          .   4c99fc:             LEAQ 0xd8(SP), DX                                                    <span class="unimportant">ip_addr_counter.go:28</span>
                   .          .   4c9a04:             MOVQ DX, 0x110(SP)                                                   <span class="unimportant">ip_addr_counter.go:28</span>
</span>
<span class="line">     29</span> <span class="livesrc">           .          .           	defer pprof.WriteHeapProfile(f) </span><span class="asm">                   .          .   4c9a0c:             LEAQ main.main.deferwrap2(SB), DX                                    <span class="unimportant">ip_addr_counter.go:29</span>
                   .          .   4c9a13:             MOVQ DX, 0xc0(SP)                                                    <span class="unimportant">ip_addr_counter.go:29</span>
                   .          .   4c9a1b:             LEAQ go:itab.*os.File,io.Writer(SB), DX                              <span class="unimportant">ip_addr_counter.go:29</span>
                   .          .   4c9a22:             MOVQ DX, 0xc8(SP)                                                    <span class="unimportant">ip_addr_counter.go:29</span>
                   .          .   4c9a2a:             MOVQ AX, 0xd0(SP)                                                    <span class="unimportant">ip_addr_counter.go:29</span>
                   .          .   4c9a32:             LEAQ 0xc0(SP), SI                                                    <span class="unimportant">ip_addr_counter.go:29</span>
                   .          .   4c9a3a:             MOVQ SI, 0x118(SP)                                                   <span class="unimportant">ip_addr_counter.go:29</span>
                   .          .   4c9a42:             MOVB $0x3, 0x3f(SP)                                                  <span class="unimportant">ip_addr_counter.go:29</span>
</span>
<span class="line">     30</span> <span class="nop">           .          .            </span>
<span class="line">     31</span> <span class="livesrc">           .          .           	fileName := os.Args[1] </span><span class="asm">                   .          .   4c9a47:             MOVQ os.Args+8(SB), CX                                               <span class="unimportant">ip_addr_counter.go:31</span>
                   .          .   4c9a4e:             CMPQ CX, $0x1                                                        <span class="unimportant">ip_addr_counter.go:31</span>
                   .          .   4c9a52:             JBE 0x4c9db7                                                         <span class="unimportant">ip_addr_counter.go:31</span>
                   .          .   4c9a58:             MOVQ os.Args(SB), DX                                                 <span class="unimportant">ip_addr_counter.go:31</span>
                   .          .   4c9a5f:             MOVQ 0x10(DX), AX                                                    <span class="unimportant">ip_addr_counter.go:31</span>
                   .          .   4c9a63:             MOVQ 0x18(DX), BX                                                    <span class="unimportant">ip_addr_counter.go:31</span>
                                     ⋮
                   .          .   4c9db7:             MOVL $0x1, AX                                                        <span class="unimportant">ip_addr_counter.go:31</span>
                   .          .   4c9dbc:             NOPL 0(AX)                                                           <span class="unimportant">ip_addr_counter.go:31</span>
                   .          .   4c9dc0:             CALL runtime.panicIndex(SB)                                          <span class="unimportant">ip_addr_counter.go:31</span>
                   .          .   4c9dc5:             NOPL                                                                 <span class="unimportant">ip_addr_counter.go:31</span>
                   .          .   4c9dc6:             CALL runtime.deferreturn(SB)                                         <span class="unimportant">ip_addr_counter.go:31</span>
                   .          .   4c9dcb:             ADDQ $0x128, SP                                                      <span class="unimportant">ip_addr_counter.go:31</span>
                   .          .   4c9dd2:             POPQ BP                                                              <span class="unimportant">ip_addr_counter.go:31</span>
                   .          .   4c9dd3:             RET                                                                  <span class="unimportant">ip_addr_counter.go:31</span>
</span>
<span class="line">     32</span> <span class="livesrc">           .          .           	file, err := os.Open(fileName) </span><span class="asm">                   .          .   4c9a67:             NOPL                                                                 <span class="unimportant">ip_addr_counter.go:32</span>
</span>
<span class="line">     33</span> <span class="livesrc">           .          .           	if err != nil { </span><span class="asm">                   .          .   4c9a71:             TESTQ BX, BX                                                         <span class="unimportant">ip_addr_counter.go:33</span>
                   .          .   4c9a74:             JNE 0x4c9dab                                                         <span class="unimportant">ip_addr_counter.go:33</span>
</span>
<span class="line">     34</span> <span class="livesrc">           .          .           		panic(err) </span><span class="asm">                   .          .   4c9dab:                     MOVQ 0x8(BX), AX                                             <span class="unimportant">ip_addr_counter.go:34</span>
                   .          .   4c9daf:                     MOVQ CX, BX                                                  <span class="unimportant">ip_addr_counter.go:34</span>
                   .          .   4c9db2:                     CALL runtime.gopanic(SB)                                     <span class="unimportant">ip_addr_counter.go:34</span>
</span>
<span class="line">     35</span> <span class="nop">           .          .           	} </span>
<span class="line">     36</span> <span class="livesrc">           .          .           	defer file.Close() </span><span class="asm">                   .          .   4c9a82:             LEAQ main.main.deferwrap3(SB), CX                                    <span class="unimportant">ip_addr_counter.go:36</span>
                   .          .   4c9a89:             MOVQ CX, 0xb0(SP)                                                    <span class="unimportant">ip_addr_counter.go:36</span>
                   .          .   4c9a91:             MOVQ AX, 0xb8(SP)                                                    <span class="unimportant">ip_addr_counter.go:36</span>
                   .          .   4c9a99:             LEAQ 0xb0(SP), CX                                                    <span class="unimportant">ip_addr_counter.go:36</span>
                   .          .   4c9aa1:             MOVQ CX, 0x120(SP)                                                   <span class="unimportant">ip_addr_counter.go:36</span>
                   .          .   4c9aa9:             MOVB $0x7, 0x3f(SP)                                                  <span class="unimportant">ip_addr_counter.go:36</span>
</span>
<span class="line">     37</span> <span class="nop">           .          .            </span>
<span class="line">     38</span> <span class="livesrc">           .          .           	stat, _ := file.Stat() </span><span class="asm">                   .          .   4c9aae:             CALL os.(*File).Stat(SB)                                             <span class="unimportant">ip_addr_counter.go:38</span>
</span>
<span class="line">     39</span> <span class="livesrc">           .          .           	fileSize := stat.Size() </span><span class="asm">                   .          .   4c9ab3:             MOVQ 0x38(AX), CX                                                    <span class="unimportant">ip_addr_counter.go:39</span>
                   .          .   4c9ab7:             MOVQ BX, AX                                                          <span class="unimportant">ip_addr_counter.go:39</span>
                   .          .   4c9aba:             CALL CX                                                              <span class="unimportant">ip_addr_counter.go:39</span>
                   .          .   4c9abc:             MOVQ AX, 0x48(SP)                                                    <span class="unimportant">ip_addr_counter.go:39</span>
</span>
<span class="line">     40</span> <span class="nop">           .          .            </span>
<span class="line">     41</span> <span class="livesrc">           .          .           	start := time.Now() </span><span class="asm">                   .          .   4c9ac1:             CALL time.Now(SB)                                                    <span class="unimportant">ip_addr_counter.go:41</span>
                   .          .   4c9ac6:             MOVQ AX, 0x78(SP)                                                    <span class="unimportant">ip_addr_counter.go:41</span>
                   .          .   4c9acb:             MOVQ BX, 0x70(SP)                                                    <span class="unimportant">ip_addr_counter.go:41</span>
                   .          .   4c9ad0:             MOVQ CX, 0x100(SP)                                                   <span class="unimportant">ip_addr_counter.go:41</span>
</span>
<span class="line">     42</span> <span class="nop">           .          .            </span>
<span class="line">     43</span> <span class="livesrc">       512MB      512MB           	bitmap := make([]uint64, bitmapSize) </span><span class="asm" style="">                   .          .   4c9ad8:             LEAQ 0xd141(IP), AX                                                  <span class="unimportant">ip_addr_counter.go:43</span>
                   .          .   4c9adf:             MOVL $0x4000000, BX                                                  <span class="unimportant">ip_addr_counter.go:43</span>
                   .          .   4c9ae4:             MOVQ BX, CX                                                          <span class="unimportant">ip_addr_counter.go:43</span>
               512MB      512MB   4c9ae7:             CALL runtime.makeslice(SB)                                           <span class="unimportant">ip_addr_counter.go:43</span>
                   .          .   4c9aec:             MOVQ AX, 0xf8(SP)                                                    <span class="unimportant">ip_addr_counter.go:43</span>
</span>
<span class="line">     44</span> <span class="nop">           .          .            </span>
<span class="line">     45</span> <span class="livesrc">           .          .           	numWorkers := runtime.NumCPU() </span><span class="asm">                   .          .   4c9b0c:             NOPL                                                                 <span class="unimportant">ip_addr_counter.go:45</span>
</span>
<span class="line">     46</span> <span class="livesrc">           .          .           	var wg sync.WaitGroup </span><span class="asm">                   .          .   4c9b0d:             LEAQ 0x1cd8c(IP), AX                                                 <span class="unimportant">ip_addr_counter.go:46</span>
                   .          .   4c9b14:             CALL runtime.newobject(SB)                                           <span class="unimportant">ip_addr_counter.go:46</span>
                   .          .   4c9b19:             MOVQ AX, 0x108(SP)                                                   <span class="unimportant">ip_addr_counter.go:46</span>
</span>
<span class="line">     47</span> <span class="nop">           .          .            </span>
<span class="line">     48</span> <span class="livesrc">           .          .           	jobs := make(chan int64, numWorkers*10) </span><span class="asm">                   .          .   4c9b00:             ADDQ CX, CX                                                          <span class="unimportant">ip_addr_counter.go:48</span>
                   .          .   4c9b03:             LEAQ 0(CX)(CX*4), CX                                                 <span class="unimportant">ip_addr_counter.go:48</span>
                   .          .   4c9b07:             MOVQ CX, 0x60(SP)                                                    <span class="unimportant">ip_addr_counter.go:48</span>
                                     ⋮
                   .          .   4c9b21:             LEAQ 0xd7f8(IP), AX                                                  <span class="unimportant">ip_addr_counter.go:48</span>
                   .          .   4c9b28:             MOVQ 0x60(SP), BX                                                    <span class="unimportant">ip_addr_counter.go:48</span>
                   .          .   4c9b2d:             CALL runtime.makechan(SB)                                            <span class="unimportant">ip_addr_counter.go:48</span>
                   .          .   4c9b32:             MOVQ AX, 0x88(SP)                                                    <span class="unimportant">ip_addr_counter.go:48</span>
</span>
<span class="line">     49</span> <span class="nop">           .          .            </span>
<span class="line">     50</span> <span class="livesrc">           .          .           	for range numWorkers { </span><span class="asm">                   .          .   4c9b3a:             MOVQ 0x68(SP), CX                                                    <span class="unimportant">ip_addr_counter.go:50</span>
                   .          .   4c9b3f:             NOPL                                                                 <span class="unimportant">ip_addr_counter.go:50</span>
                   .          .   4c9b40:             JMP 0x4c9b80                                                         <span class="unimportant">ip_addr_counter.go:50</span>
                                     ⋮
                   .          .   4c9b6e:             MOVQ 0x68(SP), CX                                                    <span class="unimportant">ip_addr_counter.go:50</span>
                   .          .   4c9b73:             DECQ CX                                                              <span class="unimportant">ip_addr_counter.go:50</span>
                                     ⋮
                   .          .   4c9b80:             TESTQ CX, CX                                                         <span class="unimportant">ip_addr_counter.go:50</span>
                   .          .   4c9b83:             JLE 0x4c9bf3                                                         <span class="unimportant">ip_addr_counter.go:50</span>
                   .          .   4c9b85:             MOVQ CX, 0x68(SP)                                                    <span class="unimportant">ip_addr_counter.go:50</span>
                                     ⋮
                   .          .   4c9bf5:             JMP 0x4c9c1f                                                         <span class="unimportant">ip_addr_counter.go:50</span>
</span>
<span class="line">     51</span> <span class="livesrc">           .          .           		wg.Go(func() { </span><span class="asm">                   .          .   4c9b42:                     MOVQ DX, 0x8(AX)                                             <span class="unimportant">ip_addr_counter.go:51</span>
                   .          .   4c9b46:                     MOVQ SI, 0x10(AX)                                            <span class="unimportant">ip_addr_counter.go:51</span>
                   .          .   4c9b4a:                     MOVQ $0x4000000, 0x20(AX)                                    <span class="unimportant">ip_addr_counter.go:51</span>
                   .          .   4c9b52:                     MOVQ $0x4000000, 0x28(AX)                                    <span class="unimportant">ip_addr_counter.go:51</span>
                   .          .   4c9b5a:                     MOVQ DI, 0x18(AX)                                            <span class="unimportant">ip_addr_counter.go:51</span>
                   .          .   4c9b5e:                     MOVQ AX, BX                                                  <span class="unimportant">ip_addr_counter.go:51</span>
                   .          .   4c9b61:                     MOVQ 0x108(SP), AX                                           <span class="unimportant">ip_addr_counter.go:51</span>
                   .          .   4c9b69:                     CALL sync.(*WaitGroup).Go(SB)                                <span class="unimportant">ip_addr_counter.go:51</span>
                                     ⋮
                   .          .   4c9b8a:                     LEAQ 0x1e50f(IP), AX                                         <span class="unimportant">ip_addr_counter.go:51</span>
                   .          .   4c9b91:                     CALL runtime.newobject(SB)                                   <span class="unimportant">ip_addr_counter.go:51</span>
                   .          .   4c9b96:                     LEAQ main.main.func1(SB), CX                                 <span class="unimportant">ip_addr_counter.go:51</span>
                   .          .   4c9b9d:                     MOVQ CX, 0(AX)                                               <span class="unimportant">ip_addr_counter.go:51</span>
                   .          .   4c9ba0:                     CMPL runtime.writeBarrier(SB), $0x0                          <span class="unimportant">ip_addr_counter.go:51</span>
                   .          .   4c9ba7:                     JNE 0x4c9bc6                                                 <span class="unimportant">ip_addr_counter.go:51</span>
                   .          .   4c9ba9:                     MOVQ 0x80(SP), DX                                            <span class="unimportant">ip_addr_counter.go:51</span>
                   .          .   4c9bb1:                     MOVQ 0x88(SP), SI                                            <span class="unimportant">ip_addr_counter.go:51</span>
                   .          .   4c9bb9:                     MOVQ 0xf8(SP), DI                                            <span class="unimportant">ip_addr_counter.go:51</span>
                   .          .   4c9bc1:                     JMP 0x4c9b42                                                 <span class="unimportant">ip_addr_counter.go:51</span>
                   .          .   4c9bc6:                     CALL runtime.gcWriteBarrier3(SB)                             <span class="unimportant">ip_addr_counter.go:51</span>
                   .          .   4c9bcb:                     MOVQ 0x80(SP), DX                                            <span class="unimportant">ip_addr_counter.go:51</span>
                   .          .   4c9bd3:                     MOVQ DX, 0(R11)                                              <span class="unimportant">ip_addr_counter.go:51</span>
                   .          .   4c9bd6:                     MOVQ 0x88(SP), SI                                            <span class="unimportant">ip_addr_counter.go:51</span>
                   .          .   4c9bde:                     MOVQ SI, 0x8(R11)                                            <span class="unimportant">ip_addr_counter.go:51</span>
                   .          .   4c9be2:                     MOVQ 0xf8(SP), DI                                            <span class="unimportant">ip_addr_counter.go:51</span>
                   .          .   4c9bea:                     MOVQ DI, 0x10(R11)                                           <span class="unimportant">ip_addr_counter.go:51</span>
                   .          .   4c9bee:                     JMP 0x4c9b42                                                 <span class="unimportant">ip_addr_counter.go:51</span>
                   .          .   4c9bf3:                     XORL CX, CX                                                  <span class="unimportant">ip_addr_counter.go:51</span>
                                     ⋮
                   .          .   4c9de0:                     CMPQ SP, 0x10(R14)                                           <span class="unimportant">ip_addr_counter.go:51</span>
                   .          .   4c9de4:                     JBE 0x4c9e0d                                                 <span class="unimportant">ip_addr_counter.go:51</span>
                   .          .   4c9de6:                     PUSHQ BP                                                     <span class="unimportant">ip_addr_counter.go:51</span>
                   .          .   4c9de7:                     MOVQ SP, BP                                                  <span class="unimportant">ip_addr_counter.go:51</span>
                   .          .   4c9dea:                     SUBQ $0x28, SP                                               <span class="unimportant">ip_addr_counter.go:51</span>
                   .          .   4c9dee:                     MOVQ 0x10(DX), BX                                            <span class="unimportant">ip_addr_counter.go:51</span>
                   .          .   4c9df2:                     MOVQ 0x18(DX), CX                                            <span class="unimportant">ip_addr_counter.go:51</span>
                   .          .   4c9df6:                     MOVQ 0x20(DX), DI                                            <span class="unimportant">ip_addr_counter.go:51</span>
                   .          .   4c9dfa:                     MOVQ 0x28(DX), SI                                            <span class="unimportant">ip_addr_counter.go:51</span>
                   .          .   4c9dfe:                     MOVQ 0x8(DX), AX                                             <span class="unimportant">ip_addr_counter.go:51</span>
                                     ⋮
                   .          .   4c9e0d:                     CALL runtime.morestack.abi0(SB)                              <span class="unimportant">ip_addr_counter.go:51</span>
                   .          .   4c9e12:                     JMP main.main.func1(SB)                                      <span class="unimportant">ip_addr_counter.go:51</span>
</span>
</pre>
<h2>main.main.func1</h2><p class="filename">/home/mikhliuk/projects/lightspeed/ip_addr_counter.go</p>
<pre onclick="pprof_toggle_asm(event)">  Total:           0    64.15MB (flat, cum) 11.08%
<span class="line">     52</span> <span class="livesrc">           .    64.15MB           			worker(file, jobs, bitmap) </span><span class="asm" style="">                   .    64.15MB   4c9e02:                             CALL main.worker(SB)                                 <span class="unimportant">ip_addr_counter.go:52</span>
</span>
<span class="line">     53</span> <span class="livesrc">           .          .           		}) </span><span class="asm">                   .          .   4c9e07:                     ADDQ $0x28, SP                                               <span class="unimportant">ip_addr_counter.go:53</span>
                   .          .   4c9e0b:                     POPQ BP                                                      <span class="unimportant">ip_addr_counter.go:53</span>
                   .          .   4c9e0c:                     RET                                                          <span class="unimportant">ip_addr_counter.go:53</span>
</span>
<span class="line">     54</span> <span class="nop">           .          .           	} </span>
</pre>
<h2>main.worker</h2><p class="filename">/home/mikhliuk/projects/lightspeed/ip_addr_counter.go</p>
<pre onclick="pprof_toggle_asm(event)">  Total:     64.15MB    64.15MB (flat, cum) 11.08%
<span class="line">     69</span> <span class="livesrc">           .          .           func worker(file *os.File, jobs &lt;-chan int64, bitmap []uint64) { </span><span class="asm">                   .          .   4c9f40:     CMPQ SP, 0x10(R14)                                                           <span class="unimportant">ip_addr_counter.go:69</span>
                   .          .   4c9f44:     JBE 0x4ca09c                                                                 <span class="unimportant">ip_addr_counter.go:69</span>
                   .          .   4c9f4a:     PUSHQ BP                                                                     <span class="unimportant">ip_addr_counter.go:69</span>
                   .          .   4c9f4b:     MOVQ SP, BP                                                                  <span class="unimportant">ip_addr_counter.go:69</span>
                   .          .   4c9f4e:     SUBQ $0x50, SP                                                               <span class="unimportant">ip_addr_counter.go:69</span>
                                     ⋮
                   .          .   4ca09c:     MOVQ AX, 0x8(SP)                                                             <span class="unimportant">ip_addr_counter.go:69</span>
                   .          .   4ca0a1:     MOVQ BX, 0x10(SP)                                                            <span class="unimportant">ip_addr_counter.go:69</span>
                   .          .   4ca0a6:     MOVQ CX, 0x18(SP)                                                            <span class="unimportant">ip_addr_counter.go:69</span>
                   .          .   4ca0ab:     MOVQ DI, 0x20(SP)                                                            <span class="unimportant">ip_addr_counter.go:69</span>
                   .          .   4ca0b0:     MOVQ SI, 0x28(SP)                                                            <span class="unimportant">ip_addr_counter.go:69</span>
                   .          .   4ca0b5:     CALL runtime.morestack_noctxt.abi0(SB)                                       <span class="unimportant">ip_addr_counter.go:69</span>
                   .          .   4ca0ba:     MOVQ 0x8(SP), AX                                                             <span class="unimportant">ip_addr_counter.go:69</span>
                   .          .   4ca0bf:     MOVQ 0x10(SP), BX                                                            <span class="unimportant">ip_addr_counter.go:69</span>
                   .          .   4ca0c4:     MOVQ 0x18(SP), CX                                                            <span class="unimportant">ip_addr_counter.go:69</span>
                   .          .   4ca0c9:     MOVQ 0x20(SP), DI                                                            <span class="unimportant">ip_addr_counter.go:69</span>
                   .          .   4ca0ce:     MOVQ 0x28(SP), SI                                                            <span class="unimportant">ip_addr_counter.go:69</span>
                   .          .   4ca0d3:     JMP main.worker(SB)                                                          <span class="unimportant">ip_addr_counter.go:69</span>
</span>
<span class="line">     70</span> <span class="livesrc">     64.15MB    64.15MB           	buf := make([]byte, workerBufSize+128) </span><span class="asm" style="display: block;">                   .          .   4c9f6e:             LEAQ 0xcb2b(IP), AX                                                  <span class="unimportant">ip_addr_counter.go:70</span>
                   .          .   4c9f75:             MOVL $0x400080, BX                                                   <span class="unimportant">ip_addr_counter.go:70</span>
                   .          .   4c9f7a:             MOVQ BX, CX                                                          <span class="unimportant">ip_addr_counter.go:70</span>
                   .          .   4c9f7d:             NOPL 0(AX)                                                           <span class="unimportant">ip_addr_counter.go:70</span>
             64.15MB    64.15MB   4c9f80:             CALL runtime.makeslice(SB)                                           <span class="unimportant">ip_addr_counter.go:70</span>
                   .          .   4c9f85:             MOVQ AX, 0x48(SP)                                                    <span class="unimportant">ip_addr_counter.go:70</span>
</span>
<span class="line">     71</span> <span class="nop">           .          .            </span>
<span class="line">     72</span> <span class="livesrc">           .          .           	for offset := range jobs { </span><span class="asm">                   .          .   4c9f52:             MOVQ AX, 0x60(SP)                                                    <span class="unimportant">ip_addr_counter.go:72</span>
                   .          .   4c9f57:             MOVQ BX, 0x68(SP)                                                    <span class="unimportant">ip_addr_counter.go:72</span>
                   .          .   4c9f5c:             MOVQ CX, 0x70(SP)                                                    <span class="unimportant">ip_addr_counter.go:72</span>
                   .          .   4c9f61:             MOVQ SI, 0x80(SP)                                                    <span class="unimportant">ip_addr_counter.go:72</span>
                   .          .   4c9f69:             MOVQ DI, 0x78(SP)                                                    <span class="unimportant">ip_addr_counter.go:72</span>
                                     ⋮
                   .          .   4c9f8a:             MOVQ 0x68(SP), AX                                                    <span class="unimportant">ip_addr_counter.go:72</span>
                   .          .   4c9f8f:             LEAQ 0x40(SP), BX                                                    <span class="unimportant">ip_addr_counter.go:72</span>
                   .          .   4c9f94:             CALL runtime.chanrecv2(SB)                                           <span class="unimportant">ip_addr_counter.go:72</span>
                   .          .   4c9f99:             NOPL 0(AX)                                                           <span class="unimportant">ip_addr_counter.go:72</span>
                   .          .   4c9fa0:             TESTL AL, AL                                                         <span class="unimportant">ip_addr_counter.go:72</span>
                   .          .   4c9fa2:             JE 0x4ca045                                                          <span class="unimportant">ip_addr_counter.go:72</span>
                   .          .   4c9fa8:             MOVQ 0x40(SP), SI                                                    <span class="unimportant">ip_addr_counter.go:72</span>
                   .          .   4c9fad:             MOVQ SI, 0x38(SP)                                                    <span class="unimportant">ip_addr_counter.go:72</span>
                   .          .   4c9fb2:             MOVQ $0x0, 0x40(SP)                                                  <span class="unimportant">ip_addr_counter.go:72</span>
</span>
<span class="line">     73</span> <span class="livesrc">           .          .           		endIdx, _ := file.ReadAt(buf, offset) </span><span class="asm">                   .          .   4c9fbb:                     MOVQ 0x60(SP), AX                                            <span class="unimportant">ip_addr_counter.go:73</span>
                   .          .   4c9fc0:                     MOVQ 0x48(SP), BX                                            <span class="unimportant">ip_addr_counter.go:73</span>
                   .          .   4c9fc5:                     MOVL $0x400080, CX                                           <span class="unimportant">ip_addr_counter.go:73</span>
                   .          .   4c9fca:                     MOVQ CX, DI                                                  <span class="unimportant">ip_addr_counter.go:73</span>
                   .          .   4c9fcd:                     CALL os.(*File).ReadAt(SB)                                   <span class="unimportant">ip_addr_counter.go:73</span>
                                     ⋮
                   .          .   4ca04b:                     MOVQ AX, DX                                                  <span class="unimportant">ip_addr_counter.go:73</span>
</span>
<span class="line">     74</span> <span class="nop">           .          .            </span>
<span class="line">     75</span> <span class="livesrc">           .          .           		if endIdx == 0 { </span><span class="asm">                   .          .   4c9fd2:                     TESTQ AX, AX                                                 <span class="unimportant">ip_addr_counter.go:75</span>
                   .          .   4c9fd5:                     JE 0x4c9f8a                                                  <span class="unimportant">ip_addr_counter.go:75</span>
</span>
<span class="line">     76</span> <span class="nop">           .          .           			continue </span>
<span class="line">     77</span> <span class="nop">           .          .           		} </span>
<span class="line">     78</span> <span class="nop">           .          .            </span>
<span class="line">     79</span> <span class="livesrc">           .          .           		startIdx := findStartIdx(buf, offset, endIdx) </span><span class="asm">                   .          .   4c9fd7:                     NOPL                                                         <span class="unimportant">ip_addr_counter.go:79</span>
</span>
<span class="line">     80</span> <span class="nop">           .          .            </span>
<span class="line">     81</span> <span class="livesrc">           .          .           		parseAndSet(buf[startIdx:endIdx], offset, bitmap) </span><span class="asm">                   .          .   4c9ff0:                     CMPQ AX, $0x400080                                           <span class="unimportant">ip_addr_counter.go:81</span>
                   .          .   4c9ff6:                     JA 0x4ca059                                                  <span class="unimportant">ip_addr_counter.go:81</span>
                   .          .   4c9ff8:                     CMPQ AX, CX                                                  <span class="unimportant">ip_addr_counter.go:81</span>
                   .          .   4c9ffb:                     JB 0x4ca04b                                                  <span class="unimportant">ip_addr_counter.go:81</span>
                   .          .   4c9ffd:                     SUBQ CX, AX                                                  <span class="unimportant">ip_addr_counter.go:81</span>
                   .          .   4ca000:                     LEAQ 0xffbfff80(CX), DX                                      <span class="unimportant">ip_addr_counter.go:81</span>
                   .          .   4ca007:                     MOVQ DX, R10                                                 <span class="unimportant">ip_addr_counter.go:81</span>
                   .          .   4ca00a:                     NEGQ DX                                                      <span class="unimportant">ip_addr_counter.go:81</span>
                   .          .   4ca00d:                     SARQ $0x3f, R10                                              <span class="unimportant">ip_addr_counter.go:81</span>
                   .          .   4ca011:                     ANDQ R10, CX                                                 <span class="unimportant">ip_addr_counter.go:81</span>
                   .          .   4ca014:                     MOVQ 0x48(SP), R10                                           <span class="unimportant">ip_addr_counter.go:81</span>
                   .          .   4ca019:                     ADDQ CX, R10                                                 <span class="unimportant">ip_addr_counter.go:81</span>
                   .          .   4ca01c:                     MOVQ AX, BX                                                  <span class="unimportant">ip_addr_counter.go:81</span>
                   .          .   4ca01f:                     MOVQ DX, CX                                                  <span class="unimportant">ip_addr_counter.go:81</span>
                   .          .   4ca022:                     MOVQ 0x70(SP), SI                                            <span class="unimportant">ip_addr_counter.go:81</span>
                   .          .   4ca027:                     MOVQ 0x78(SP), R8                                            <span class="unimportant">ip_addr_counter.go:81</span>
                   .          .   4ca02c:                     MOVQ 0x80(SP), R9                                            <span class="unimportant">ip_addr_counter.go:81</span>
                   .          .   4ca034:                     MOVQ R10, AX                                                 <span class="unimportant">ip_addr_counter.go:81</span>
                   .          .   4ca037:                     CALL main.parseAndSet(SB)                                    <span class="unimportant">ip_addr_counter.go:81</span>
                   .          .   4ca03c:                     NOPL 0(AX)                                                   <span class="unimportant">ip_addr_counter.go:81</span>
                   .          .   4ca040:                     JMP 0x4c9f8a                                                 <span class="unimportant">ip_addr_counter.go:81</span>
                                     ⋮
                   .          .   4ca04e:                     MOVQ CX, AX                                                  <span class="unimportant">ip_addr_counter.go:81</span>
                   .          .   4ca051:                     MOVQ DX, CX                                                  <span class="unimportant">ip_addr_counter.go:81</span>
                   .          .   4ca054:                     CALL runtime.panicSliceB(SB)                                 <span class="unimportant">ip_addr_counter.go:81</span>
                   .          .   4ca059:                     MOVQ AX, CX                                                  <span class="unimportant">ip_addr_counter.go:81</span>
                   .          .   4ca05c:                     MOVL $0x400080, DX                                           <span class="unimportant">ip_addr_counter.go:81</span>
                   .          .   4ca061:                     CALL runtime.panicSliceAcap(SB)                              <span class="unimportant">ip_addr_counter.go:81</span>
</span>
<span class="line">     82</span> <span class="nop">           .          .           	} </span>
<span class="line">     83</span> <span class="livesrc">           .          .           } </span><span class="asm">                   .          .   4ca045:     ADDQ $0x50, SP                                                               <span class="unimportant">ip_addr_counter.go:83</span>
                   .          .   4ca049:     POPQ BP                                                                      <span class="unimportant">ip_addr_counter.go:83</span>
                   .          .   4ca04a:     RET                                                                          <span class="unimportant">ip_addr_counter.go:83</span>
</span>
<span class="line">     84</span> <span class="nop">           .          .            </span>
<span class="line">     85</span> <span class="nop">           .          .           func findStartIdx(buf []byte, offset int64, endIdx int) int { </span>
<span class="line">     86</span> <span class="nop">           .          .           	startIdx := 0 </span>
<span class="line">     87</span> <span class="nop">           .          .            </span>
<span class="line">     88</span> <span class="livesrc">           .          .           	if offset &gt; 0 { </span><span class="asm">                   .          .   4c9fd8:             MOVQ 0x38(SP), DI                                                    <span class="unimportant">ip_addr_counter.go:88</span>
                   .          .   4c9fdd:             NOPL 0(AX)                                                           <span class="unimportant">ip_addr_counter.go:88</span>
                   .          .   4c9fe0:             TESTQ DI, DI                                                         <span class="unimportant">ip_addr_counter.go:88</span>
                   .          .   4c9fe3:             JLE 0x4c9fee                                                         <span class="unimportant">ip_addr_counter.go:88</span>
                   .          .   4c9fe5:             MOVQ 0x48(SP), R10                                                   <span class="unimportant">ip_addr_counter.go:88</span>
                   .          .   4c9fea:             XORL CX, CX                                                          <span class="unimportant">ip_addr_counter.go:88</span>
                   .          .   4c9fec:             JMP 0x4ca069                                                         <span class="unimportant">ip_addr_counter.go:88</span>
                   .          .   4c9fee:             XORL CX, CX                                                          <span class="unimportant">ip_addr_counter.go:88</span>
</span>
<span class="line">     89</span> <span class="livesrc">           .          .           		for startIdx &lt; endIdx &amp;&amp; buf[startIdx] != '\n' { </span><span class="asm">                   .          .   4ca069:                     CMPQ AX, CX                                                  <span class="unimportant">ip_addr_counter.go:89</span>
                   .          .   4ca06c:                     JLE 0x4ca086                                                 <span class="unimportant">ip_addr_counter.go:89</span>
                   .          .   4ca06e:                     CMPQ CX, $0x400080                                           <span class="unimportant">ip_addr_counter.go:89</span>
                   .          .   4ca075:                     JAE 0x4ca08e                                                 <span class="unimportant">ip_addr_counter.go:89</span>
                   .          .   4ca077:                     MOVZX 0(R10)(CX*1), R11                                      <span class="unimportant">ip_addr_counter.go:89</span>
                   .          .   4ca07c:                     NOPL 0(AX)                                                   <span class="unimportant">ip_addr_counter.go:89</span>
                   .          .   4ca080:                     CMPL R11, $0xa                                               <span class="unimportant">ip_addr_counter.go:89</span>
                   .          .   4ca084:                     JNE 0x4ca066                                                 <span class="unimportant">ip_addr_counter.go:89</span>
                                     ⋮
                   .          .   4ca08e:                     MOVQ CX, AX                                                  <span class="unimportant">ip_addr_counter.go:89</span>
                   .          .   4ca091:                     MOVL $0x400080, CX                                           <span class="unimportant">ip_addr_counter.go:89</span>
                   .          .   4ca096:                     CALL runtime.panicIndex(SB)                                  <span class="unimportant">ip_addr_counter.go:89</span>
                   .          .   4ca09b:                     NOPL                                                         <span class="unimportant">ip_addr_counter.go:89</span>
</span>
<span class="line">     90</span> <span class="livesrc">           .          .           			startIdx++ </span><span class="asm">                   .          .   4ca066:                             INCQ CX                                              <span class="unimportant">ip_addr_counter.go:90</span>
</span>
<span class="line">     91</span> <span class="nop">           .          .           		} </span>
<span class="line">     92</span> <span class="livesrc">           .          .           		startIdx++ </span><span class="asm">                   .          .   4ca086:                     INCQ CX                                                      <span class="unimportant">ip_addr_counter.go:92</span>
                   .          .   4ca089:                     JMP 0x4c9ff0                                                 <span class="unimportant">ip_addr_counter.go:92</span>
</span>
<span class="line">     93</span> <span class="nop">           .          .           	} </span>
<span class="line">     94</span> <span class="nop">           .          .            </span>
<span class="line">     95</span> <span class="nop">           .          .           	return startIdx </span>
<span class="line">     96</span> <span class="nop">           .          .           } </span>
<span class="line">     97</span> <span class="nop">           .          .            </span>
</pre>
<h2>runtime.main</h2><p class="filename">/home/mikhliuk/go/go1.25.4/src/runtime/proc.go</p>
<pre onclick="pprof_toggle_asm(event)">  Total:           0   512.50MB (flat, cum) 88.49%
<span class="line">    182</span> <span class="nop">           .          .           	// by calling runtime.LockOSThread during initialization </span>
<span class="line">    183</span> <span class="nop">           .          .           	// to preserve the lock. </span>
<span class="line">    184</span> <span class="nop">           .          .           	lockOSThread() </span>
<span class="line">    185</span> <span class="nop">           .          .            </span>
<span class="line">    186</span> <span class="nop">           .          .           	if mp != &amp;m0 { </span>
<span class="line">    187</span> <span class="livesrc">           .          .           		throw("runtime.main not on m0") </span><span class="asm">                   .          .   4404eb:                     LEAQ 0xb92bf(IP), AX                                         <span class="unimportant">proc.go:187</span>
                   .          .   4404f2:                     MOVL $0x16, BX                                               <span class="unimportant">proc.go:187</span>
                   .          .   4404f7:                     CALL runtime.throw(SB)                                       <span class="unimportant">proc.go:187</span>
                   .          .   4404fc:                     NOPL                                                         <span class="unimportant">proc.go:187</span>
                   .          .   4404fd:                     NOPL 0(AX)                                                   <span class="unimportant">proc.go:187</span>
                   .          .   440500:                     CALL runtime.deferreturn(SB)                                 <span class="unimportant">proc.go:187</span>
                   .          .   440505:                     SUBQ $-0x80, SP                                              <span class="unimportant">proc.go:187</span>
                   .          .   440509:                     POPQ BP                                                      <span class="unimportant">proc.go:187</span>
                   .          .   44050a:                     RET                                                          <span class="unimportant">proc.go:187</span>
</span>
<span class="line">    188</span> <span class="nop">           .          .           	} </span>
<span class="line">    189</span> <span class="nop">           .          .            </span>
<span class="line">    190</span> <span class="nop">           .          .           	// Record when the world started. </span>
<span class="line">    191</span> <span class="nop">           .          .           	// Must be before doInit for tracing init. </span>
<span class="line">    192</span> <span class="livesrc">           .          .           	runtimeInitTime = nanotime() </span><span class="asm">                   .          .   4401c4:             MOVQ AX, runtime.runtimeInitTime(SB)                                 <span class="unimportant">proc.go:192</span>
</span>
<span class="line">    193</span> <span class="livesrc">           .          .           	if runtimeInitTime == 0 { </span><span class="asm">                   .          .   4401cb:             TESTQ AX, AX                                                         <span class="unimportant">proc.go:193</span>
                   .          .   4401ce:             JE 0x4404da                                                          <span class="unimportant">proc.go:193</span>
</span>
<span class="line">    194</span> <span class="livesrc">           .          .           		throw("nanotime returning zero") </span><span class="asm">                   .          .   4404da:                     LEAQ 0xb96b0(IP), AX                                         <span class="unimportant">proc.go:194</span>
                   .          .   4404e1:                     MOVL $0x17, BX                                               <span class="unimportant">proc.go:194</span>
                   .          .   4404e6:                     CALL runtime.throw(SB)                                       <span class="unimportant">proc.go:194</span>
</span>
<span class="line">    195</span> <span class="nop">           .          .           	} </span>
<span class="line">    196</span> <span class="nop">           .          .            </span>
<span class="line">    197</span> <span class="livesrc">           .          .           	if debug.inittrace != 0 { </span><span class="asm">                   .          .   4401d4:             CMPL runtime.debug+112(SB), $0x0                                     <span class="unimportant">proc.go:197</span>
                   .          .   4401db:             JE 0x4401f2                                                          <span class="unimportant">proc.go:197</span>
</span>
<span class="line">    198</span> <span class="livesrc">           .          .           		inittrace.id = getg().goid </span><span class="asm">                   .          .   4401dd:                     MOVQ 0x98(R14), CX                                           <span class="unimportant">proc.go:198</span>
                   .          .   4401e4:                     MOVQ CX, runtime.inittrace+8(SB)                             <span class="unimportant">proc.go:198</span>
</span>
<span class="line">    199</span> <span class="livesrc">           .          .           		inittrace.active = true </span><span class="asm">                   .          .   4401eb:                     MOVB $0x1, runtime.inittrace(SB)                             <span class="unimportant">proc.go:199</span>
</span>
<span class="line">    200</span> <span class="nop">           .          .           	} </span>
<span class="line">    201</span> <span class="nop">           .          .            </span>
<span class="line">    202</span> <span class="livesrc">           .          .           	doInit(runtime_inittasks) // Must be before defer. </span><span class="asm">                   .          .   4401f2:             MOVQ runtime.runtime_inittasks(SB), CX                               <span class="unimportant">proc.go:202</span>
                   .          .   4401f9:             MOVQ CX, 0x58(SP)                                                    <span class="unimportant">proc.go:202</span>
                   .          .   4401fe:             MOVQ runtime.runtime_inittasks+8(SB), DX                             <span class="unimportant">proc.go:202</span>
                   .          .   440205:             MOVQ DX, 0x30(SP)                                                    <span class="unimportant">proc.go:202</span>
                   .          .   44020a:             XORL AX, AX                                                          <span class="unimportant">proc.go:202</span>
</span>
<span class="line">    203</span> <span class="nop">           .          .            </span>
<span class="line">    204</span> <span class="nop">           .          .           	// Defer unlock so that runtime.Goexit during init does the unlock too. </span>
<span class="line">    205</span> <span class="livesrc">           .          .           	needUnlock := true </span><span class="asm">                   .          .   440233:             MOVB $0x1, 0x26(SP)                                                  <span class="unimportant">proc.go:205</span>
</span>
<span class="line">    206</span> <span class="livesrc">           .          .           	defer func() { </span><span class="asm">                   .          .   440238:             LEAQ runtime.main.func2(SB), AX                                      <span class="unimportant">proc.go:206</span>
                   .          .   44023f:             MOVQ AX, 0x68(SP)                                                    <span class="unimportant">proc.go:206</span>
                   .          .   440244:             LEAQ 0x26(SP), AX                                                    <span class="unimportant">proc.go:206</span>
                   .          .   440249:             MOVQ AX, 0x70(SP)                                                    <span class="unimportant">proc.go:206</span>
                   .          .   44024e:             LEAQ 0x68(SP), AX                                                    <span class="unimportant">proc.go:206</span>
                   .          .   440253:             MOVQ AX, 0x78(SP)                                                    <span class="unimportant">proc.go:206</span>
                   .          .   440258:             MOVB $0x1, 0x27(SP)                                                  <span class="unimportant">proc.go:206</span>
</span>
<span class="line">    207</span> <span class="nop">           .          .           		if needUnlock { </span>
<span class="line">    208</span> <span class="nop">           .          .           			unlockOSThread() </span>
<span class="line">    209</span> <span class="nop">           .          .           		} </span>
<span class="line">    210</span> <span class="nop">           .          .           	}() </span>
<span class="line">    211</span> <span class="nop">           .          .            </span>
<span class="line">    212</span> <span class="livesrc">           .          .           	gcenable() </span><span class="asm">                   .          .   44025d:             NOPL 0(AX)                                                           <span class="unimportant">proc.go:212</span>
                   .          .   440260:             CALL runtime.gcenable(SB)                                            <span class="unimportant">proc.go:212</span>
</span>
<span class="line">    213</span> <span class="livesrc">           .          .           	defaultGOMAXPROCSUpdateEnable() // don't STW before runtime initialized. </span><span class="asm">                   .          .   440265:             CALL runtime.defaultGOMAXPROCSUpdateEnable(SB)                       <span class="unimportant">proc.go:213</span>
</span>
<span class="line">    214</span> <span class="nop">           .          .            </span>
<span class="line">    215</span> <span class="livesrc">           .          .           	main_init_done = make(chan bool) </span><span class="asm">                   .          .   44026a:             LEAQ 0x974af(IP), AX                                                 <span class="unimportant">proc.go:215</span>
                   .          .   440271:             XORL BX, BX                                                          <span class="unimportant">proc.go:215</span>
                   .          .   440273:             CALL runtime.makechan(SB)                                            <span class="unimportant">proc.go:215</span>
                   .          .   440278:             CMPL runtime.writeBarrier(SB), $0x0                                  <span class="unimportant">proc.go:215</span>
                   .          .   44027f:             NOPL                                                                 <span class="unimportant">proc.go:215</span>
                   .          .   440280:             JE 0x440295                                                          <span class="unimportant">proc.go:215</span>
                   .          .   440282:             MOVQ runtime.main_init_done(SB), CX                                  <span class="unimportant">proc.go:215</span>
                   .          .   440289:             CALL runtime.gcWriteBarrier2(SB)                                     <span class="unimportant">proc.go:215</span>
                   .          .   44028e:             MOVQ AX, 0(R11)                                                      <span class="unimportant">proc.go:215</span>
                   .          .   440291:             MOVQ CX, 0x8(R11)                                                    <span class="unimportant">proc.go:215</span>
                   .          .   440295:             MOVQ AX, runtime.main_init_done(SB)                                  <span class="unimportant">proc.go:215</span>
</span>
<span class="line">    216</span> <span class="livesrc">           .          .           	if iscgo { </span><span class="asm">                   .          .   44029c:             CMPB runtime.iscgo(SB), $0x0                                         <span class="unimportant">proc.go:216</span>
                   .          .   4402a3:             JE 0x440325                                                          <span class="unimportant">proc.go:216</span>
</span>
<span class="line">    217</span> <span class="livesrc">           .          .           		if _cgo_pthread_key_created == nil { </span><span class="asm">                   .          .   4402a9:                     CMPQ _cgo_pthread_key_created(SB), $0x0                      <span class="unimportant">proc.go:217</span>
                   .          .   4402b1:                     JE 0x4404c9                                                  <span class="unimportant">proc.go:217</span>
</span>
<span class="line">    218</span> <span class="livesrc">           .          .           			throw("_cgo_pthread_key_created missing") </span><span class="asm">                   .          .   4404c9:                             LEAQ 0xbb999(IP), AX                                 <span class="unimportant">proc.go:218</span>
                   .          .   4404d0:                             MOVL $0x20, BX                                       <span class="unimportant">proc.go:218</span>
                   .          .   4404d5:                             CALL runtime.throw(SB)                               <span class="unimportant">proc.go:218</span>
</span>
<span class="line">    219</span> <span class="nop">           .          .           		} </span>
<span class="line">    220</span> <span class="nop">           .          .            </span>
<span class="line">    221</span> <span class="livesrc">           .          .           		if _cgo_thread_start == nil { </span><span class="asm">                   .          .   4402b7:                     CMPQ _cgo_thread_start(SB), $0x0                             <span class="unimportant">proc.go:221</span>
                   .          .   4402bf:                     NOPL                                                         <span class="unimportant">proc.go:221</span>
                   .          .   4402c0:                     JE 0x4404b8                                                  <span class="unimportant">proc.go:221</span>
</span>
<span class="line">    222</span> <span class="livesrc">           .          .           			throw("_cgo_thread_start missing") </span><span class="asm">                   .          .   4404b8:                             LEAQ 0xb9d8b(IP), AX                                 <span class="unimportant">proc.go:222</span>
                   .          .   4404bf:                             MOVL $0x19, BX                                       <span class="unimportant">proc.go:222</span>
                   .          .   4404c4:                             CALL runtime.throw(SB)                               <span class="unimportant">proc.go:222</span>
</span>
<span class="line">    223</span> <span class="nop">           .          .           		} </span>
<span class="line">    224</span> <span class="nop">           .          .           		if GOOS != "windows" { </span>
<span class="line">    225</span> <span class="livesrc">           .          .           			if _cgo_setenv == nil { </span><span class="asm">                   .          .   4402c6:                             CMPQ runtime._cgo_setenv(SB), $0x0                   <span class="unimportant">proc.go:225</span>
                   .          .   4402ce:                             JE 0x4404a7                                          <span class="unimportant">proc.go:225</span>
</span>
<span class="line">    226</span> <span class="livesrc">           .          .           				throw("_cgo_setenv missing") </span><span class="asm">                   .          .   4404a7:                                     LEAQ 0xb8772(IP), AX                         <span class="unimportant">proc.go:226</span>
                   .          .   4404ae:                                     MOVL $0x13, BX                               <span class="unimportant">proc.go:226</span>
                   .          .   4404b3:                                     CALL runtime.throw(SB)                       <span class="unimportant">proc.go:226</span>
</span>
<span class="line">    227</span> <span class="nop">           .          .           			} </span>
<span class="line">    228</span> <span class="livesrc">           .          .           			if _cgo_unsetenv == nil { </span><span class="asm">                   .          .   4402d4:                             CMPQ runtime._cgo_unsetenv(SB), $0x0                 <span class="unimportant">proc.go:228</span>
                   .          .   4402dc:                             NOPL 0(AX)                                           <span class="unimportant">proc.go:228</span>
                   .          .   4402e0:                             JE 0x440496                                          <span class="unimportant">proc.go:228</span>
</span>
<span class="line">    229</span> <span class="livesrc">           .          .           				throw("_cgo_unsetenv missing") </span><span class="asm">                   .          .   440496:                                     LEAQ 0xb8eb6(IP), AX                         <span class="unimportant">proc.go:229</span>
                   .          .   44049d:                                     MOVL $0x15, BX                               <span class="unimportant">proc.go:229</span>
                   .          .   4404a2:                                     CALL runtime.throw(SB)                       <span class="unimportant">proc.go:229</span>
</span>
<span class="line">    230</span> <span class="nop">           .          .           			} </span>
<span class="line">    231</span> <span class="nop">           .          .           		} </span>
<span class="line">    232</span> <span class="livesrc">           .          .           		if _cgo_notify_runtime_init_done == nil { </span><span class="asm">                   .          .   4402e6:                     CMPQ _cgo_notify_runtime_init_done(SB), $0x0                 <span class="unimportant">proc.go:232</span>
                   .          .   4402ee:                     JE 0x440485                                                  <span class="unimportant">proc.go:232</span>
</span>
<span class="line">    233</span> <span class="livesrc">           .          .           			throw("_cgo_notify_runtime_init_done missing") </span><span class="asm">                   .          .   440485:                             LEAQ 0xbcbda(IP), AX                                 <span class="unimportant">proc.go:233</span>
                   .          .   44048c:                             MOVL $0x25, BX                                       <span class="unimportant">proc.go:233</span>
                   .          .   440491:                             CALL runtime.throw(SB)                               <span class="unimportant">proc.go:233</span>
</span>
<span class="line">    234</span> <span class="nop">           .          .           		} </span>
<span class="line">    235</span> <span class="nop">           .          .            </span>
<span class="line">    236</span> <span class="nop">           .          .           		// Set the x_crosscall2_ptr C function pointer variable point to crosscall2. </span>
<span class="line">    237</span> <span class="livesrc">           .          .           		if set_crosscall2 == nil { </span><span class="asm">                   .          .   4402f4:                     MOVQ runtime.set_crosscall2(SB), DX                          <span class="unimportant">proc.go:237</span>
                   .          .   4402fb:                     NOPL 0(AX)(AX*1)                                             <span class="unimportant">proc.go:237</span>
                   .          .   440300:                     TESTQ DX, DX                                                 <span class="unimportant">proc.go:237</span>
                   .          .   440303:                     JE 0x440471                                                  <span class="unimportant">proc.go:237</span>
</span>
<span class="line">    238</span> <span class="livesrc">           .          .           			throw("set_crosscall2 missing") </span><span class="asm">                   .          .   440471:                             LEAQ 0xb934f(IP), AX                                 <span class="unimportant">proc.go:238</span>
                   .          .   440478:                             MOVL $0x16, BX                                       <span class="unimportant">proc.go:238</span>
                   .          .   44047d:                             NOPL 0(AX)                                           <span class="unimportant">proc.go:238</span>
                   .          .   440480:                             CALL runtime.throw(SB)                               <span class="unimportant">proc.go:238</span>
</span>
<span class="line">    239</span> <span class="nop">           .          .           		} </span>
<span class="line">    240</span> <span class="livesrc">           .          .           		set_crosscall2() </span><span class="asm">                   .          .   440309:                     MOVQ 0(DX), AX                                               <span class="unimportant">proc.go:240</span>
                   .          .   44030c:                     CALL AX                                                      <span class="unimportant">proc.go:240</span>
</span>
<span class="line">    241</span> <span class="nop">           .          .            </span>
<span class="line">    242</span> <span class="nop">           .          .           		// Start the template thread in case we enter Go from </span>
<span class="line">    243</span> <span class="nop">           .          .           		// a C-created thread and need to create a new thread. </span>
<span class="line">    244</span> <span class="livesrc">           .          .           		startTemplateThread() </span><span class="asm">                   .          .   44030e:                     CALL runtime.startTemplateThread(SB)                         <span class="unimportant">proc.go:244</span>
</span>
<span class="line">    245</span> <span class="livesrc">           .          .           		cgocall(_cgo_notify_runtime_init_done, nil) </span><span class="asm">                   .          .   440313:                     MOVQ _cgo_notify_runtime_init_done(SB), AX                   <span class="unimportant">proc.go:245</span>
                   .          .   44031a:                     XORL BX, BX                                                  <span class="unimportant">proc.go:245</span>
                   .          .   44031c:                     NOPL 0(AX)                                                   <span class="unimportant">proc.go:245</span>
                   .          .   440320:                     CALL runtime.cgocall(SB)                                     <span class="unimportant">proc.go:245</span>
</span>
<span class="line">    246</span> <span class="nop">           .          .           	} </span>
<span class="line">    247</span> <span class="nop">           .          .            </span>
<span class="line">    248</span> <span class="nop">           .          .           	// Run the initializing tasks. Depending on build mode this </span>
<span class="line">    249</span> <span class="nop">           .          .           	// list can arrive a few different ways, but it will always </span>
<span class="line">    250</span> <span class="nop">           .          .           	// contain the init tasks computed by the linker for all the </span>
<span class="line">    251</span> <span class="nop">           .          .           	// packages in the program (excluding those added at runtime </span>
<span class="line">    252</span> <span class="nop">           .          .           	// by package plugin). Run through the modules in dependency </span>
<span class="line">    253</span> <span class="nop">           .          .           	// order (the order they are initialized by the dynamic </span>
<span class="line">    254</span> <span class="nop">           .          .           	// loader, i.e. they are added to the moduledata linked list). </span>
<span class="line">    255</span> <span class="livesrc">           .          .           	for m := &amp;firstmoduledata; m != nil; m = m.next { </span><span class="asm">                   .          .   44032e:             MOVQ 0x240(AX), AX                                                   <span class="unimportant">proc.go:255</span>
                   .          .   440335:             TESTQ AX, AX                                                         <span class="unimportant">proc.go:255</span>
                   .          .   440338:             JE 0x44035e                                                          <span class="unimportant">proc.go:255</span>
                   .          .   44033a:             MOVQ AX, 0x38(SP)                                                    <span class="unimportant">proc.go:255</span>
                                     ⋮
                   .          .   440458:             MOVQ 0x38(SP), AX                                                    <span class="unimportant">proc.go:255</span>
</span>
<span class="line">    256</span> <span class="livesrc">           .          .           		doInit(m.inittasks) </span><span class="asm">                   .          .   44033f:                     MOVQ 0x1d0(AX), CX                                           <span class="unimportant">proc.go:256</span>
                   .          .   440346:                     MOVQ CX, 0x50(SP)                                            <span class="unimportant">proc.go:256</span>
                   .          .   44034b:                     MOVQ 0x1d8(AX), DX                                           <span class="unimportant">proc.go:256</span>
                   .          .   440352:                     MOVQ DX, 0x28(SP)                                            <span class="unimportant">proc.go:256</span>
                   .          .   440357:                     XORL BX, BX                                                  <span class="unimportant">proc.go:256</span>
</span>
<span class="line">    257</span> <span class="nop">           .          .           	} </span>
<span class="line">    258</span> <span class="nop">           .          .            </span>
<span class="line">    259</span> <span class="nop">           .          .           	// Disable init tracing after main init done to avoid overhead </span>
<span class="line">    260</span> <span class="nop">           .          .           	// of collecting statistics in malloc and newproc </span>
<span class="line">    261</span> <span class="livesrc">           .          .           	inittrace.active = false </span><span class="asm">                   .          .   440325:             LEAQ runtime.firstmoduledata(SB), AX                                 <span class="unimportant">proc.go:261</span>
                   .          .   44032c:             JMP 0x440335                                                         <span class="unimportant">proc.go:261</span>
                                     ⋮
                   .          .   44035e:             MOVB $0x0, runtime.inittrace(SB)                                     <span class="unimportant">proc.go:261</span>
</span>
<span class="line">    262</span> <span class="nop">           .          .            </span>
<span class="line">    263</span> <span class="livesrc">           .          .           	close(main_init_done) </span><span class="asm">                   .          .   440365:             MOVQ runtime.main_init_done(SB), AX                                  <span class="unimportant">proc.go:263</span>
                   .          .   44036c:             CALL runtime.closechan(SB)                                           <span class="unimportant">proc.go:263</span>
</span>
<span class="line">    264</span> <span class="nop">           .          .            </span>
<span class="line">    265</span> <span class="livesrc">           .          .           	needUnlock = false </span><span class="asm">                   .          .   440371:             MOVB $0x0, 0x26(SP)                                                  <span class="unimportant">proc.go:265</span>
</span>
<span class="line">    266</span> <span class="livesrc">           .          .           	unlockOSThread() </span><span class="asm">                   .          .   440376:             CALL runtime.unlockOSThread(SB)                                      <span class="unimportant">proc.go:266</span>
</span>
<span class="line">    267</span> <span class="nop">           .          .            </span>
<span class="line">    268</span> <span class="livesrc">           .          .           	if isarchive || islibrary { </span><span class="asm">                   .          .   44037b:             CMPB runtime.isarchive(SB), $0x0                                     <span class="unimportant">proc.go:268</span>
                   .          .   440382:             JNE 0x4403ae                                                         <span class="unimportant">proc.go:268</span>
                   .          .   440384:             CMPB runtime.islibrary(SB), $0x0                                     <span class="unimportant">proc.go:268</span>
                   .          .   44038b:             JNE 0x4403ae                                                         <span class="unimportant">proc.go:268</span>
</span>
<span class="line">    269</span> <span class="nop">           .          .           		// A program compiled with -buildmode=c-archive or c-shared </span>
<span class="line">    270</span> <span class="nop">           .          .           		// has a main, but it is not executed. </span>
<span class="line">    271</span> <span class="nop">           .          .           		if GOARCH == "wasm" { </span>
<span class="line">    272</span> <span class="nop">           .          .           			// On Wasm, pause makes it return to the host. </span>
<span class="line">    273</span> <span class="nop">           .          .           			// Unlike cgo callbacks where Ms are created on demand, </span>
<span class="line">    274</span> <span class="nop">           .          .           			// on Wasm we have only one M. So we keep this M (and this </span>
<span class="line">    275</span> <span class="nop">           .          .           			// G) for callbacks. </span>
<span class="line">    276</span> <span class="nop">           .          .           			// Using the caller's SP unwinds this frame and backs to </span>
<span class="line">    277</span> <span class="nop">           .          .           			// goexit. The -16 is: 8 for goexit's (fake) return PC, </span>
<span class="line">    278</span> <span class="nop">           .          .           			// and pause's epilogue pops 8. </span>
<span class="line">    279</span> <span class="nop">           .          .           			pause(sys.GetCallerSP() - 16) // should not return </span>
<span class="line">    280</span> <span class="nop">           .          .           			panic("unreachable") </span>
<span class="line">    281</span> <span class="nop">           .          .           		} </span>
<span class="line">    282</span> <span class="livesrc">           .          .           		return </span><span class="asm">                   .          .   4403ae:                     MOVB $0x0, 0x27(SP)                                          <span class="unimportant">proc.go:282</span>
                   .          .   4403b3:                     MOVQ 0x78(SP), DX                                            <span class="unimportant">proc.go:282</span>
                   .          .   4403b8:                     MOVQ 0(DX), AX                                               <span class="unimportant">proc.go:282</span>
                   .          .   4403bb:                     CALL AX                                                      <span class="unimportant">proc.go:282</span>
                   .          .   4403bd:                     SUBQ $-0x80, SP                                              <span class="unimportant">proc.go:282</span>
                   .          .   4403c1:                     POPQ BP                                                      <span class="unimportant">proc.go:282</span>
                   .          .   4403c2:                     RET                                                          <span class="unimportant">proc.go:282</span>
</span>
<span class="line">    283</span> <span class="nop">           .          .           	} </span>
<span class="line">    284</span> <span class="nop">           .          .           	fn := main_main // make an indirect call, as the linker doesn't know the address of the main package when laying down the runtime </span>
<span class="line">    285</span> <span class="livesrc">           .   512.50MB           	fn() </span><span class="asm" style="display: block;">                   .          .   44038d:             MOVQ 0xc06e4(IP), AX                                                 <span class="unimportant">proc.go:285</span>
                   .          .   440394:             LEAQ 0xc06dd(IP), DX                                                 <span class="unimportant">proc.go:285</span>
                   .   512.50MB   44039b:             CALL AX                                                              <span class="unimportant">proc.go:285</span>
</span>
<span class="line">    286</span> <span class="nop">           .          .            </span>
<span class="line">    287</span> <span class="nop">           .          .           	exitHooksRun := false </span>
<span class="line">    288</span> <span class="nop">           .          .           	if raceenabled { </span>
<span class="line">    289</span> <span class="nop">           .          .           		runExitHooks(0) // run hooks now, since racefini does not return </span>
<span class="line">    290</span> <span class="nop">           .          .           		exitHooksRun = true </span>
</pre>
<h2>runtime.acquireSudog</h2><p class="filename">/home/mikhliuk/go/go1.25.4/src/runtime/proc.go</p>
<pre onclick="pprof_toggle_asm(event)">  Total:    512.05kB   512.05kB (flat, cum) 0.086%
<span class="line">    495</span> <span class="nop">           .          .           	mp := acquirem() </span>
<span class="line">    496</span> <span class="nop">           .          .           	pp := mp.p.ptr() </span>
<span class="line">    497</span> <span class="nop">           .          .           	if len(pp.sudogcache) == 0 { </span>
<span class="line">    498</span> <span class="nop">           .          .           		lock(&amp;sched.sudoglock) </span>
<span class="line">    499</span> <span class="nop">           .          .           		// First, try to grab a batch from central cache. </span>
<span class="line">    500</span> <span class="livesrc">           .          .           		for len(pp.sudogcache) &lt; cap(pp.sudogcache)/2 &amp;&amp; sched.sudogcache != nil { </span><span class="asm">                   .          .   44089d:                     MOVQ 0x9b8(CX), DX                                           <span class="unimportant">proc.go:500</span>
                   .          .   4408a4:                     SHRQ $0x1, DX                                                <span class="unimportant">proc.go:500</span>
                   .          .   4408a7:                     CMPQ 0x9b0(CX), DX                                           <span class="unimportant">proc.go:500</span>
                   .          .   4408ae:                     JGE 0x44099c                                                 <span class="unimportant">proc.go:500</span>
                   .          .   4408b4:                     MOVQ runtime.sched+216(SB), DX                               <span class="unimportant">proc.go:500</span>
                   .          .   4408bb:                     NOPL 0(AX)(AX*1)                                             <span class="unimportant">proc.go:500</span>
                   .          .   4408c0:                     TESTQ DX, DX                                                 <span class="unimportant">proc.go:500</span>
                   .          .   4408c3:                     JE 0x44099c                                                  <span class="unimportant">proc.go:500</span>
                                     ⋮
                   .          .   44091d:                     MOVQ DX, 0x48(SP)                                            <span class="unimportant">proc.go:500</span>
</span>
<span class="line">    501</span> <span class="nop">           .          .           			s := sched.sudogcache </span>
<span class="line">    502</span> <span class="livesrc">           .          .           			sched.sudogcache = s.next </span><span class="asm">                   .          .   4408c9:                             MOVQ 0x8(DX), R8                                     <span class="unimportant">proc.go:502</span>
                   .          .   4408cd:                             CMPL runtime.writeBarrier(SB), $0x0                  <span class="unimportant">proc.go:502</span>
                   .          .   4408d4:                             JE 0x4408f1                                          <span class="unimportant">proc.go:502</span>
                   .          .   4408d6:                             MOVQ runtime.sched+216(SB), R9                       <span class="unimportant">proc.go:502</span>
                                     ⋮
                   .          .   4408e1:                             CALL runtime.gcWriteBarrier3(SB)                     <span class="unimportant">proc.go:502</span>
                   .          .   4408e6:                             MOVQ R8, 0(R11)                                      <span class="unimportant">proc.go:502</span>
                   .          .   4408e9:                             MOVQ R9, 0x8(R11)                                    <span class="unimportant">proc.go:502</span>
                                     ⋮
                   .          .   4408f1:                             MOVQ R8, runtime.sched+216(SB)                       <span class="unimportant">proc.go:502</span>
</span>
<span class="line">    503</span> <span class="livesrc">           .          .           			s.next = nil </span><span class="asm">                   .          .   4408dd:                             MOVQ 0x8(DX), R10                                    <span class="unimportant">proc.go:503</span>
                                     ⋮
                   .          .   4408ed:                             MOVQ R10, 0x10(R11)                                  <span class="unimportant">proc.go:503</span>
                                     ⋮
                   .          .   4408f8:                             MOVQ $0x0, 0x8(DX)                                   <span class="unimportant">proc.go:503</span>
</span>
<span class="line">    504</span> <span class="livesrc">           .          .           			pp.sudogcache = append(pp.sudogcache, s) </span><span class="asm">                   .          .   440898:                             MOVQ DX, -0x8(AX)(BX*8)                              <span class="unimportant">proc.go:504</span>
                                     ⋮
                   .          .   440900:                             MOVQ 0x9b8(CX), R8                                   <span class="unimportant">proc.go:504</span>
                   .          .   440907:                             MOVQ 0x9b0(CX), BX                                   <span class="unimportant">proc.go:504</span>
                   .          .   44090e:                             INCQ BX                                              <span class="unimportant">proc.go:504</span>
                   .          .   440911:                             MOVQ 0x9a8(CX), AX                                   <span class="unimportant">proc.go:504</span>
                   .          .   440918:                             CMPQ R8, BX                                          <span class="unimportant">proc.go:504</span>
                   .          .   44091b:                             JAE 0x44096d                                         <span class="unimportant">proc.go:504</span>
                                     ⋮
                   .          .   440922:                             MOVQ R8, CX                                          <span class="unimportant">proc.go:504</span>
                   .          .   440925:                             MOVL $0x1, DI                                        <span class="unimportant">proc.go:504</span>
                   .          .   44092a:                             LEAQ 0x92d8f(IP), SI                                 <span class="unimportant">proc.go:504</span>
                   .          .   440931:                             CALL runtime.growslice(SB)                           <span class="unimportant">proc.go:504</span>
                   .          .   440936:                             MOVQ 0x50(SP), DX                                    <span class="unimportant">proc.go:504</span>
                   .          .   44093b:                             MOVQ CX, 0x9b8(DX)                                   <span class="unimportant">proc.go:504</span>
                   .          .   440942:                             CMPL runtime.writeBarrier(SB), $0x0                  <span class="unimportant">proc.go:504</span>
                   .          .   440949:                             JE 0x44095e                                          <span class="unimportant">proc.go:504</span>
                   .          .   44094b:                             MOVQ 0x9a8(DX), R8                                   <span class="unimportant">proc.go:504</span>
                   .          .   440952:                             CALL runtime.gcWriteBarrier2(SB)                     <span class="unimportant">proc.go:504</span>
                   .          .   440957:                             MOVQ AX, 0(R11)                                      <span class="unimportant">proc.go:504</span>
                   .          .   44095a:                             MOVQ R8, 0x8(R11)                                    <span class="unimportant">proc.go:504</span>
                   .          .   44095e:                             MOVQ AX, 0x9a8(DX)                                   <span class="unimportant">proc.go:504</span>
                   .          .   440965:                             MOVQ DX, CX                                          <span class="unimportant">proc.go:504</span>
                   .          .   440968:                             MOVQ 0x48(SP), DX                                    <span class="unimportant">proc.go:504</span>
                   .          .   44096d:                             MOVQ BX, 0x9b0(CX)                                   <span class="unimportant">proc.go:504</span>
                   .          .   440974:                             CMPL runtime.writeBarrier(SB), $0x0                  <span class="unimportant">proc.go:504</span>
                   .          .   44097b:                             NOPL 0(AX)(AX*1)                                     <span class="unimportant">proc.go:504</span>
                   .          .   440980:                             JE 0x440898                                          <span class="unimportant">proc.go:504</span>
                   .          .   440986:                             MOVQ -0x8(AX)(BX*8), R8                              <span class="unimportant">proc.go:504</span>
                   .          .   44098b:                             CALL runtime.gcWriteBarrier2(SB)                     <span class="unimportant">proc.go:504</span>
                   .          .   440990:                             MOVQ DX, 0(R11)                                      <span class="unimportant">proc.go:504</span>
                   .          .   440993:                             MOVQ R8, 0x8(R11)                                    <span class="unimportant">proc.go:504</span>
                   .          .   440997:                             JMP 0x440898                                         <span class="unimportant">proc.go:504</span>
</span>
<span class="line">    505</span> <span class="nop">           .          .           		} </span>
<span class="line">    506</span> <span class="livesrc">           .          .           		unlock(&amp;sched.sudoglock) </span><span class="asm">                   .          .   44099c:                     NOPL                                                         <span class="unimportant">proc.go:506</span>
</span>
<span class="line">    507</span> <span class="nop">           .          .           		// If the central cache is empty, allocate a new one. </span>
<span class="line">    508</span> <span class="livesrc">           .          .           		if len(pp.sudogcache) == 0 { </span><span class="asm">                   .          .   4409aa:                     MOVQ 0x50(SP), CX                                            <span class="unimportant">proc.go:508</span>
                   .          .   4409af:                     CMPQ 0x9b0(CX), $0x0                                         <span class="unimportant">proc.go:508</span>
                   .          .   4409b7:                     JNE 0x440a67                                                 <span class="unimportant">proc.go:508</span>
</span>
<span class="line">    509</span> <span class="livesrc">    512.05kB   512.05kB           			pp.sudogcache = append(pp.sudogcache, new(sudog)) </span><span class="asm">                   .          .   4409bd:                             LEAQ 0xafb1c(IP), AX                                 <span class="unimportant">proc.go:509</span>
            512.05kB   512.05kB   4409c4:                             CALL runtime.newobject(SB)                           <span class="unimportant">proc.go:509</span>
                   .          .   4409c9:                             MOVQ 0x50(SP), CX                                    <span class="unimportant">proc.go:509</span>
                   .          .   4409ce:                             MOVQ 0x9b8(CX), DX                                   <span class="unimportant">proc.go:509</span>
                   .          .   4409d5:                             MOVQ 0x9b0(CX), BX                                   <span class="unimportant">proc.go:509</span>
                   .          .   4409dc:                             INCQ BX                                              <span class="unimportant">proc.go:509</span>
                   .          .   4409df:                             MOVQ 0x9a8(CX), SI                                   <span class="unimportant">proc.go:509</span>
                   .          .   4409e6:                             CMPQ DX, BX                                          <span class="unimportant">proc.go:509</span>
                   .          .   4409e9:                             JAE 0x440a41                                         <span class="unimportant">proc.go:509</span>
                   .          .   4409eb:                             MOVQ AX, 0x48(SP)                                    <span class="unimportant">proc.go:509</span>
                   .          .   4409f0:                             MOVQ SI, AX                                          <span class="unimportant">proc.go:509</span>
                   .          .   4409f3:                             MOVQ DX, CX                                          <span class="unimportant">proc.go:509</span>
                   .          .   4409f6:                             MOVL $0x1, DI                                        <span class="unimportant">proc.go:509</span>
                   .          .   4409fb:                             LEAQ 0x92cbe(IP), SI                                 <span class="unimportant">proc.go:509</span>
                   .          .   440a02:                             CALL runtime.growslice(SB)                           <span class="unimportant">proc.go:509</span>
                   .          .   440a07:                             MOVQ 0x50(SP), DX                                    <span class="unimportant">proc.go:509</span>
                   .          .   440a0c:                             MOVQ CX, 0x9b8(DX)                                   <span class="unimportant">proc.go:509</span>
                   .          .   440a13:                             CMPL runtime.writeBarrier(SB), $0x0                  <span class="unimportant">proc.go:509</span>
                   .          .   440a1a:                             JE 0x440a2f                                          <span class="unimportant">proc.go:509</span>
                   .          .   440a1c:                             MOVQ 0x9a8(DX), SI                                   <span class="unimportant">proc.go:509</span>
                   .          .   440a23:                             CALL runtime.gcWriteBarrier2(SB)                     <span class="unimportant">proc.go:509</span>
                   .          .   440a28:                             MOVQ AX, 0(R11)                                      <span class="unimportant">proc.go:509</span>
                   .          .   440a2b:                             MOVQ SI, 0x8(R11)                                    <span class="unimportant">proc.go:509</span>
                   .          .   440a2f:                             MOVQ AX, 0x9a8(DX)                                   <span class="unimportant">proc.go:509</span>
                   .          .   440a36:                             MOVQ DX, CX                                          <span class="unimportant">proc.go:509</span>
                   .          .   440a39:                             MOVQ AX, SI                                          <span class="unimportant">proc.go:509</span>
                   .          .   440a3c:                             MOVQ 0x48(SP), AX                                    <span class="unimportant">proc.go:509</span>
                   .          .   440a41:                             MOVQ BX, 0x9b0(CX)                                   <span class="unimportant">proc.go:509</span>
                   .          .   440a48:                             CMPL runtime.writeBarrier(SB), $0x0                  <span class="unimportant">proc.go:509</span>
                   .          .   440a4f:                             JE 0x440a62                                          <span class="unimportant">proc.go:509</span>
                   .          .   440a51:                             MOVQ -0x8(SI)(BX*8), DI                              <span class="unimportant">proc.go:509</span>
                   .          .   440a56:                             CALL runtime.gcWriteBarrier2(SB)                     <span class="unimportant">proc.go:509</span>
                   .          .   440a5b:                             MOVQ AX, 0(R11)                                      <span class="unimportant">proc.go:509</span>
                   .          .   440a5e:                             MOVQ DI, 0x8(R11)                                    <span class="unimportant">proc.go:509</span>
                   .          .   440a62:                             MOVQ AX, -0x8(SI)(BX*8)                              <span class="unimportant">proc.go:509</span>
</span>
<span class="line">    510</span> <span class="nop">           .          .           		} </span>
<span class="line">    511</span> <span class="nop">           .          .           	} </span>
<span class="line">    512</span> <span class="livesrc">           .          .           	n := len(pp.sudogcache) </span><span class="asm">                   .          .   4407e9:             MOVQ 0x9b0(DI), AX                                                   <span class="unimportant">proc.go:512</span>
                                     ⋮
                   .          .   4407fd:             MOVQ 0x9a8(DI), R8                                                   <span class="unimportant">proc.go:512</span>
                                     ⋮
                   .          .   44088a:             MOVQ AX, DX                                                          <span class="unimportant">proc.go:512</span>
                                     ⋮
                   .          .   440a6c:             MOVQ CX, DI                                                          <span class="unimportant">proc.go:512</span>
                   .          .   440a6f:             JMP 0x4407e9                                                         <span class="unimportant">proc.go:512</span>
</span>
<span class="line">    513</span> <span class="livesrc">           .          .           	s := pp.sudogcache[n-1] </span><span class="asm">                   .          .   4407f0:             LEAQ -0x1(AX), CX                                                    <span class="unimportant">proc.go:513</span>
                   .          .   4407f4:             CMPQ AX, CX                                                          <span class="unimportant">proc.go:513</span>
                   .          .   4407f7:             JBE 0x44088a                                                         <span class="unimportant">proc.go:513</span>
                                     ⋮
                   .          .   440804:             MOVQ -0x8(R8)(AX*8), R9                                              <span class="unimportant">proc.go:513</span>
                                     ⋮
                   .          .   44088d:             MOVQ CX, AX                                                          <span class="unimportant">proc.go:513</span>
                   .          .   440890:             MOVQ DX, CX                                                          <span class="unimportant">proc.go:513</span>
                   .          .   440893:             CALL runtime.panicIndex(SB)                                          <span class="unimportant">proc.go:513</span>
</span>
<span class="line">    514</span> <span class="livesrc">           .          .           	pp.sudogcache[n-1] = nil </span><span class="asm">                   .          .   440809:             CMPL runtime.writeBarrier(SB), $0x0                                  <span class="unimportant">proc.go:514</span>
                   .          .   440810:             JE 0x44081f                                                          <span class="unimportant">proc.go:514</span>
                   .          .   440812:             MOVQ -0x8(R8)(AX*8), R10                                             <span class="unimportant">proc.go:514</span>
                   .          .   440817:             CALL runtime.gcWriteBarrier1(SB)                                     <span class="unimportant">proc.go:514</span>
                   .          .   44081c:             MOVQ R10, 0(R11)                                                     <span class="unimportant">proc.go:514</span>
                   .          .   44081f:             MOVQ $0x0, -0x8(R8)(AX*8)                                            <span class="unimportant">proc.go:514</span>
</span>
<span class="line">    515</span> <span class="livesrc">           .          .           	pp.sudogcache = pp.sudogcache[:n-1] </span><span class="asm">                   .          .   440828:             MOVQ 0x9b8(DI), DX                                                   <span class="unimportant">proc.go:515</span>
                   .          .   44082f:             CMPQ DX, CX                                                          <span class="unimportant">proc.go:515</span>
                   .          .   440832:             JB 0x440885                                                          <span class="unimportant">proc.go:515</span>
                   .          .   440834:             MOVQ CX, 0x9b0(DI)                                                   <span class="unimportant">proc.go:515</span>
                                     ⋮
                   .          .   440885:             CALL runtime.panicSliceAcap(SB)                                      <span class="unimportant">proc.go:515</span>
</span>
<span class="line">    516</span> <span class="livesrc">           .          .           	if s.elem != nil { </span><span class="asm">                   .          .   44083b:             CMPQ 0x18(R9), $0x0                                                  <span class="unimportant">proc.go:516</span>
                   .          .   440840:             JNE 0x440873                                                         <span class="unimportant">proc.go:516</span>
</span>
<span class="line">    517</span> <span class="livesrc">           .          .           		throw("acquireSudog: found s.elem != nil in cache") </span><span class="asm">                   .          .   440873:                     LEAQ 0xbd721(IP), AX                                         <span class="unimportant">proc.go:517</span>
                   .          .   44087a:                     MOVL $0x2a, BX                                               <span class="unimportant">proc.go:517</span>
                   .          .   44087f:                     NOPL                                                         <span class="unimportant">proc.go:517</span>
                   .          .   440880:                     CALL runtime.throw(SB)                                       <span class="unimportant">proc.go:517</span>
</span>
<span class="line">    518</span> <span class="nop">           .          .           	} </span>
<span class="line">    519</span> <span class="livesrc">           .          .           	releasem(mp) </span><span class="asm">                   .          .   44084b:             NOPL                                                                 <span class="unimportant">proc.go:519</span>
</span>
<span class="line">    520</span> <span class="livesrc">           .          .           	return s </span><span class="asm">                   .          .   44086a:             MOVQ R9, AX                                                          <span class="unimportant">proc.go:520</span>
                   .          .   44086d:             ADDQ $0x58, SP                                                       <span class="unimportant">proc.go:520</span>
                   .          .   440871:             POPQ BP                                                              <span class="unimportant">proc.go:520</span>
                   .          .   440872:             RET                                                                  <span class="unimportant">proc.go:520</span>
</span>
<span class="line">    521</span> <span class="nop">           .          .           } </span>
<span class="line">    522</span> <span class="nop">           .          .            </span>
<span class="line">    523</span> <span class="nop">           .          .           //go:nosplit </span>
<span class="line">    524</span> <span class="nop">           .          .           func releaseSudog(s *sudog) { </span>
<span class="line">    525</span> <span class="nop">           .          .           	if s.elem != nil { </span>
</pre>
<h2>runtime.mstart0</h2><p class="filename">/home/mikhliuk/go/go1.25.4/src/runtime/proc.go</p>
<pre onclick="pprof_toggle_asm(event)">  Total:           0        2MB (flat, cum)  0.35%
<span class="line">   1864</span> <span class="nop">           .          .           // May run during STW (because it doesn't have a P yet), so write </span>
<span class="line">   1865</span> <span class="nop">           .          .           // barriers are not allowed. </span>
<span class="line">   1866</span> <span class="nop">           .          .           // </span>
<span class="line">   1867</span> <span class="nop">           .          .           //go:nosplit </span>
<span class="line">   1868</span> <span class="nop">           .          .           //go:nowritebarrierrec </span>
<span class="line">   1869</span> <span class="livesrc">           .          .           func mstart0() { </span><span class="asm">                   .          .   443900:     PUSHQ BP                                                                     <span class="unimportant">proc.go:1869</span>
                   .          .   443901:     MOVQ SP, BP                                                                  <span class="unimportant">proc.go:1869</span>
                   .          .   443904:     SUBQ $0x20, SP                                                               <span class="unimportant">proc.go:1869</span>
</span>
<span class="line">   1870</span> <span class="livesrc">           .          .           	gp := getg() </span><span class="asm">                   .          .   443908:             MOVQ R14, 0x18(SP)                                                   <span class="unimportant">proc.go:1870</span>
                   .          .   44390d:             MOVQ 0(R14), AX                                                      <span class="unimportant">proc.go:1870</span>
</span>
<span class="line">   1871</span> <span class="nop">           .          .            </span>
<span class="line">   1872</span> <span class="livesrc">           .          .           	osStack := gp.stack.lo == 0 </span><span class="asm">                   .          .   443910:             TESTQ AX, AX                                                         <span class="unimportant">proc.go:1872</span>
                                     ⋮
                   .          .   44394e:             TESTQ AX, AX                                                         <span class="unimportant">proc.go:1872</span>
                                     ⋮
                   .          .   443958:             SETE AL                                                              <span class="unimportant">proc.go:1872</span>
                   .          .   44395b:             MOVB AL, 0xf(SP)                                                     <span class="unimportant">proc.go:1872</span>
</span>
<span class="line">   1873</span> <span class="livesrc">           .          .           	if osStack { </span><span class="asm">                   .          .   443913:             JNE 0x443953                                                         <span class="unimportant">proc.go:1873</span>
</span>
<span class="line">   1874</span> <span class="nop">           .          .           		// Initialize stack bounds from system stack. </span>
<span class="line">   1875</span> <span class="nop">           .          .           		// Cgo may have left stack size in stack.hi. </span>
<span class="line">   1876</span> <span class="nop">           .          .           		// minit may update the stack bounds. </span>
<span class="line">   1877</span> <span class="nop">           .          .           		// </span>
<span class="line">   1878</span> <span class="nop">           .          .           		// Note: these bounds may not be very accurate. </span>
<span class="line">   1879</span> <span class="nop">           .          .           		// We set hi to &amp;size, but there are things above </span>
<span class="line">   1880</span> <span class="nop">           .          .           		// it. The 1024 is supposed to compensate this, </span>
<span class="line">   1881</span> <span class="nop">           .          .           		// but is somewhat arbitrary. </span>
<span class="line">   1882</span> <span class="livesrc">           .          .           		size := gp.stack.hi </span><span class="asm">                   .          .   443915:                     MOVQ 0x8(R14), CX                                            <span class="unimportant">proc.go:1882</span>
                   .          .   443919:                     MOVQ CX, 0x10(SP)                                            <span class="unimportant">proc.go:1882</span>
                   .          .   44391e:                     NOPW                                                         <span class="unimportant">proc.go:1882</span>
</span>
<span class="line">   1883</span> <span class="livesrc">           .          .           		if size == 0 { </span><span class="asm">                   .          .   443920:                     TESTQ CX, CX                                                 <span class="unimportant">proc.go:1883</span>
                   .          .   443923:                     JNE 0x44392e                                                 <span class="unimportant">proc.go:1883</span>
</span>
<span class="line">   1884</span> <span class="livesrc">           .          .           			size = 16384 * sys.StackGuardMultiplier </span><span class="asm">                   .          .   443925:                             MOVQ $0x4000, 0x10(SP)                               <span class="unimportant">proc.go:1884</span>
</span>
<span class="line">   1885</span> <span class="nop">           .          .           		} </span>
<span class="line">   1886</span> <span class="livesrc">           .          .           		gp.stack.hi = uintptr(noescape(unsafe.Pointer(&amp;size))) </span><span class="asm">                   .          .   44392e:                     LEAQ 0x10(SP), CX                                            <span class="unimportant">proc.go:1886</span>
                   .          .   443933:                     MOVQ 0x18(SP), DX                                            <span class="unimportant">proc.go:1886</span>
                   .          .   443938:                     MOVQ CX, 0x8(DX)                                             <span class="unimportant">proc.go:1886</span>
</span>
<span class="line">   1887</span> <span class="livesrc">           .          .           		gp.stack.lo = gp.stack.hi - size + 1024 </span><span class="asm">                   .          .   44393c:                     MOVQ 0x10(SP), BX                                            <span class="unimportant">proc.go:1887</span>
                   .          .   443941:                     SUBQ BX, CX                                                  <span class="unimportant">proc.go:1887</span>
                   .          .   443944:                     ADDQ $0x400, CX                                              <span class="unimportant">proc.go:1887</span>
                   .          .   44394b:                     MOVQ CX, 0(DX)                                               <span class="unimportant">proc.go:1887</span>
                                     ⋮
                   .          .   443951:                     JMP 0x443958                                                 <span class="unimportant">proc.go:1887</span>
</span>
<span class="line">   1888</span> <span class="nop">           .          .           	} </span>
<span class="line">   1889</span> <span class="nop">           .          .           	// Initialize stack guard so that we can start calling regular </span>
<span class="line">   1890</span> <span class="nop">           .          .           	// Go code. </span>
<span class="line">   1891</span> <span class="livesrc">           .          .           	gp.stackguard0 = gp.stack.lo + stackGuard </span><span class="asm">                   .          .   443953:             MOVQ 0x18(SP), DX                                                    <span class="unimportant">proc.go:1891</span>
                                     ⋮
                   .          .   44395f:             MOVQ 0(DX), AX                                                       <span class="unimportant">proc.go:1891</span>
                   .          .   443962:             ADDQ $0x3a0, AX                                                      <span class="unimportant">proc.go:1891</span>
                   .          .   443968:             MOVQ AX, 0x10(DX)                                                    <span class="unimportant">proc.go:1891</span>
</span>
<span class="line">   1892</span> <span class="nop">           .          .           	// This is the g0, so we can also call go:systemstack </span>
<span class="line">   1893</span> <span class="nop">           .          .           	// functions, which check stackguard1. </span>
<span class="line">   1894</span> <span class="livesrc">           .          .           	gp.stackguard1 = gp.stackguard0 </span><span class="asm">                   .          .   44396c:             MOVQ AX, 0x18(DX)                                                    <span class="unimportant">proc.go:1894</span>
</span>
<span class="line">   1895</span> <span class="livesrc">           .        2MB           	mstart1() </span><span class="asm">                   .        2MB   443970:             CALL runtime.mstart1(SB)                                             <span class="unimportant">proc.go:1895</span>
</span>
<span class="line">   1896</span> <span class="nop">           .          .            </span>
<span class="line">   1897</span> <span class="nop">           .          .           	// Exit this thread. </span>
<span class="line">   1898</span> <span class="nop">           .          .           	if mStackIsSystemAllocated() { </span>
<span class="line">   1899</span> <span class="nop">           .          .           		// Windows, Solaris, illumos, Darwin, AIX and Plan 9 always system-allocate </span>
<span class="line">   1900</span> <span class="nop">           .          .           		// the stack, but put it in gp.stack before mstart, </span>
<span class="line">   1901</span> <span class="nop">           .          .           		// so the logic above hasn't set osStack yet. </span>
<span class="line">   1902</span> <span class="nop">           .          .           		osStack = true </span>
<span class="line">   1903</span> <span class="nop">           .          .           	} </span>
<span class="line">   1904</span> <span class="livesrc">           .          .           	mexit(osStack) </span><span class="asm">                   .          .   443975:             MOVZX 0xf(SP), AX                                                    <span class="unimportant">proc.go:1904</span>
                   .          .   44397a:             CALL runtime.mexit(SB)                                               <span class="unimportant">proc.go:1904</span>
</span>
<span class="line">   1905</span> <span class="livesrc">           .          .           } </span><span class="asm">                   .          .   44397f:     ADDQ $0x20, SP                                                               <span class="unimportant">proc.go:1905</span>
                   .          .   443983:     POPQ BP                                                                      <span class="unimportant">proc.go:1905</span>
                   .          .   443984:     RET                                                                          <span class="unimportant">proc.go:1905</span>
</span>
<span class="line">   1906</span> <span class="nop">           .          .            </span>
<span class="line">   1907</span> <span class="nop">           .          .           // The go:noinline is to guarantee the sys.GetCallerPC/sys.GetCallerSP below are safe, </span>
</pre>
<h2>runtime.mstart1</h2><p class="filename">/home/mikhliuk/go/go1.25.4/src/runtime/proc.go</p>
<pre onclick="pprof_toggle_asm(event)">  Total:           0        2MB (flat, cum)  0.35%
<span class="line">   1909</span> <span class="nop">           .          .           // </span>
<span class="line">   1910</span> <span class="nop">           .          .           //go:noinline </span>
<span class="line">   1911</span> <span class="livesrc">           .          .           func mstart1() { </span><span class="asm">                   .          .   4439a0:     CMPQ SP, 0x10(R14)                                                           <span class="unimportant">proc.go:1911</span>
                   .          .   4439a4:     JBE 0x443a86                                                                 <span class="unimportant">proc.go:1911</span>
                   .          .   4439aa:     PUSHQ BP                                                                     <span class="unimportant">proc.go:1911</span>
                   .          .   4439ab:     MOVQ SP, BP                                                                  <span class="unimportant">proc.go:1911</span>
                   .          .   4439ae:     SUBQ $0x18, SP                                                               <span class="unimportant">proc.go:1911</span>
                                     ⋮
                   .          .   443a86:     CALL runtime.morestack_noctxt.abi0(SB)                                       <span class="unimportant">proc.go:1911</span>
                   .          .   443a8b:     JMP runtime.mstart1(SB)                                                      <span class="unimportant">proc.go:1911</span>
</span>
<span class="line">   1912</span> <span class="livesrc">           .          .           	gp := getg() </span><span class="asm">                   .          .   4439b2:             MOVQ 0x30(R14), CX                                                   <span class="unimportant">proc.go:1912</span>
                                     ⋮
                   .          .   4439c9:             MOVQ DX, 0x10(SP)                                                    <span class="unimportant">proc.go:1912</span>
</span>
<span class="line">   1913</span> <span class="nop">           .          .            </span>
<span class="line">   1914</span> <span class="livesrc">           .          .           	if gp != gp.m.g0 { </span><span class="asm">                   .          .   4439b6:             MOVQ R14, DX                                                         <span class="unimportant">proc.go:1914</span>
                   .          .   4439b9:             NOPL 0(AX)                                                           <span class="unimportant">proc.go:1914</span>
                   .          .   4439c0:             CMPQ 0(CX), DX                                                       <span class="unimportant">proc.go:1914</span>
                   .          .   4439c3:             JNE 0x443a73                                                         <span class="unimportant">proc.go:1914</span>
</span>
<span class="line">   1915</span> <span class="livesrc">           .          .           		throw("bad runtime·mstart") </span><span class="asm">                   .          .   443a73:                     LEAQ 0xb51b9(IP), AX                                         <span class="unimportant">proc.go:1915</span>
                   .          .   443a7a:                     MOVL $0x13, BX                                               <span class="unimportant">proc.go:1915</span>
                   .          .   443a7f:                     NOPL                                                         <span class="unimportant">proc.go:1915</span>
                   .          .   443a80:                     CALL runtime.throw(SB)                                       <span class="unimportant">proc.go:1915</span>
                   .          .   443a85:                     NOPL                                                         <span class="unimportant">proc.go:1915</span>
</span>
<span class="line">   1916</span> <span class="nop">           .          .           	} </span>
<span class="line">   1917</span> <span class="nop">           .          .            </span>
<span class="line">   1918</span> <span class="nop">           .          .           	// Set up m.g0.sched as a label returning to just </span>
<span class="line">   1919</span> <span class="nop">           .          .           	// after the mstart1 call in mstart0 above, for use by goexit0 and mcall. </span>
<span class="line">   1920</span> <span class="nop">           .          .           	// We're never coming back to mstart1 after we call schedule, </span>
<span class="line">   1921</span> <span class="nop">           .          .           	// so other calls can reuse the current frame. </span>
<span class="line">   1922</span> <span class="nop">           .          .           	// And goexit0 does a gogo that needs to return from mstart1 </span>
<span class="line">   1923</span> <span class="nop">           .          .           	// and let mstart0 exit the thread. </span>
<span class="line">   1924</span> <span class="livesrc">           .          .           	gp.sched.g = guintptr(unsafe.Pointer(gp)) </span><span class="asm">                   .          .   4439ce:             MOVQ DX, 0x48(R14)                                                   <span class="unimportant">proc.go:1924</span>
</span>
<span class="line">   1925</span> <span class="livesrc">           .          .           	gp.sched.pc = sys.GetCallerPC() </span><span class="asm">                   .          .   4439d2:             MOVQ 0x20(SP), AX                                                    <span class="unimportant">proc.go:1925</span>
                   .          .   4439d7:             MOVQ AX, 0x40(R14)                                                   <span class="unimportant">proc.go:1925</span>
</span>
<span class="line">   1926</span> <span class="livesrc">           .          .           	gp.sched.sp = sys.GetCallerSP() </span><span class="asm">                   .          .   4439db:             LEAQ 0x28(SP), AX                                                    <span class="unimportant">proc.go:1926</span>
                   .          .   4439e0:             MOVQ AX, 0x38(R14)                                                   <span class="unimportant">proc.go:1926</span>
</span>
<span class="line">   1927</span> <span class="nop">           .          .            </span>
<span class="line">   1928</span> <span class="livesrc">           .          .           	asminit() </span><span class="asm">                   .          .   4439e4:             CALL runtime.asminit.abi0(SB)                                        <span class="unimportant">proc.go:1928</span>
                   .          .   4439e9:             XORPS X15, X15                                                       <span class="unimportant">proc.go:1928</span>
                   .          .   4439ed:             MOVQ FS:0xfffffff8, R14                                              <span class="unimportant">proc.go:1928</span>
</span>
<span class="line">   1929</span> <span class="livesrc">           .          .           	minit() </span><span class="asm">                   .          .   4439f6:             CALL runtime.minit(SB)                                               <span class="unimportant">proc.go:1929</span>
</span>
<span class="line">   1930</span> <span class="nop">           .          .            </span>
<span class="line">   1931</span> <span class="nop">           .          .           	// Install signal handlers; after minit so that minit can </span>
<span class="line">   1932</span> <span class="nop">           .          .           	// prepare the thread to be able to handle the signals. </span>
<span class="line">   1933</span> <span class="livesrc">           .          .           	if gp.m == &amp;m0 { </span><span class="asm">                   .          .   4439fb:             LEAQ runtime.m0(SB), AX                                              <span class="unimportant">proc.go:1933</span>
                   .          .   443a02:             MOVQ 0x10(SP), CX                                                    <span class="unimportant">proc.go:1933</span>
                   .          .   443a07:             CMPQ 0x30(CX), AX                                                    <span class="unimportant">proc.go:1933</span>
                   .          .   443a0b:             JNE 0x443a1e                                                         <span class="unimportant">proc.go:1933</span>
</span>
<span class="line">   1934</span> <span class="livesrc">           .          .           		mstartm0() </span><span class="asm">                   .          .   443a0d:                     CALL runtime.mstartm0(SB)                                    <span class="unimportant">proc.go:1934</span>
                   .          .   443a12:                     LEAQ runtime.m0(SB), AX                                      <span class="unimportant">proc.go:1934</span>
</span>
<span class="line">   1935</span> <span class="nop">           .          .           	} </span>
<span class="line">   1936</span> <span class="nop">           .          .            </span>
<span class="line">   1937</span> <span class="nop">           .          .           	if debug.dataindependenttiming == 1 { </span>
<span class="line">   1938</span> <span class="nop">           .          .           		sys.EnableDIT() </span>
<span class="line">   1939</span> <span class="nop">           .          .           	} </span>
<span class="line">   1940</span> <span class="nop">           .          .            </span>
<span class="line">   1941</span> <span class="livesrc">           .          .           	if fn := gp.m.mstartfn; fn != nil { </span><span class="asm">                   .          .   443a19:             MOVQ 0x10(SP), CX                                                    <span class="unimportant">proc.go:1941</span>
                   .          .   443a1e:             MOVQ 0x30(CX), BX                                                    <span class="unimportant">proc.go:1941</span>
                   .          .   443a22:             MOVQ 0xb0(BX), DX                                                    <span class="unimportant">proc.go:1941</span>
                   .          .   443a29:             TESTQ DX, DX                                                         <span class="unimportant">proc.go:1941</span>
                   .          .   443a2c:             JE 0x443a3f                                                          <span class="unimportant">proc.go:1941</span>
</span>
<span class="line">   1942</span> <span class="livesrc">           .      513kB           		fn() </span><span class="asm">                   .          .   443a2e:                     MOVQ 0(DX), AX                                               <span class="unimportant">proc.go:1942</span>
                   .      513kB   443a31:                     CALL AX                                                      <span class="unimportant">proc.go:1942</span>
                   .          .   443a33:                     LEAQ runtime.m0(SB), AX                                      <span class="unimportant">proc.go:1942</span>
</span>
<span class="line">   1943</span> <span class="nop">           .          .           	} </span>
<span class="line">   1944</span> <span class="nop">           .          .            </span>
<span class="line">   1945</span> <span class="livesrc">           .          .           	if gp.m != &amp;m0 { </span><span class="asm">                   .          .   443a3a:             MOVQ 0x10(SP), CX                                                    <span class="unimportant">proc.go:1945</span>
                   .          .   443a3f:             MOVQ 0x30(CX), DX                                                    <span class="unimportant">proc.go:1945</span>
                   .          .   443a43:             CMPQ DX, AX                                                          <span class="unimportant">proc.go:1945</span>
                   .          .   443a46:             JE 0x443a68                                                          <span class="unimportant">proc.go:1945</span>
</span>
<span class="line">   1946</span> <span class="livesrc">           .          .           		acquirep(gp.m.nextp.ptr()) </span><span class="asm">                   .          .   443a48:                     MOVQ 0xd0(DX), AX                                            <span class="unimportant">proc.go:1946</span>
                   .          .   443a4f:                     CALL runtime.acquirep(SB)                                    <span class="unimportant">proc.go:1946</span>
</span>
<span class="line">   1947</span> <span class="livesrc">           .          .           		gp.m.nextp = 0 </span><span class="asm">                   .          .   443a54:                     MOVQ 0x10(SP), CX                                            <span class="unimportant">proc.go:1947</span>
                   .          .   443a59:                     MOVQ 0x30(CX), CX                                            <span class="unimportant">proc.go:1947</span>
                   .          .   443a5d:                     MOVQ $0x0, 0xd0(CX)                                          <span class="unimportant">proc.go:1947</span>
</span>
<span class="line">   1948</span> <span class="nop">           .          .           	} </span>
<span class="line">   1949</span> <span class="livesrc">           .     1.50MB           	schedule() </span><span class="asm">                   .     1.50MB   443a68:             CALL runtime.schedule(SB)                                            <span class="unimportant">proc.go:1949</span>
</span>
<span class="line">   1950</span> <span class="livesrc">           .          .           } </span><span class="asm">                   .          .   443a6d:     ADDQ $0x18, SP                                                               <span class="unimportant">proc.go:1950</span>
                   .          .   443a71:     POPQ BP                                                                      <span class="unimportant">proc.go:1950</span>
                   .          .   443a72:     RET                                                                          <span class="unimportant">proc.go:1950</span>
</span>
<span class="line">   1951</span> <span class="nop">           .          .            </span>
<span class="line">   1952</span> <span class="nop">           .          .           // mstartm0 implements part of mstart1 that only runs on the m0. </span>
<span class="line">   1953</span> <span class="nop">           .          .           // </span>
<span class="line">   1954</span> <span class="nop">           .          .           // Write barriers are allowed here because we know the GC can't be </span>
<span class="line">   1955</span> <span class="nop">           .          .           // running yet, so they'll be no-ops. </span>
</pre>
<h2>runtime.allocm</h2><p class="filename">/home/mikhliuk/go/go1.25.4/src/runtime/proc.go</p>
<pre onclick="pprof_toggle_asm(event)">  Total:         2MB        2MB (flat, cum)  0.35%
<span class="line">   2279</span> <span class="nop">           .          .           // </span>
<span class="line">   2280</span> <span class="nop">           .          .           // This function is allowed to have write barriers even if the caller </span>
<span class="line">   2281</span> <span class="nop">           .          .           // isn't because it borrows pp. </span>
<span class="line">   2282</span> <span class="nop">           .          .           // </span>
<span class="line">   2283</span> <span class="nop">           .          .           //go:yeswritebarrierrec </span>
<span class="line">   2284</span> <span class="livesrc">           .          .           func allocm(pp *p, fn func(), id int64) *m { </span><span class="asm">                   .          .   4442a0:     CMPQ SP, 0x10(R14)                                                           <span class="unimportant">proc.go:2284</span>
                   .          .   4442a4:     JBE 0x44457b                                                                 <span class="unimportant">proc.go:2284</span>
                   .          .   4442aa:     PUSHQ BP                                                                     <span class="unimportant">proc.go:2284</span>
                   .          .   4442ab:     MOVQ SP, BP                                                                  <span class="unimportant">proc.go:2284</span>
                   .          .   4442ae:     SUBQ $0x48, SP                                                               <span class="unimportant">proc.go:2284</span>
</span>
<span class="line">   2285</span> <span class="livesrc">           .          .           	allocmLock.rlock() </span><span class="asm">                   .          .   4442c1:             LEAQ runtime.allocmLock(SB), AX                                      <span class="unimportant">proc.go:2285</span>
                   .          .   4442c8:             CALL runtime.(*rwmutex).rlock(SB)                                    <span class="unimportant">proc.go:2285</span>
</span>
<span class="line">   2286</span> <span class="nop">           .          .            </span>
<span class="line">   2287</span> <span class="nop">           .          .           	// The caller owns pp, but we may borrow (i.e., acquirep) it. We must </span>
<span class="line">   2288</span> <span class="nop">           .          .           	// disable preemption to ensure it is not stolen, which would make the </span>
<span class="line">   2289</span> <span class="nop">           .          .           	// caller lose ownership. </span>
<span class="line">   2290</span> <span class="livesrc">           .          .           	acquirem() </span><span class="asm">                   .          .   4442d1:             NOPL                                                                 <span class="unimportant">proc.go:2290</span>
</span>
<span class="line">   2291</span> <span class="nop">           .          .            </span>
<span class="line">   2292</span> <span class="livesrc">           .          .           	gp := getg() </span><span class="asm">                   .          .   4442dd:             MOVQ R14, 0x20(SP)                                                   <span class="unimportant">proc.go:2292</span>
</span>
<span class="line">   2293</span> <span class="livesrc">           .          .           	if gp.m.p == 0 { </span><span class="asm">                   .          .   4442b2:             MOVQ AX, 0x58(SP)                                                    <span class="unimportant">proc.go:2293</span>
                   .          .   4442b7:             MOVQ BX, 0x60(SP)                                                    <span class="unimportant">proc.go:2293</span>
                   .          .   4442bc:             MOVQ CX, 0x68(SP)                                                    <span class="unimportant">proc.go:2293</span>
                                     ⋮
                   .          .   4442e2:             MOVQ 0x30(R14), CX                                                   <span class="unimportant">proc.go:2293</span>
                   .          .   4442e6:             CMPQ 0xc8(CX), $0x0                                                  <span class="unimportant">proc.go:2293</span>
                   .          .   4442ee:             JNE 0x4442fa                                                         <span class="unimportant">proc.go:2293</span>
</span>
<span class="line">   2294</span> <span class="livesrc">           .          .           		acquirep(pp) // temporarily borrow p for mallocs in this function </span><span class="asm">                   .          .   4442f0:                     MOVQ 0x58(SP), AX                                            <span class="unimportant">proc.go:2294</span>
                   .          .   4442f5:                     CALL runtime.acquirep(SB)                                    <span class="unimportant">proc.go:2294</span>
</span>
<span class="line">   2295</span> <span class="nop">           .          .           	} </span>
<span class="line">   2296</span> <span class="nop">           .          .            </span>
<span class="line">   2297</span> <span class="nop">           .          .           	// Release the free M list. We need to do this somewhere and </span>
<span class="line">   2298</span> <span class="nop">           .          .           	// this may free up a stack we can use. </span>
<span class="line">   2299</span> <span class="livesrc">           .          .           	if sched.freem != nil { </span><span class="asm">                   .          .   4442fa:             CMPQ runtime.sched+240(SB), $0x0                                     <span class="unimportant">proc.go:2299</span>
                   .          .   444302:             JE 0x444325                                                          <span class="unimportant">proc.go:2299</span>
</span>
<span class="line">   2300</span> <span class="livesrc">           .          .           		lock(&amp;sched.lock) </span><span class="asm">                   .          .   444304:                     NOPL                                                         <span class="unimportant">proc.go:2300</span>
</span>
<span class="line">   2301</span> <span class="nop">           .          .           		var newList *m </span>
<span class="line">   2302</span> <span class="livesrc">           .          .           		for freem := sched.freem; freem != nil; { </span><span class="asm">                   .          .   444312:                     MOVQ runtime.sched+240(SB), CX                               <span class="unimportant">proc.go:2302</span>
                   .          .   444319:                     XORL AX, AX                                                  <span class="unimportant">proc.go:2302</span>
                   .          .   44431b:                     NOPL 0(AX)(AX*1)                                             <span class="unimportant">proc.go:2302</span>
                   .          .   444320:                     JMP 0x444466                                                 <span class="unimportant">proc.go:2302</span>
                                     ⋮
                   .          .   444461:                     MOVQ 0x28(SP), CX                                            <span class="unimportant">proc.go:2302</span>
                   .          .   444466:                     MOVQ CX, 0x28(SP)                                            <span class="unimportant">proc.go:2302</span>
                   .          .   44446b:                     TESTQ CX, CX                                                 <span class="unimportant">proc.go:2302</span>
                   .          .   44446e:                     JE 0x444545                                                  <span class="unimportant">proc.go:2302</span>
</span>
<span class="line">   2303</span> <span class="nop">           .          .           			// Wait for freeWait to indicate that freem's stack is unused. </span>
<span class="line">   2304</span> <span class="livesrc">           .          .           			wait := freem.freeWait.Load() </span><span class="asm">                   .          .   444474:                             NOPL                                                 <span class="unimportant">proc.go:2304</span>
</span>
<span class="line">   2305</span> <span class="livesrc">           .          .           			if wait == freeMWait { </span><span class="asm">                   .          .   444480:                             CMPL CX, $0x2                                        <span class="unimportant">proc.go:2305</span>
                   .          .   444483:                             JNE 0x4444c2                                         <span class="unimportant">proc.go:2305</span>
</span>
<span class="line">   2306</span> <span class="livesrc">           .          .           				next := freem.freelink </span><span class="asm">                   .          .   44448a:                                     MOVQ 0x2f8(CX), DX                           <span class="unimportant">proc.go:2306</span>
</span>
<span class="line">   2307</span> <span class="livesrc">           .          .           				freem.freelink = newList </span><span class="asm">                   .          .   444485:                                     MOVQ 0x28(SP), CX                            <span class="unimportant">proc.go:2307</span>
                                     ⋮
                   .          .   444491:                                     CMPL runtime.writeBarrier(SB), $0x0          <span class="unimportant">proc.go:2307</span>
                   .          .   444498:                                     JE 0x4444ad                                  <span class="unimportant">proc.go:2307</span>
                   .          .   44449a:                                     MOVQ 0x2f8(CX), BX                           <span class="unimportant">proc.go:2307</span>
                   .          .   4444a1:                                     CALL runtime.gcWriteBarrier2(SB)             <span class="unimportant">proc.go:2307</span>
                   .          .   4444a6:                                     MOVQ AX, 0(R11)                              <span class="unimportant">proc.go:2307</span>
                   .          .   4444a9:                                     MOVQ BX, 0x8(R11)                            <span class="unimportant">proc.go:2307</span>
                   .          .   4444ad:                                     MOVQ AX, 0x2f8(CX)                           <span class="unimportant">proc.go:2307</span>
                                     ⋮
                   .          .   4444c6:                                     MOVQ AX, 0x18(SP)                            <span class="unimportant">proc.go:2307</span>
                                     ⋮
                   .          .   4444e9:                                     MOVQ 0x18(SP), AX                            <span class="unimportant">proc.go:2307</span>
</span>
<span class="line">   2308</span> <span class="livesrc">           .          .           				newList = freem </span><span class="asm">                   .          .   4444b4:                                     MOVQ 0x28(SP), AX                            <span class="unimportant">proc.go:2308</span>
</span>
<span class="line">   2309</span> <span class="livesrc">           .          .           				freem = next </span><span class="asm">                   .          .   4444b9:                                     MOVQ DX, 0x28(SP)                            <span class="unimportant">proc.go:2309</span>
                   .          .   4444be:                                     NOPW                                         <span class="unimportant">proc.go:2309</span>
</span>
<span class="line">   2310</span> <span class="livesrc">           .          .           				continue </span><span class="asm">                   .          .   4444c0:                                     JMP 0x444461                                 <span class="unimportant">proc.go:2310</span>
</span>
<span class="line">   2311</span> <span class="nop">           .          .           			} </span>
<span class="line">   2312</span> <span class="nop">           .          .           			// Drop any remaining trace resources. </span>
<span class="line">   2313</span> <span class="nop">           .          .           			// Ms can continue to emit events all the way until wait != freeMWait, </span>
<span class="line">   2314</span> <span class="nop">           .          .           			// so it's only safe to call traceThreadDestroy at this point. </span>
<span class="line">   2315</span> <span class="livesrc">           .          .           			if traceEnabled() || traceShuttingDown() { </span><span class="asm">                   .          .   4444d2:                             JNE 0x4444df                                         <span class="unimportant">proc.go:2315</span>
                                     ⋮
                   .          .   4444dd:                             JE 0x4444f2                                          <span class="unimportant">proc.go:2315</span>
</span>
<span class="line">   2316</span> <span class="livesrc">           .          .           				traceThreadDestroy(freem) </span><span class="asm">                   .          .   4444df:                                     MOVQ 0x28(SP), AX                            <span class="unimportant">proc.go:2316</span>
                   .          .   4444e4:                                     CALL runtime.traceThreadDestroy(SB)          <span class="unimportant">proc.go:2316</span>
</span>
<span class="line">   2317</span> <span class="nop">           .          .           			} </span>
<span class="line">   2318</span> <span class="nop">           .          .           			// Free the stack if needed. For freeMRef, there is </span>
<span class="line">   2319</span> <span class="nop">           .          .           			// nothing to do except drop freem from the sched.freem </span>
<span class="line">   2320</span> <span class="nop">           .          .           			// list. </span>
<span class="line">   2321</span> <span class="livesrc">           .          .           			if wait == freeMStack { </span><span class="asm">                   .          .   4444ee:                             MOVL 0x14(SP), CX                                    <span class="unimportant">proc.go:2321</span>
                   .          .   4444f2:                             TESTL CX, CX                                         <span class="unimportant">proc.go:2321</span>
                   .          .   4444f4:                             JNE 0x44452c                                         <span class="unimportant">proc.go:2321</span>
</span>
<span class="line">   2322</span> <span class="nop">           .          .           				// stackfree must be on the system stack, but allocm is </span>
<span class="line">   2323</span> <span class="nop">           .          .           				// reachable off the system stack transitively from </span>
<span class="line">   2324</span> <span class="nop">           .          .           				// startm. </span>
<span class="line">   2325</span> <span class="livesrc">           .          .           				systemstack(func() { </span><span class="asm">                   .          .   4444f6:                                     LEAQ runtime.allocm.func1(SB), AX            <span class="unimportant">proc.go:2325</span>
                   .          .   4444fd:                                     MOVQ AX, 0x38(SP)                            <span class="unimportant">proc.go:2325</span>
                   .          .   444502:                                     LEAQ 0x28(SP), AX                            <span class="unimportant">proc.go:2325</span>
                   .          .   444507:                                     MOVQ AX, 0x40(SP)                            <span class="unimportant">proc.go:2325</span>
                   .          .   44450c:                                     LEAQ 0x38(SP), AX                            <span class="unimportant">proc.go:2325</span>
                   .          .   444511:                                     MOVQ AX, 0(SP)                               <span class="unimportant">proc.go:2325</span>
                   .          .   444515:                                     CALL runtime.systemstack.abi0(SB)            <span class="unimportant">proc.go:2325</span>
                   .          .   44451a:                                     XORPS X15, X15                               <span class="unimportant">proc.go:2325</span>
                   .          .   44451e:                                     ?                                            <span class="unimportant">proc.go:2325</span>
                   .          .   44451f:                                     ?                                            <span class="unimportant">proc.go:2325</span>
                   .          .   444520:                                     ?                                            <span class="unimportant">proc.go:2325</span>
                   .          .   444521:                                     XORL $0x25, AL                               <span class="unimportant">proc.go:2325</span>
                   .          .   444523:                                     CLC                                          <span class="unimportant">proc.go:2325</span>
</span>
<span class="line">   2326</span> <span class="nop">           .          .           					stackfree(freem.g0.stack) </span>
<span class="line">   2327</span> <span class="nop">           .          .           					if valgrindenabled { </span>
<span class="line">   2328</span> <span class="nop">           .          .           						valgrindDeregisterStack(freem.g0.valgrindStackID) </span>
<span class="line">   2329</span> <span class="nop">           .          .           						freem.g0.valgrindStackID = 0 </span>
<span class="line">   2330</span> <span class="nop">           .          .           					} </span>
<span class="line">   2331</span> <span class="nop">           .          .           				}) </span>
<span class="line">   2332</span> <span class="nop">           .          .           			} </span>
<span class="line">   2333</span> <span class="nop">           .          .           			freem = freem.freelink </span>
<span class="line">   2334</span> <span class="nop">           .          .           		} </span>
<span class="line">   2335</span> <span class="nop">           .          .           		sched.freem = newList </span>
<span class="line">   2336</span> <span class="nop">           .          .           		unlock(&amp;sched.lock) </span>
<span class="line">   2337</span> <span class="nop">           .          .           	} </span>
<span class="line">   2338</span> <span class="nop">           .          .            </span>
<span class="line">   2339</span> <span class="livesrc">         2MB        2MB           	mp := &amp;new(mPadded).m </span><span class="asm">                   .          .   444325:             LEAQ 0x9ef14(IP), AX                                                 <span class="unimportant">proc.go:2339</span>
                 2MB        2MB   44432c:             CALL runtime.newobject(SB)                                           <span class="unimportant">proc.go:2339</span>
                                     ⋮
                   .          .   44434f:             MOVQ AX, 0x30(SP)                                                    <span class="unimportant">proc.go:2339</span>
</span>
<span class="line">   2340</span> <span class="livesrc">           .          .           	mp.mstartfn = fn </span><span class="asm">                   .          .   444331:             CMPL runtime.writeBarrier(SB), $0x0                                  <span class="unimportant">proc.go:2340</span>
                   .          .   444338:             JNE 0x444342                                                         <span class="unimportant">proc.go:2340</span>
                   .          .   44433a:             MOVQ 0x60(SP), CX                                                    <span class="unimportant">proc.go:2340</span>
                   .          .   44433f:             NOPL                                                                 <span class="unimportant">proc.go:2340</span>
                   .          .   444340:             JMP 0x44434f                                                         <span class="unimportant">proc.go:2340</span>
                   .          .   444342:             CALL runtime.gcWriteBarrier1(SB)                                     <span class="unimportant">proc.go:2340</span>
                   .          .   444347:             MOVQ 0x60(SP), CX                                                    <span class="unimportant">proc.go:2340</span>
                   .          .   44434c:             MOVQ CX, 0(R11)                                                      <span class="unimportant">proc.go:2340</span>
                                     ⋮
                   .          .   444354:             MOVQ CX, 0xb0(AX)                                                    <span class="unimportant">proc.go:2340</span>
</span>
<span class="line">   2341</span> <span class="livesrc">           .          .           	mcommoninit(mp, id) </span><span class="asm">                   .          .   44435b:             MOVQ 0x68(SP), BX                                                    <span class="unimportant">proc.go:2341</span>
                   .          .   444360:             CALL runtime.mcommoninit(SB)                                         <span class="unimportant">proc.go:2341</span>
</span>
<span class="line">   2342</span> <span class="nop">           .          .            </span>
<span class="line">   2343</span> <span class="nop">           .          .           	// In case of cgo or Solaris or illumos or Darwin, pthread_create will make us a stack. </span>
<span class="line">   2344</span> <span class="nop">           .          .           	// Windows and Plan 9 will layout sched stack on OS stack. </span>
<span class="line">   2345</span> <span class="livesrc">           .          .           	if iscgo || mStackIsSystemAllocated() { </span><span class="asm">                   .          .   444365:             CMPB runtime.iscgo(SB), $0x0                                         <span class="unimportant">proc.go:2345</span>
                   .          .   44436c:             JE 0x4443a2                                                          <span class="unimportant">proc.go:2345</span>
</span>
<span class="line">   2346</span> <span class="livesrc">           .          .           		mp.g0 = malg(-1) </span><span class="asm">                   .          .   44436e:                     MOVL $-0x1, AX                                               <span class="unimportant">proc.go:2346</span>
                   .          .   444373:                     CALL runtime.malg(SB)                                        <span class="unimportant">proc.go:2346</span>
                   .          .   444378:                     CMPL runtime.writeBarrier(SB), $0x0                          <span class="unimportant">proc.go:2346</span>
                   .          .   44437f:                     NOPL                                                         <span class="unimportant">proc.go:2346</span>
                   .          .   444380:                     JNE 0x444389                                                 <span class="unimportant">proc.go:2346</span>
                   .          .   444382:                     MOVQ 0x30(SP), CX                                            <span class="unimportant">proc.go:2346</span>
                   .          .   444387:                     JMP 0x44439d                                                 <span class="unimportant">proc.go:2346</span>
                   .          .   444389:                     MOVQ 0x30(SP), CX                                            <span class="unimportant">proc.go:2346</span>
                   .          .   44438e:                     MOVQ 0(CX), DX                                               <span class="unimportant">proc.go:2346</span>
                   .          .   444391:                     CALL runtime.gcWriteBarrier2(SB)                             <span class="unimportant">proc.go:2346</span>
                   .          .   444396:                     MOVQ AX, 0(R11)                                              <span class="unimportant">proc.go:2346</span>
                   .          .   444399:                     MOVQ DX, 0x8(R11)                                            <span class="unimportant">proc.go:2346</span>
                   .          .   44439d:                     MOVQ AX, 0(CX)                                               <span class="unimportant">proc.go:2346</span>
                   .          .   4443a0:                     JMP 0x4443d3                                                 <span class="unimportant">proc.go:2346</span>
</span>
<span class="line">   2347</span> <span class="nop">           .          .           	} else { </span>
<span class="line">   2348</span> <span class="livesrc">           .          .           		mp.g0 = malg(16384 * sys.StackGuardMultiplier) </span><span class="asm">                   .          .   4443a2:                     MOVL $0x4000, AX                                             <span class="unimportant">proc.go:2348</span>
                   .          .   4443a7:                     CALL runtime.malg(SB)                                        <span class="unimportant">proc.go:2348</span>
                   .          .   4443ac:                     CMPL runtime.writeBarrier(SB), $0x0                          <span class="unimportant">proc.go:2348</span>
                   .          .   4443b3:                     JNE 0x4443bc                                                 <span class="unimportant">proc.go:2348</span>
                   .          .   4443b5:                     MOVQ 0x30(SP), CX                                            <span class="unimportant">proc.go:2348</span>
                   .          .   4443ba:                     JMP 0x4443d0                                                 <span class="unimportant">proc.go:2348</span>
                   .          .   4443bc:                     MOVQ 0x30(SP), CX                                            <span class="unimportant">proc.go:2348</span>
                   .          .   4443c1:                     MOVQ 0(CX), DX                                               <span class="unimportant">proc.go:2348</span>
                   .          .   4443c4:                     CALL runtime.gcWriteBarrier2(SB)                             <span class="unimportant">proc.go:2348</span>
                   .          .   4443c9:                     MOVQ AX, 0(R11)                                              <span class="unimportant">proc.go:2348</span>
                   .          .   4443cc:                     MOVQ DX, 0x8(R11)                                            <span class="unimportant">proc.go:2348</span>
                   .          .   4443d0:                     MOVQ AX, 0(CX)                                               <span class="unimportant">proc.go:2348</span>
</span>
<span class="line">   2349</span> <span class="nop">           .          .           	} </span>
<span class="line">   2350</span> <span class="livesrc">           .          .           	mp.g0.m = mp </span><span class="asm">                   .          .   4443d3:             MOVQ 0(CX), DX                                                       <span class="unimportant">proc.go:2350</span>
                   .          .   4443d6:             TESTB AL, 0(DX)                                                      <span class="unimportant">proc.go:2350</span>
                   .          .   4443d8:             CMPL runtime.writeBarrier(SB), $0x0                                  <span class="unimportant">proc.go:2350</span>
                   .          .   4443df:             NOPL                                                                 <span class="unimportant">proc.go:2350</span>
                   .          .   4443e0:             JE 0x4443f2                                                          <span class="unimportant">proc.go:2350</span>
                   .          .   4443e2:             MOVQ 0x30(DX), BX                                                    <span class="unimportant">proc.go:2350</span>
                   .          .   4443e6:             CALL runtime.gcWriteBarrier2(SB)                                     <span class="unimportant">proc.go:2350</span>
                   .          .   4443eb:             MOVQ CX, 0(R11)                                                      <span class="unimportant">proc.go:2350</span>
                   .          .   4443ee:             MOVQ BX, 0x8(R11)                                                    <span class="unimportant">proc.go:2350</span>
                   .          .   4443f2:             MOVQ CX, 0x30(DX)                                                    <span class="unimportant">proc.go:2350</span>
</span>
<span class="line">   2351</span> <span class="nop">           .          .            </span>
<span class="line">   2352</span> <span class="livesrc">           .          .           	if pp == gp.m.p.ptr() { </span><span class="asm">                   .          .   4443f6:             MOVQ 0x20(SP), DX                                                    <span class="unimportant">proc.go:2352</span>
                   .          .   4443fb:             MOVQ 0x30(DX), BX                                                    <span class="unimportant">proc.go:2352</span>
                   .          .   4443ff:             MOVQ 0xc8(BX), BX                                                    <span class="unimportant">proc.go:2352</span>
                   .          .   444406:             MOVQ 0x58(SP), SI                                                    <span class="unimportant">proc.go:2352</span>
                   .          .   44440b:             CMPQ SI, BX                                                          <span class="unimportant">proc.go:2352</span>
                   .          .   44440e:             JNE 0x44441f                                                         <span class="unimportant">proc.go:2352</span>
</span>
<span class="line">   2353</span> <span class="livesrc">           .          .           		releasep() </span><span class="asm">                   .          .   444410:                     CALL runtime.releasep(SB)                                    <span class="unimportant">proc.go:2353</span>
</span>
<span class="line">   2354</span> <span class="nop">           .          .           	} </span>
<span class="line">   2355</span> <span class="nop">           .          .            </span>
<span class="line">   2356</span> <span class="livesrc">           .          .           	releasem(gp.m) </span><span class="asm">                   .          .   44441a:             MOVQ 0x20(SP), DX                                                    <span class="unimportant">proc.go:2356</span>
                   .          .   44441f:             MOVQ 0x30(DX), DX                                                    <span class="unimportant">proc.go:2356</span>
</span>
<span class="line">   2357</span> <span class="livesrc">           .          .           	allocmLock.runlock() </span><span class="asm">                   .          .   44444a:             LEAQ runtime.allocmLock(SB), AX                                      <span class="unimportant">proc.go:2357</span>
                   .          .   444451:             CALL runtime.(*rwmutex).runlock(SB)                                  <span class="unimportant">proc.go:2357</span>
</span>
<span class="line">   2358</span> <span class="livesrc">           .          .           	return mp </span><span class="asm">                   .          .   444415:             MOVQ 0x30(SP), CX                                                    <span class="unimportant">proc.go:2358</span>
                                     ⋮
                   .          .   444456:             MOVQ 0x30(SP), AX                                                    <span class="unimportant">proc.go:2358</span>
                   .          .   44445b:             ADDQ $0x48, SP                                                       <span class="unimportant">proc.go:2358</span>
                   .          .   44445f:             POPQ BP                                                              <span class="unimportant">proc.go:2358</span>
                   .          .   444460:             RET                                                                  <span class="unimportant">proc.go:2358</span>
</span>
<span class="line">   2359</span> <span class="nop">           .          .           } </span>
<span class="line">   2360</span> <span class="nop">           .          .            </span>
<span class="line">   2361</span> <span class="nop">           .          .           // needm is called when a cgo callback happens on a </span>
<span class="line">   2362</span> <span class="nop">           .          .           // thread without an m (a thread not created by Go). </span>
<span class="line">   2363</span> <span class="nop">           .          .           // In this case, needm is expected to find an m to use </span>
</pre>
<h2>runtime.newm</h2><p class="filename">/home/mikhliuk/go/go1.25.4/src/runtime/proc.go</p>
<pre onclick="pprof_toggle_asm(event)">  Total:           0        2MB (flat, cum)  0.35%
<span class="line">   2857</span> <span class="nop">           .          .           // May run with m.p==nil, so write barriers are not allowed. </span>
<span class="line">   2858</span> <span class="nop">           .          .           // </span>
<span class="line">   2859</span> <span class="nop">           .          .           // id is optional pre-allocated m ID. Omit by passing -1. </span>
<span class="line">   2860</span> <span class="nop">           .          .           // </span>
<span class="line">   2861</span> <span class="nop">           .          .           //go:nowritebarrierrec </span>
<span class="line">   2862</span> <span class="livesrc">           .          .           func newm(fn func(), pp *p, id int64) { </span><span class="asm">                   .          .   444d80:     CMPQ SP, 0x10(R14)                                                           <span class="unimportant">proc.go:2862</span>
                   .          .   444d84:     JBE 0x444ee7                                                                 <span class="unimportant">proc.go:2862</span>
                   .          .   444d8a:     PUSHQ BP                                                                     <span class="unimportant">proc.go:2862</span>
                   .          .   444d8b:     MOVQ SP, BP                                                                  <span class="unimportant">proc.go:2862</span>
                   .          .   444d8e:     SUBQ $0x20, SP                                                               <span class="unimportant">proc.go:2862</span>
                                     ⋮
                   .          .   444ee7:     MOVQ AX, 0x8(SP)                                                             <span class="unimportant">proc.go:2862</span>
                   .          .   444eec:     MOVQ BX, 0x10(SP)                                                            <span class="unimportant">proc.go:2862</span>
                   .          .   444ef1:     MOVQ CX, 0x18(SP)                                                            <span class="unimportant">proc.go:2862</span>
                   .          .   444ef6:     CALL runtime.morestack_noctxt.abi0(SB)                                       <span class="unimportant">proc.go:2862</span>
                   .          .   444efb:     MOVQ 0x8(SP), AX                                                             <span class="unimportant">proc.go:2862</span>
                   .          .   444f00:     MOVQ 0x10(SP), BX                                                            <span class="unimportant">proc.go:2862</span>
                   .          .   444f05:     MOVQ 0x18(SP), CX                                                            <span class="unimportant">proc.go:2862</span>
                   .          .   444f0a:     JMP runtime.newm(SB)                                                         <span class="unimportant">proc.go:2862</span>
</span>
<span class="line">   2863</span> <span class="nop">           .          .           	// allocm adds a new M to allm, but they do not start until created by </span>
<span class="line">   2864</span> <span class="nop">           .          .           	// the OS in newm1 or the template thread. </span>
<span class="line">   2865</span> <span class="nop">           .          .           	// </span>
<span class="line">   2866</span> <span class="nop">           .          .           	// doAllThreadsSyscall requires that every M in allm will eventually </span>
<span class="line">   2867</span> <span class="nop">           .          .           	// start and be signal-able, even with a STW. </span>
<span class="line">   2868</span> <span class="nop">           .          .           	// </span>
<span class="line">   2869</span> <span class="nop">           .          .           	// Disable preemption here until we start the thread to ensure that </span>
<span class="line">   2870</span> <span class="nop">           .          .           	// newm is not preempted between allocm and starting the new thread, </span>
<span class="line">   2871</span> <span class="nop">           .          .           	// ensuring that anything added to allm is guaranteed to eventually </span>
<span class="line">   2872</span> <span class="nop">           .          .           	// start. </span>
<span class="line">   2873</span> <span class="livesrc">           .          .           	acquirem() </span><span class="asm">                   .          .   444d9b:             NOPL                                                                 <span class="unimportant">proc.go:2873</span>
</span>
<span class="line">   2874</span> <span class="nop">           .          .            </span>
<span class="line">   2875</span> <span class="livesrc">           .        2MB           	mp := allocm(pp, fn, id) </span><span class="asm">                   .          .   444daa:             MOVQ BX, AX                                                          <span class="unimportant">proc.go:2875</span>
                   .          .   444dad:             MOVQ DX, BX                                                          <span class="unimportant">proc.go:2875</span>
                   .        2MB   444db0:             CALL runtime.allocm(SB)                                              <span class="unimportant">proc.go:2875</span>
                                     ⋮
                   .          .   444de9:             MOVQ AX, 0x18(SP)                                                    <span class="unimportant">proc.go:2875</span>
</span>
<span class="line">   2876</span> <span class="livesrc">           .          .           	mp.nextp.set(pp) </span><span class="asm">                   .          .   444dba:             NOPL                                                                 <span class="unimportant">proc.go:2876</span>
</span>
<span class="line">   2877</span> <span class="livesrc">           .          .           	mp.sigmask = initSigmask </span><span class="asm">                   .          .   444dc2:             MOVQ runtime.initSigmask(SB), DX                                     <span class="unimportant">proc.go:2877</span>
                   .          .   444dc9:             MOVQ DX, 0x78(AX)                                                    <span class="unimportant">proc.go:2877</span>
</span>
<span class="line">   2878</span> <span class="livesrc">           .          .           	if gp := getg(); gp != nil &amp;&amp; gp.m != nil &amp;&amp; (gp.m.lockedExt != 0 || gp.m.incgo) &amp;&amp; GOOS != "plan9" { </span><span class="asm">                   .          .   444d92:             MOVQ BX, 0x38(SP)                                                    <span class="unimportant">proc.go:2878</span>
                                     ⋮
                   .          .   444da7:             MOVQ AX, DX                                                          <span class="unimportant">proc.go:2878</span>
                                     ⋮
                   .          .   444dcd:             MOVQ R14, DX                                                         <span class="unimportant">proc.go:2878</span>
                   .          .   444dd0:             TESTQ DX, DX                                                         <span class="unimportant">proc.go:2878</span>
                   .          .   444dd3:             JE 0x444ea0                                                          <span class="unimportant">proc.go:2878</span>
                   .          .   444dd9:             MOVQ 0x30(DX), CX                                                    <span class="unimportant">proc.go:2878</span>
                   .          .   444ddd:             NOPL 0(AX)                                                           <span class="unimportant">proc.go:2878</span>
                   .          .   444de0:             TESTQ CX, CX                                                         <span class="unimportant">proc.go:2878</span>
                   .          .   444de3:             JE 0x444ea0                                                          <span class="unimportant">proc.go:2878</span>
                                     ⋮
                   .          .   444dee:             CMPL 0x270(CX), $0x0                                                 <span class="unimportant">proc.go:2878</span>
                   .          .   444df5:             JNE 0x444e06                                                         <span class="unimportant">proc.go:2878</span>
                   .          .   444df7:             CMPB 0x110(CX), $0x0                                                 <span class="unimportant">proc.go:2878</span>
                   .          .   444dfe:             NOPW                                                                 <span class="unimportant">proc.go:2878</span>
                   .          .   444e00:             JE 0x444ea0                                                          <span class="unimportant">proc.go:2878</span>
</span>
<span class="line">   2879</span> <span class="nop">           .          .           		// We're on a locked M or a thread that may have been </span>
<span class="line">   2880</span> <span class="nop">           .          .           		// started by C. The kernel state of this thread may </span>
<span class="line">   2881</span> <span class="nop">           .          .           		// be strange (the user may have locked it for that </span>
<span class="line">   2882</span> <span class="nop">           .          .           		// purpose). We don't want to clone that into another </span>
<span class="line">   2883</span> <span class="nop">           .          .           		// thread. Instead, ask a known-good thread to create </span>
<span class="line">   2884</span> <span class="nop">           .          .           		// the thread for us. </span>
<span class="line">   2885</span> <span class="nop">           .          .           		// </span>
<span class="line">   2886</span> <span class="nop">           .          .           		// This is disabled on Plan 9. See golang.org/issue/22227. </span>
<span class="line">   2887</span> <span class="nop">           .          .           		// </span>
<span class="line">   2888</span> <span class="nop">           .          .           		// TODO: This may be unnecessary on Windows, which </span>
<span class="line">   2889</span> <span class="nop">           .          .           		// doesn't model thread creation off fork. </span>
<span class="line">   2890</span> <span class="livesrc">           .          .           		lock(&amp;newmHandoff.lock) </span><span class="asm">                   .          .   444e06:                     NOPL                                                         <span class="unimportant">proc.go:2890</span>
</span>
<span class="line">   2891</span> <span class="livesrc">           .          .           		if newmHandoff.haveTemplateThread == 0 { </span><span class="asm">                   .          .   444e14:                     CMPL runtime.newmHandoff+32(SB), $0x0                        <span class="unimportant">proc.go:2891</span>
                   .          .   444e1b:                     NOPL 0(AX)(AX*1)                                             <span class="unimportant">proc.go:2891</span>
                   .          .   444e20:                     JE 0x444ed5                                                  <span class="unimportant">proc.go:2891</span>
</span>
<span class="line">   2892</span> <span class="livesrc">           .          .           			throw("on a locked thread with no template thread") </span><span class="asm">                   .          .   444ed5:                             LEAQ 0xb9113(IP), AX                                 <span class="unimportant">proc.go:2892</span>
                   .          .   444edc:                             MOVL $0x2a, BX                                       <span class="unimportant">proc.go:2892</span>
                   .          .   444ee1:                             CALL runtime.throw(SB)                               <span class="unimportant">proc.go:2892</span>
                   .          .   444ee6:                             NOPL                                                 <span class="unimportant">proc.go:2892</span>
</span>
<span class="line">   2893</span> <span class="nop">           .          .           		} </span>
<span class="line">   2894</span> <span class="livesrc">           .          .           		mp.schedlink = newmHandoff.newm </span><span class="asm">                   .          .   444e26:                     MOVQ runtime.newmHandoff+8(SB), CX                           <span class="unimportant">proc.go:2894</span>
                   .          .   444e2d:                     MOVQ 0x18(SP), DX                                            <span class="unimportant">proc.go:2894</span>
                   .          .   444e32:                     MOVQ CX, 0x160(DX)                                           <span class="unimportant">proc.go:2894</span>
</span>
<span class="line">   2895</span> <span class="livesrc">           .          .           		newmHandoff.newm.set(mp) </span><span class="asm">                   .          .   444e39:                     NOPL                                                         <span class="unimportant">proc.go:2895</span>
</span>
<span class="line">   2896</span> <span class="livesrc">           .          .           		if newmHandoff.waiting { </span><span class="asm">                   .          .   444e41:                     CMPB runtime.newmHandoff+16(SB), $0x0                        <span class="unimportant">proc.go:2896</span>
                   .          .   444e48:                     JE 0x444e5d                                                  <span class="unimportant">proc.go:2896</span>
</span>
<span class="line">   2897</span> <span class="livesrc">           .          .           			newmHandoff.waiting = false </span><span class="asm">                   .          .   444e4a:                             MOVB $0x0, runtime.newmHandoff+16(SB)                <span class="unimportant">proc.go:2897</span>
</span>
<span class="line">   2898</span> <span class="livesrc">           .          .           			notewakeup(&amp;newmHandoff.wake) </span><span class="asm">                   .          .   444e51:                             LEAQ runtime.newmHandoff+24(SB), AX                  <span class="unimportant">proc.go:2898</span>
                   .          .   444e58:                             CALL runtime.notewakeup(SB)                          <span class="unimportant">proc.go:2898</span>
</span>
<span class="line">   2899</span> <span class="nop">           .          .           		} </span>
<span class="line">   2900</span> <span class="livesrc">           .          .           		unlock(&amp;newmHandoff.lock) </span><span class="asm">                   .          .   444e5d:                     NOPL                                                         <span class="unimportant">proc.go:2900</span>
</span>
<span class="line">   2901</span> <span class="nop">           .          .           		// The M has not started yet, but the template thread does not </span>
<span class="line">   2902</span> <span class="nop">           .          .           		// participate in STW, so it will always process queued Ms and </span>
<span class="line">   2903</span> <span class="nop">           .          .           		// it is safe to releasem. </span>
<span class="line">   2904</span> <span class="livesrc">           .          .           		releasem(getg().m) </span><span class="asm">                   .          .   444e6b:                     MOVQ 0x30(R14), CX                                           <span class="unimportant">proc.go:2904</span>
</span>
<span class="line">   2905</span> <span class="livesrc">           .          .           		return </span><span class="asm">                   .          .   444e97:                     ADDQ $0x20, SP                                               <span class="unimportant">proc.go:2905</span>
                   .          .   444e9b:                     POPQ BP                                                      <span class="unimportant">proc.go:2905</span>
                   .          .   444e9c:                     RET                                                          <span class="unimportant">proc.go:2905</span>
                   .          .   444e9d:                     NOPL 0(AX)                                                   <span class="unimportant">proc.go:2905</span>
</span>
<span class="line">   2906</span> <span class="nop">           .          .           	} </span>
<span class="line">   2907</span> <span class="livesrc">           .          .           	newm1(mp) </span><span class="asm">                   .          .   444ea0:             CALL runtime.newm1(SB)                                               <span class="unimportant">proc.go:2907</span>
</span>
<span class="line">   2908</span> <span class="livesrc">           .          .           	releasem(getg().m) </span><span class="asm">                   .          .   444ea5:             MOVQ 0x30(R14), CX                                                   <span class="unimportant">proc.go:2908</span>
</span>
<span class="line">   2909</span> <span class="livesrc">           .          .           } </span><span class="asm">                   .          .   444ecf:     ADDQ $0x20, SP                                                               <span class="unimportant">proc.go:2909</span>
                   .          .   444ed3:     POPQ BP                                                                      <span class="unimportant">proc.go:2909</span>
                   .          .   444ed4:     RET                                                                          <span class="unimportant">proc.go:2909</span>
</span>
<span class="line">   2910</span> <span class="nop">           .          .            </span>
<span class="line">   2911</span> <span class="nop">           .          .           func newm1(mp *m) { </span>
<span class="line">   2912</span> <span class="nop">           .          .           	if iscgo { </span>
<span class="line">   2913</span> <span class="nop">           .          .           		var ts cgothreadstart </span>
<span class="line">   2914</span> <span class="nop">           .          .           		if _cgo_thread_start == nil { </span>
</pre>
<h2>runtime.startm</h2><p class="filename">/home/mikhliuk/go/go1.25.4/src/runtime/proc.go</p>
<pre onclick="pprof_toggle_asm(event)">  Total:           0        2MB (flat, cum)  0.35%
<span class="line">   3035</span> <span class="nop">           .          .           // returning. </span>
<span class="line">   3036</span> <span class="nop">           .          .           // </span>
<span class="line">   3037</span> <span class="nop">           .          .           // Must not have write barriers because this may be called without a P. </span>
<span class="line">   3038</span> <span class="nop">           .          .           // </span>
<span class="line">   3039</span> <span class="nop">           .          .           //go:nowritebarrierrec </span>
<span class="line">   3040</span> <span class="livesrc">           .          .           func startm(pp *p, spinning, lockheld bool) { </span><span class="asm">                   .          .   445340:     CMPQ SP, 0x10(R14)                                                           <span class="unimportant">proc.go:3040</span>
                   .          .   445344:     JBE 0x4455ee                                                                 <span class="unimportant">proc.go:3040</span>
                   .          .   44534a:     PUSHQ BP                                                                     <span class="unimportant">proc.go:3040</span>
                   .          .   44534b:     MOVQ SP, BP                                                                  <span class="unimportant">proc.go:3040</span>
                   .          .   44534e:     SUBQ $0x40, SP                                                               <span class="unimportant">proc.go:3040</span>
                                     ⋮
                   .          .   4455ee:     MOVQ AX, 0x8(SP)                                                             <span class="unimportant">proc.go:3040</span>
                   .          .   4455f3:     MOVB BL, 0x10(SP)                                                            <span class="unimportant">proc.go:3040</span>
                   .          .   4455f7:     MOVB CL, 0x11(SP)                                                            <span class="unimportant">proc.go:3040</span>
                   .          .   4455fb:     NOPL 0(AX)(AX*1)                                                             <span class="unimportant">proc.go:3040</span>
                   .          .   445600:     CALL runtime.morestack_noctxt.abi0(SB)                                       <span class="unimportant">proc.go:3040</span>
                   .          .   445605:     MOVQ 0x8(SP), AX                                                             <span class="unimportant">proc.go:3040</span>
                   .          .   44560a:     MOVZX 0x10(SP), BX                                                           <span class="unimportant">proc.go:3040</span>
                   .          .   44560f:     MOVZX 0x11(SP), CX                                                           <span class="unimportant">proc.go:3040</span>
                   .          .   445614:     JMP runtime.startm(SB)                                                       <span class="unimportant">proc.go:3040</span>
</span>
<span class="line">   3041</span> <span class="nop">           .          .           	// Disable preemption. </span>
<span class="line">   3042</span> <span class="nop">           .          .           	// </span>
<span class="line">   3043</span> <span class="nop">           .          .           	// Every owned P must have an owner that will eventually stop it in the </span>
<span class="line">   3044</span> <span class="nop">           .          .           	// event of a GC stop request. startm takes transient ownership of a P </span>
<span class="line">   3045</span> <span class="nop">           .          .           	// (either from argument or pidleget below) and transfers ownership to </span>
<span class="line">   3046</span> <span class="nop">           .          .           	// a started M, which will be responsible for performing the stop. </span>
<span class="line">   3047</span> <span class="nop">           .          .           	// </span>
<span class="line">   3048</span> <span class="nop">           .          .           	// Preemption must be disabled during this transient ownership, </span>
<span class="line">   3049</span> <span class="nop">           .          .           	// otherwise the P this is running on may enter GC stop while still </span>
<span class="line">   3050</span> <span class="nop">           .          .           	// holding the transient P, leaving that P in limbo and deadlocking the </span>
<span class="line">   3051</span> <span class="nop">           .          .           	// STW. </span>
<span class="line">   3052</span> <span class="nop">           .          .           	// </span>
<span class="line">   3053</span> <span class="nop">           .          .           	// Callers passing a non-nil P must already be in non-preemptible </span>
<span class="line">   3054</span> <span class="nop">           .          .           	// context, otherwise such preemption could occur on function entry to </span>
<span class="line">   3055</span> <span class="nop">           .          .           	// startm. Callers passing a nil P may be preemptible, so we must </span>
<span class="line">   3056</span> <span class="nop">           .          .           	// disable preemption before acquiring a P from pidleget below. </span>
<span class="line">   3057</span> <span class="livesrc">           .          .           	mp := acquirem() </span><span class="asm">                   .          .   44535e:             NOPL                                                                 <span class="unimportant">proc.go:3057</span>
</span>
<span class="line">   3058</span> <span class="livesrc">           .          .           	if !lockheld { </span><span class="asm">                   .          .   445352:             MOVB BL, 0x58(SP)                                                    <span class="unimportant">proc.go:3058</span>
                   .          .   445356:             MOVB CL, 0x59(SP)                                                    <span class="unimportant">proc.go:3058</span>
                                     ⋮
                   .          .   44536e:             TESTL CL, CL                                                         <span class="unimportant">proc.go:3058</span>
                   .          .   445370:             JNE 0x445399                                                         <span class="unimportant">proc.go:3058</span>
                   .          .   445372:             MOVQ AX, 0x50(SP)                                                    <span class="unimportant">proc.go:3058</span>
                                     ⋮
                   .          .   44538a:             MOVZX 0x59(SP), CX                                                   <span class="unimportant">proc.go:3058</span>
                                     ⋮
                   .          .   445394:             MOVZX 0x58(SP), BX                                                   <span class="unimportant">proc.go:3058</span>
                                     ⋮
                   .          .   4453a0:             TESTL BL, BL                                                         <span class="unimportant">proc.go:3058</span>
                                     ⋮
                   .          .   4453b8:             MOVZX 0x59(SP), CX                                                   <span class="unimportant">proc.go:3058</span>
                                     ⋮
                   .          .   4453c2:             MOVZX 0x58(SP), BX                                                   <span class="unimportant">proc.go:3058</span>
                                     ⋮
                   .          .   4453f2:             TESTL CL, CL                                                         <span class="unimportant">proc.go:3058</span>
                                     ⋮
                   .          .   445413:             MOVZX 0x58(SP), BX                                                   <span class="unimportant">proc.go:3058</span>
                                     ⋮
                   .          .   445440:             TESTL BL, BL                                                         <span class="unimportant">proc.go:3058</span>
                                     ⋮
                   .          .   445499:             MOVZX 0x59(SP), AX                                                   <span class="unimportant">proc.go:3058</span>
                   .          .   44549e:             NOPW                                                                 <span class="unimportant">proc.go:3058</span>
                   .          .   4454a0:             TESTL AL, AL                                                         <span class="unimportant">proc.go:3058</span>
                                     ⋮
                   .          .   4454e4:             MOVZX 0x59(SP), CX                                                   <span class="unimportant">proc.go:3058</span>
                   .          .   4454e9:             TESTL CL, CL                                                         <span class="unimportant">proc.go:3058</span>
</span>
<span class="line">   3059</span> <span class="livesrc">           .          .           		lock(&amp;sched.lock) </span><span class="asm">                   .          .   445377:                     NOPL                                                         <span class="unimportant">proc.go:3059</span>
</span>
<span class="line">   3060</span> <span class="nop">           .          .           	} </span>
<span class="line">   3061</span> <span class="livesrc">           .          .           	if pp == nil { </span><span class="asm">                   .          .   445385:             MOVQ 0x50(SP), AX                                                    <span class="unimportant">proc.go:3061</span>
                                     ⋮
                   .          .   445399:             TESTQ AX, AX                                                         <span class="unimportant">proc.go:3061</span>
                   .          .   44539c:             JNE 0x4453c7                                                         <span class="unimportant">proc.go:3061</span>
                   .          .   44539e:             NOPW                                                                 <span class="unimportant">proc.go:3061</span>
</span>
<span class="line">   3062</span> <span class="livesrc">           .          .           		if spinning { </span><span class="asm">                   .          .   4453a2:                     JNE 0x4455dc                                                 <span class="unimportant">proc.go:3062</span>
</span>
<span class="line">   3063</span> <span class="nop">           .          .           			// TODO(prattmic): All remaining calls to this function </span>
<span class="line">   3064</span> <span class="nop">           .          .           			// with _p_ == nil could be cleaned up to find a P </span>
<span class="line">   3065</span> <span class="nop">           .          .           			// before calling startm. </span>
<span class="line">   3066</span> <span class="livesrc">           .          .           			throw("startm: P required for spinning=true") </span><span class="asm">                   .          .   4455dc:                             LEAQ 0xb77d2(IP), AX                                 <span class="unimportant">proc.go:3066</span>
                   .          .   4455e3:                             MOVL $0x24, BX                                       <span class="unimportant">proc.go:3066</span>
                   .          .   4455e8:                             CALL runtime.throw(SB)                               <span class="unimportant">proc.go:3066</span>
                   .          .   4455ed:                             NOPL                                                 <span class="unimportant">proc.go:3066</span>
</span>
<span class="line">   3067</span> <span class="nop">           .          .           		} </span>
<span class="line">   3068</span> <span class="livesrc">           .          .           		pp, _ = pidleget(0) </span><span class="asm">                   .          .   4453a8:                     XORL AX, AX                                                  <span class="unimportant">proc.go:3068</span>
                   .          .   4453aa:                     CALL runtime.pidleget(SB)                                    <span class="unimportant">proc.go:3068</span>
</span>
<span class="line">   3069</span> <span class="livesrc">           .          .           		if pp == nil { </span><span class="asm">                   .          .   4453af:                     TESTQ AX, AX                                                 <span class="unimportant">proc.go:3069</span>
                   .          .   4453b2:                     JE 0x4454e4                                                  <span class="unimportant">proc.go:3069</span>
</span>
<span class="line">   3070</span> <span class="livesrc">           .          .           			if !lockheld { </span><span class="asm">                   .          .   4454eb:                             JNE 0x4454fb                                         <span class="unimportant">proc.go:3070</span>
</span>
<span class="line">   3071</span> <span class="livesrc">           .          .           				unlock(&amp;sched.lock) </span><span class="asm">                   .          .   4454ed:                                     NOPL                                         <span class="unimportant">proc.go:3071</span>
</span>
<span class="line">   3072</span> <span class="nop">           .          .           			} </span>
<span class="line">   3073</span> <span class="livesrc">           .          .           			releasem(mp) </span><span class="asm">                   .          .   445509:                             NOPL                                                 <span class="unimportant">proc.go:3073</span>
</span>
<span class="line">   3074</span> <span class="livesrc">           .          .           			return </span><span class="asm">                   .          .   445527:                             ADDQ $0x40, SP                                       <span class="unimportant">proc.go:3074</span>
                   .          .   44552b:                             POPQ BP                                              <span class="unimportant">proc.go:3074</span>
                   .          .   44552c:                             RET                                                  <span class="unimportant">proc.go:3074</span>
</span>
<span class="line">   3075</span> <span class="nop">           .          .           		} </span>
<span class="line">   3076</span> <span class="nop">           .          .           	} </span>
<span class="line">   3077</span> <span class="livesrc">           .          .           	nmp := mget() </span><span class="asm">                   .          .   4453ce:             NOPL                                                                 <span class="unimportant">proc.go:3077</span>
</span>
<span class="line">   3078</span> <span class="livesrc">           .          .           	if nmp == nil { </span><span class="asm">                   .          .   4453f0:             JE 0x44544d                                                          <span class="unimportant">proc.go:3078</span>
</span>
<span class="line">   3079</span> <span class="nop">           .          .           		// No M is available, we must drop sched.lock and call newm. </span>
<span class="line">   3080</span> <span class="nop">           .          .           		// However, we already own a P to assign to the M. </span>
<span class="line">   3081</span> <span class="nop">           .          .           		// </span>
<span class="line">   3082</span> <span class="nop">           .          .           		// Once sched.lock is released, another G (e.g., in a syscall), </span>
<span class="line">   3083</span> <span class="nop">           .          .           		// could find no idle P while checkdead finds a runnable G but </span>
<span class="line">   3084</span> <span class="nop">           .          .           		// no running M's because this new M hasn't started yet, thus </span>
<span class="line">   3085</span> <span class="nop">           .          .           		// throwing in an apparent deadlock. </span>
<span class="line">   3086</span> <span class="nop">           .          .           		// This apparent deadlock is possible when startm is called </span>
<span class="line">   3087</span> <span class="nop">           .          .           		// from sysmon, which doesn't count as a running M. </span>
<span class="line">   3088</span> <span class="nop">           .          .           		// </span>
<span class="line">   3089</span> <span class="nop">           .          .           		// Avoid this situation by pre-allocating the ID for the new M, </span>
<span class="line">   3090</span> <span class="nop">           .          .           		// thus marking it as 'running' before we drop sched.lock. This </span>
<span class="line">   3091</span> <span class="nop">           .          .           		// new M will eventually run the scheduler to execute any </span>
<span class="line">   3092</span> <span class="nop">           .          .           		// queued G's. </span>
<span class="line">   3093</span> <span class="livesrc">           .          .           		id := mReserveID() </span><span class="asm">                   .          .   44544d:                     CALL runtime.mReserveID(SB)                                  <span class="unimportant">proc.go:3093</span>
                   .          .   445452:                     MOVQ AX, 0x18(SP)                                            <span class="unimportant">proc.go:3093</span>
</span>
<span class="line">   3094</span> <span class="livesrc">           .          .           		unlock(&amp;sched.lock) </span><span class="asm">                   .          .   445464:                     NOPL                                                         <span class="unimportant">proc.go:3094</span>
</span>
<span class="line">   3095</span> <span class="nop">           .          .            </span>
<span class="line">   3096</span> <span class="nop">           .          .           		var fn func() </span>
<span class="line">   3097</span> <span class="livesrc">           .          .           		if spinning { </span><span class="asm">                   .          .   4454a2:                     JE 0x4454b2                                                  <span class="unimportant">proc.go:3097</span>
</span>
<span class="line">   3098</span> <span class="nop">           .          .           			// The caller incremented nmspinning, so set m.spinning in the new M. </span>
<span class="line">   3099</span> <span class="nop">           .          .           			fn = mspinning </span>
<span class="line">   3100</span> <span class="nop">           .          .           		} </span>
<span class="line">   3101</span> <span class="livesrc">           .        2MB           		newm(fn, pp, id) </span><span class="asm">                   .          .   445457:                     MOVZX 0x58(SP), AX                                           <span class="unimportant">proc.go:3101</span>
                   .          .   44545c:                     MOVZX AL, AX                                                 <span class="unimportant">proc.go:3101</span>
                   .          .   44545f:                     MOVQ AX, 0x20(SP)                                            <span class="unimportant">proc.go:3101</span>
                                     ⋮
                   .          .   445472:                     MOVQ 0x20(SP), AX                                            <span class="unimportant">proc.go:3101</span>
                   .          .   445477:                     TESTQ AX, AX                                                 <span class="unimportant">proc.go:3101</span>
                   .          .   44547a:                     MOVL $0x0, AX                                                <span class="unimportant">proc.go:3101</span>
                   .          .   44547f:                     LEAQ 0xbb932(IP), CX                                         <span class="unimportant">proc.go:3101</span>
                   .          .   445486:                     CMOVNE CX, AX                                                <span class="unimportant">proc.go:3101</span>
                   .          .   44548a:                     MOVQ 0x30(SP), BX                                            <span class="unimportant">proc.go:3101</span>
                   .          .   44548f:                     MOVQ 0x18(SP), CX                                            <span class="unimportant">proc.go:3101</span>
                   .        2MB   445494:                     CALL runtime.newm(SB)                                        <span class="unimportant">proc.go:3101</span>
</span>
<span class="line">   3102</span> <span class="nop">           .          .            </span>
<span class="line">   3103</span> <span class="nop">           .          .           		if lockheld { </span>
<span class="line">   3104</span> <span class="livesrc">           .          .           			lock(&amp;sched.lock) </span><span class="asm">                   .          .   4454a4:                             NOPL                                                 <span class="unimportant">proc.go:3104</span>
</span>
<span class="line">   3105</span> <span class="nop">           .          .           		} </span>
<span class="line">   3106</span> <span class="nop">           .          .           		// Ownership transfer of pp committed by start in newm. </span>
<span class="line">   3107</span> <span class="nop">           .          .           		// Preemption is now safe. </span>
<span class="line">   3108</span> <span class="livesrc">           .          .           		releasem(mp) </span><span class="asm">                   .          .   4454c0:                     NOPL                                                         <span class="unimportant">proc.go:3108</span>
</span>
<span class="line">   3109</span> <span class="livesrc">           .          .           		return </span><span class="asm">                   .          .   4454de:                     ADDQ $0x40, SP                                               <span class="unimportant">proc.go:3109</span>
                   .          .   4454e2:                     POPQ BP                                                      <span class="unimportant">proc.go:3109</span>
                   .          .   4454e3:                     RET                                                          <span class="unimportant">proc.go:3109</span>
</span>
<span class="line">   3110</span> <span class="nop">           .          .           	} </span>
<span class="line">   3111</span> <span class="livesrc">           .          .           	if !lockheld { </span><span class="asm">                   .          .   4453f4:             JNE 0x44541d                                                         <span class="unimportant">proc.go:3111</span>
</span>
<span class="line">   3112</span> <span class="livesrc">           .          .           		unlock(&amp;sched.lock) </span><span class="asm">                   .          .   4453fb:                     NOPL                                                         <span class="unimportant">proc.go:3112</span>
</span>
<span class="line">   3113</span> <span class="nop">           .          .           	} </span>
<span class="line">   3114</span> <span class="livesrc">           .          .           	if nmp.spinning { </span><span class="asm">                   .          .   445418:             MOVQ 0x38(SP), SI                                                    <span class="unimportant">proc.go:3114</span>
                   .          .   44541d:             CMPB 0x10c(SI), $0x0                                                 <span class="unimportant">proc.go:3114</span>
                   .          .   445424:             JNE 0x4455cb                                                         <span class="unimportant">proc.go:3114</span>
</span>
<span class="line">   3115</span> <span class="livesrc">           .          .           		throw("startm: m is spinning") </span><span class="asm">                   .          .   4455cb:                     LEAQ 0xb3d96(IP), AX                                         <span class="unimportant">proc.go:3115</span>
                   .          .   4455d2:                     MOVL $0x15, BX                                               <span class="unimportant">proc.go:3115</span>
                   .          .   4455d7:                     CALL runtime.throw(SB)                                       <span class="unimportant">proc.go:3115</span>
</span>
<span class="line">   3116</span> <span class="nop">           .          .           	} </span>
<span class="line">   3117</span> <span class="livesrc">           .          .           	if nmp.nextp != 0 { </span><span class="asm">                   .          .   44542a:             CMPQ 0xd0(SI), $0x0                                                  <span class="unimportant">proc.go:3117</span>
                   .          .   445432:             JNE 0x4455ba                                                         <span class="unimportant">proc.go:3117</span>
                   .          .   445438:             NOPL 0(AX)(AX*1)                                                     <span class="unimportant">proc.go:3117</span>
</span>
<span class="line">   3118</span> <span class="livesrc">           .          .           		throw("startm: m has p") </span><span class="asm">                   .          .   4455ba:                     LEAQ 0xb2618(IP), AX                                         <span class="unimportant">proc.go:3118</span>
                   .          .   4455c1:                     MOVL $0xf, BX                                                <span class="unimportant">proc.go:3118</span>
                   .          .   4455c6:                     CALL runtime.throw(SB)                                       <span class="unimportant">proc.go:3118</span>
</span>
<span class="line">   3119</span> <span class="nop">           .          .           	} </span>
<span class="line">   3120</span> <span class="livesrc">           .          .           	if spinning &amp;&amp; !runqempty(pp) { </span><span class="asm">                   .          .   445442:             JE 0x44552d                                                          <span class="unimportant">proc.go:3120</span>
                                     ⋮
                   .          .   4455a7:             JE 0x44552d                                                          <span class="unimportant">proc.go:3120</span>
</span>
<span class="line">   3121</span> <span class="livesrc">           .          .           		throw("startm: p has runnable gs") </span><span class="asm">                   .          .   4455a9:                     LEAQ 0xb4ce5(IP), AX                                         <span class="unimportant">proc.go:3121</span>
                   .          .   4455b0:                     MOVL $0x19, BX                                               <span class="unimportant">proc.go:3121</span>
                   .          .   4455b5:                     CALL runtime.throw(SB)                                       <span class="unimportant">proc.go:3121</span>
</span>
<span class="line">   3122</span> <span class="nop">           .          .           	} </span>
<span class="line">   3123</span> <span class="nop">           .          .           	// The caller incremented nmspinning, so set m.spinning in the new M. </span>
<span class="line">   3124</span> <span class="livesrc">           .          .           	nmp.spinning = spinning </span><span class="asm">                   .          .   44552d:             MOVB BL, 0x10c(SI)                                                   <span class="unimportant">proc.go:3124</span>
</span>
<span class="line">   3125</span> <span class="livesrc">           .          .           	nmp.nextp.set(pp) </span><span class="asm">                   .          .   4453eb:             MOVQ AX, 0x30(SP)                                                    <span class="unimportant">proc.go:3125</span>
</span>
<span class="line">   3126</span> <span class="livesrc">           .          .           	notewakeup(&amp;nmp.park) </span><span class="asm">                   .          .   445533:             LEAQ 0x150(SI), CX                                                   <span class="unimportant">proc.go:3126</span>
                                     ⋮
                   .          .   445541:             MOVQ CX, AX                                                          <span class="unimportant">proc.go:3126</span>
                   .          .   445544:             CALL runtime.notewakeup(SB)                                          <span class="unimportant">proc.go:3126</span>
</span>
<span class="line">   3127</span> <span class="nop">           .          .           	// Ownership transfer of pp committed by wakeup. Preemption is now </span>
<span class="line">   3128</span> <span class="nop">           .          .           	// safe. </span>
<span class="line">   3129</span> <span class="livesrc">           .          .           	releasem(mp) </span><span class="asm">                   .          .   445557:             NOPL                                                                 <span class="unimportant">proc.go:3129</span>
</span>
<span class="line">   3130</span> <span class="livesrc">           .          .           } </span><span class="asm">                   .          .   445577:     ADDQ $0x40, SP                                                               <span class="unimportant">proc.go:3130</span>
                   .          .   44557b:     POPQ BP                                                                      <span class="unimportant">proc.go:3130</span>
                   .          .   44557c:     RET                                                                          <span class="unimportant">proc.go:3130</span>
</span>
<span class="line">   3131</span> <span class="nop">           .          .            </span>
<span class="line">   3132</span> <span class="nop">           .          .           // Hands off P from syscall or locked M. </span>
<span class="line">   3133</span> <span class="nop">           .          .           // Always runs without a P, so write barriers are not allowed. </span>
<span class="line">   3134</span> <span class="nop">           .          .           // </span>
<span class="line">   3135</span> <span class="nop">           .          .           //go:nowritebarrierrec </span>
</pre>
<h2>runtime.wakep</h2><p class="filename">/home/mikhliuk/go/go1.25.4/src/runtime/proc.go</p>
<pre onclick="pprof_toggle_asm(event)">  Total:           0     1.50MB (flat, cum)  0.26%
<span class="line">   3212</span> <span class="nop">           .          .           // </span>
<span class="line">   3213</span> <span class="nop">           .          .           // Do not remove or change the type signature. </span>
<span class="line">   3214</span> <span class="nop">           .          .           // See go.dev/issue/67401. </span>
<span class="line">   3215</span> <span class="nop">           .          .           // </span>
<span class="line">   3216</span> <span class="nop">           .          .           //go:linkname wakep </span>
<span class="line">   3217</span> <span class="livesrc">           .          .           func wakep() { </span><span class="asm">                   .          .   470580:     CMPQ SP, 0x10(R14)                                                           <span class="unimportant">proc.go:3217</span>
                   .          .   470584:     JBE 0x4706b0                                                                 <span class="unimportant">proc.go:3217</span>
                   .          .   47058a:     PUSHQ BP                                                                     <span class="unimportant">proc.go:3217</span>
                   .          .   47058b:     MOVQ SP, BP                                                                  <span class="unimportant">proc.go:3217</span>
                   .          .   47058e:     SUBQ $0x20, SP                                                               <span class="unimportant">proc.go:3217</span>
                                     ⋮
                   .          .   4706b0:     CALL runtime.morestack_noctxt.abi0(SB)                                       <span class="unimportant">proc.go:3217</span>
                   .          .   4706b5:     JMP runtime.wakep(SB)                                                        <span class="unimportant">proc.go:3217</span>
</span>
<span class="line">   3218</span> <span class="nop">           .          .           	// Be conservative about spinning threads, only start one if none exist </span>
<span class="line">   3219</span> <span class="nop">           .          .           	// already. </span>
<span class="line">   3220</span> <span class="livesrc">           .          .           	if sched.nmspinning.Load() != 0 || !sched.nmspinning.CompareAndSwap(0, 1) { </span><span class="asm">                   .          .   470598:             TESTL CX, CX                                                         <span class="unimportant">proc.go:3220</span>
                   .          .   47059a:             JNE 0x4705b5                                                         <span class="unimportant">proc.go:3220</span>
                                     ⋮
                   .          .   4705b3:             JNE 0x4705bb                                                         <span class="unimportant">proc.go:3220</span>
</span>
<span class="line">   3221</span> <span class="livesrc">           .          .           		return </span><span class="asm">                   .          .   4705b5:                     ADDQ $0x20, SP                                               <span class="unimportant">proc.go:3221</span>
                   .          .   4705b9:                     POPQ BP                                                      <span class="unimportant">proc.go:3221</span>
                   .          .   4705ba:                     RET                                                          <span class="unimportant">proc.go:3221</span>
</span>
<span class="line">   3222</span> <span class="nop">           .          .           	} </span>
<span class="line">   3223</span> <span class="nop">           .          .            </span>
<span class="line">   3224</span> <span class="nop">           .          .           	// Disable preemption until ownership of pp transfers to the next M in </span>
<span class="line">   3225</span> <span class="nop">           .          .           	// startm. Otherwise preemption here would leave pp stuck waiting to </span>
<span class="line">   3226</span> <span class="nop">           .          .           	// enter _Pgcstop. </span>
<span class="line">   3227</span> <span class="nop">           .          .           	// </span>
<span class="line">   3228</span> <span class="nop">           .          .           	// See preemption comment on acquirem in startm for more details. </span>
<span class="line">   3229</span> <span class="livesrc">           .          .           	mp := acquirem() </span><span class="asm">                   .          .   4705bf:             NOPL                                                                 <span class="unimportant">proc.go:3229</span>
</span>
<span class="line">   3230</span> <span class="nop">           .          .            </span>
<span class="line">   3231</span> <span class="nop">           .          .           	var pp *p </span>
<span class="line">   3232</span> <span class="livesrc">           .          .           	lock(&amp;sched.lock) </span><span class="asm">                   .          .   4705c6:             NOPL                                                                 <span class="unimportant">proc.go:3232</span>
</span>
<span class="line">   3233</span> <span class="livesrc">           .          .           	pp, _ = pidlegetSpinning(0) </span><span class="asm">                   .          .   4705dd:             XORL AX, AX                                                          <span class="unimportant">proc.go:3233</span>
                   .          .   4705df:             NOPL                                                                 <span class="unimportant">proc.go:3233</span>
                   .          .   4705e0:             CALL runtime.pidlegetSpinning(SB)                                    <span class="unimportant">proc.go:3233</span>
                                     ⋮
                   .          .   470648:             MOVQ AX, 0x18(SP)                                                    <span class="unimportant">proc.go:3233</span>
</span>
<span class="line">   3234</span> <span class="livesrc">           .          .           	if pp == nil { </span><span class="asm">                   .          .   4705e5:             TESTQ AX, AX                                                         <span class="unimportant">proc.go:3234</span>
                   .          .   4705e8:             JNE 0x470648                                                         <span class="unimportant">proc.go:3234</span>
</span>
<span class="line">   3235</span> <span class="livesrc">           .          .           		if sched.nmspinning.Add(-1) &lt; 0 { </span><span class="asm">                   .          .   470600:                     TESTL CX, CX                                                 <span class="unimportant">proc.go:3235</span>
                   .          .   470602:                     JL 0x47069e                                                  <span class="unimportant">proc.go:3235</span>
</span>
<span class="line">   3236</span> <span class="livesrc">           .          .           			throw("wakep: negative nmspinning") </span><span class="asm">                   .          .   47069e:                             LEAQ 0x89f68(IP), AX                                 <span class="unimportant">proc.go:3236</span>
                   .          .   4706a5:                             MOVL $0x1a, BX                                       <span class="unimportant">proc.go:3236</span>
                   .          .   4706aa:                             CALL runtime.throw(SB)                               <span class="unimportant">proc.go:3236</span>
                   .          .   4706af:                             NOPL                                                 <span class="unimportant">proc.go:3236</span>
</span>
<span class="line">   3237</span> <span class="nop">           .          .           		} </span>
<span class="line">   3238</span> <span class="livesrc">           .          .           		unlock(&amp;sched.lock) </span><span class="asm">                   .          .   470608:                     NOPL                                                         <span class="unimportant">proc.go:3238</span>
</span>
<span class="line">   3239</span> <span class="livesrc">           .          .           		releasem(mp) </span><span class="asm">                   .          .   470624:                     NOPL                                                         <span class="unimportant">proc.go:3239</span>
</span>
<span class="line">   3240</span> <span class="livesrc">           .          .           		return </span><span class="asm">                   .          .   470642:                     ADDQ $0x20, SP                                               <span class="unimportant">proc.go:3240</span>
                   .          .   470646:                     POPQ BP                                                      <span class="unimportant">proc.go:3240</span>
                   .          .   470647:                     RET                                                          <span class="unimportant">proc.go:3240</span>
</span>
<span class="line">   3241</span> <span class="nop">           .          .           	} </span>
<span class="line">   3242</span> <span class="nop">           .          .           	// Since we always have a P, the race in the "No M is available" </span>
<span class="line">   3243</span> <span class="nop">           .          .           	// comment in startm doesn't apply during the small window between the </span>
<span class="line">   3244</span> <span class="nop">           .          .           	// unlock here and lock in startm. A checkdead in between will always </span>
<span class="line">   3245</span> <span class="nop">           .          .           	// see at least one running M (ours). </span>
<span class="line">   3246</span> <span class="livesrc">           .          .           	unlock(&amp;sched.lock) </span><span class="asm">                   .          .   47064d:             NOPL                                                                 <span class="unimportant">proc.go:3246</span>
</span>
<span class="line">   3247</span> <span class="nop">           .          .            </span>
<span class="line">   3248</span> <span class="livesrc">           .     1.50MB           	startm(pp, true, false) </span><span class="asm">                   .          .   47065b:             MOVQ 0x18(SP), AX                                                    <span class="unimportant">proc.go:3248</span>
                   .          .   470660:             MOVL $0x1, BX                                                        <span class="unimportant">proc.go:3248</span>
                   .          .   470665:             XORL CX, CX                                                          <span class="unimportant">proc.go:3248</span>
                   .     1.50MB   470667:             CALL runtime.startm(SB)                                              <span class="unimportant">proc.go:3248</span>
</span>
<span class="line">   3249</span> <span class="nop">           .          .            </span>
<span class="line">   3250</span> <span class="livesrc">           .          .           	releasem(mp) </span><span class="asm">                   .          .   47067a:             NOPL                                                                 <span class="unimportant">proc.go:3250</span>
</span>
<span class="line">   3251</span> <span class="livesrc">           .          .           } </span><span class="asm">                   .          .   470698:     ADDQ $0x20, SP                                                               <span class="unimportant">proc.go:3251</span>
                   .          .   47069c:     POPQ BP                                                                      <span class="unimportant">proc.go:3251</span>
                   .          .   47069d:     RET                                                                          <span class="unimportant">proc.go:3251</span>
</span>
<span class="line">   3252</span> <span class="nop">           .          .            </span>
<span class="line">   3253</span> <span class="nop">           .          .           // Stops execution of the current m that is locked to a g until the g is runnable again. </span>
<span class="line">   3254</span> <span class="nop">           .          .           // Returns with acquired P. </span>
<span class="line">   3255</span> <span class="nop">           .          .           func stoplockedm() { </span>
<span class="line">   3256</span> <span class="nop">           .          .           	gp := getg() </span>
</pre>
<h2>runtime.resetspinning</h2><p class="filename">/home/mikhliuk/go/go1.25.4/src/runtime/proc.go</p>
<pre onclick="pprof_toggle_asm(event)">  Total:           0     1.50MB (flat, cum)  0.26%
<span class="line">   4004</span> <span class="nop">           .          .           			wakep() </span>
<span class="line">   4005</span> <span class="nop">           .          .           		} </span>
<span class="line">   4006</span> <span class="nop">           .          .           	} </span>
<span class="line">   4007</span> <span class="nop">           .          .           } </span>
<span class="line">   4008</span> <span class="nop">           .          .            </span>
<span class="line">   4009</span> <span class="livesrc">           .          .           func resetspinning() { </span><span class="asm">                   .          .   447bc0:     CMPQ SP, 0x10(R14)                                                           <span class="unimportant">proc.go:4009</span>
                   .          .   447bc4:     JBE 0x447c27                                                                 <span class="unimportant">proc.go:4009</span>
                   .          .   447bc6:     PUSHQ BP                                                                     <span class="unimportant">proc.go:4009</span>
                   .          .   447bc7:     MOVQ SP, BP                                                                  <span class="unimportant">proc.go:4009</span>
                   .          .   447bca:     SUBQ $0x10, SP                                                               <span class="unimportant">proc.go:4009</span>
                                     ⋮
                   .          .   447c27:     CALL runtime.morestack_noctxt.abi0(SB)                                       <span class="unimportant">proc.go:4009</span>
                   .          .   447c2c:     JMP runtime.resetspinning(SB)                                                <span class="unimportant">proc.go:4009</span>
</span>
<span class="line">   4010</span> <span class="livesrc">           .          .           	gp := getg() </span><span class="asm">                   .          .   447bce:             MOVQ 0x30(R14), CX                                                   <span class="unimportant">proc.go:4010</span>
</span>
<span class="line">   4011</span> <span class="livesrc">           .          .           	if !gp.m.spinning { </span><span class="asm">                   .          .   447bd2:             CMPB 0x10c(CX), $0x0                                                 <span class="unimportant">proc.go:4011</span>
                   .          .   447bd9:             JE 0x447c15                                                          <span class="unimportant">proc.go:4011</span>
</span>
<span class="line">   4012</span> <span class="livesrc">           .          .           		throw("resetspinning: not a spinning m") </span><span class="asm">                   .          .   447c15:                     LEAQ 0xb3ebc(IP), AX                                         <span class="unimportant">proc.go:4012</span>
                   .          .   447c1c:                     MOVL $0x1f, BX                                               <span class="unimportant">proc.go:4012</span>
                   .          .   447c21:                     CALL runtime.throw(SB)                                       <span class="unimportant">proc.go:4012</span>
                   .          .   447c26:                     NOPL                                                         <span class="unimportant">proc.go:4012</span>
</span>
<span class="line">   4013</span> <span class="nop">           .          .           	} </span>
<span class="line">   4014</span> <span class="livesrc">           .          .           	gp.m.spinning = false </span><span class="asm">                   .          .   447bdb:             MOVB $0x0, 0x10c(CX)                                                 <span class="unimportant">proc.go:4014</span>
</span>
<span class="line">   4015</span> <span class="livesrc">           .          .           	nmspinning := sched.nmspinning.Add(-1) </span><span class="asm">                   .          .   447be2:             NOPL                                                                 <span class="unimportant">proc.go:4015</span>
</span>
<span class="line">   4016</span> <span class="livesrc">           .          .           	if nmspinning &lt; 0 { </span><span class="asm">                   .          .   447bf5:             TESTL CX, CX                                                         <span class="unimportant">proc.go:4016</span>
                   .          .   447bf7:             JL 0x447c04                                                          <span class="unimportant">proc.go:4016</span>
</span>
<span class="line">   4017</span> <span class="livesrc">           .          .           		throw("findrunnable: negative nmspinning") </span><span class="asm">                   .          .   447c04:                     LEAQ 0xb4732(IP), AX                                         <span class="unimportant">proc.go:4017</span>
                   .          .   447c0b:                     MOVL $0x21, BX                                               <span class="unimportant">proc.go:4017</span>
                   .          .   447c10:                     CALL runtime.throw(SB)                                       <span class="unimportant">proc.go:4017</span>
</span>
<span class="line">   4018</span> <span class="nop">           .          .           	} </span>
<span class="line">   4019</span> <span class="nop">           .          .           	// M wakeup policy is deliberately somewhat conservative, so check if we </span>
<span class="line">   4020</span> <span class="nop">           .          .           	// need to wakeup another P here. See "Worker thread parking/unparking" </span>
<span class="line">   4021</span> <span class="nop">           .          .           	// comment at the top of the file for details. </span>
<span class="line">   4022</span> <span class="livesrc">           .     1.50MB           	wakep() </span><span class="asm">                   .     1.50MB   447bf9:             CALL runtime.wakep(SB)                                               <span class="unimportant">proc.go:4022</span>
</span>
<span class="line">   4023</span> <span class="livesrc">           .          .           } </span><span class="asm">                   .          .   447bfe:     ADDQ $0x10, SP                                                               <span class="unimportant">proc.go:4023</span>
                   .          .   447c02:     POPQ BP                                                                      <span class="unimportant">proc.go:4023</span>
                   .          .   447c03:     RET                                                                          <span class="unimportant">proc.go:4023</span>
</span>
<span class="line">   4024</span> <span class="nop">           .          .            </span>
<span class="line">   4025</span> <span class="nop">           .          .           // injectglist adds each runnable G on the list to some run queue, </span>
<span class="line">   4026</span> <span class="nop">           .          .           // and clears glist. If there is no current P, they are added to the </span>
<span class="line">   4027</span> <span class="nop">           .          .           // global queue, and up to npidle M's are started to run them. </span>
</pre>
<h2>runtime.injectglist.func1</h2><p class="filename">/home/mikhliuk/go/go1.25.4/src/runtime/proc.go</p>
<pre onclick="pprof_toggle_asm(event)">  Total:           0      513kB (flat, cum) 0.087%
<span class="line">   4057</span> <span class="livesrc">           .          .           	startIdle := func(n int32) { </span><span class="asm">                   .          .   46c840:             CMPQ SP, 0x10(R14)                                                   <span class="unimportant">proc.go:4057</span>
                   .          .   46c844:             JBE 0x46c929                                                         <span class="unimportant">proc.go:4057</span>
                   .          .   46c84a:             PUSHQ BP                                                             <span class="unimportant">proc.go:4057</span>
                   .          .   46c84b:             MOVQ SP, BP                                                          <span class="unimportant">proc.go:4057</span>
                   .          .   46c84e:             SUBQ $0x20, SP                                                       <span class="unimportant">proc.go:4057</span>
                                     ⋮
                   .          .   46c929:             MOVL AX, 0x8(SP)                                                     <span class="unimportant">proc.go:4057</span>
                   .          .   46c92d:             CALL runtime.morestack_noctxt.abi0(SB)                               <span class="unimportant">proc.go:4057</span>
                   .          .   46c932:             MOVL 0x8(SP), AX                                                     <span class="unimportant">proc.go:4057</span>
                   .          .   46c936:             JMP runtime.injectglist.func1(SB)                                    <span class="unimportant">proc.go:4057</span>
</span>
<span class="line">   4058</span> <span class="livesrc">           .          .           		for ; n &gt; 0; n-- { </span><span class="asm">                   .          .   46c852:                     JMP 0x46c860                                                 <span class="unimportant">proc.go:4058</span>
                   .          .   46c854:                     MOVL 0x14(SP), AX                                            <span class="unimportant">proc.go:4058</span>
                   .          .   46c858:                     DECL AX                                                      <span class="unimportant">proc.go:4058</span>
                   .          .   46c85a:                     NOPW 0(AX)(AX*1)                                             <span class="unimportant">proc.go:4058</span>
                   .          .   46c860:                     TESTL AX, AX                                                 <span class="unimportant">proc.go:4058</span>
                   .          .   46c862:                     JLE 0x46c923                                                 <span class="unimportant">proc.go:4058</span>
                   .          .   46c868:                     MOVL AX, 0x14(SP)                                            <span class="unimportant">proc.go:4058</span>
</span>
<span class="line">   4059</span> <span class="livesrc">           .          .           			mp := acquirem() // See comment in startm. </span><span class="asm">                   .          .   46c870:                             NOPL                                                 <span class="unimportant">proc.go:4059</span>
</span>
<span class="line">   4060</span> <span class="livesrc">           .          .           			lock(&amp;sched.lock) </span><span class="asm">                   .          .   46c877:                             NOPL                                                 <span class="unimportant">proc.go:4060</span>
</span>
<span class="line">   4061</span> <span class="nop">           .          .            </span>
<span class="line">   4062</span> <span class="livesrc">           .          .           			pp, _ := pidlegetSpinning(0) </span><span class="asm">                   .          .   46c88e:                             XORL AX, AX                                          <span class="unimportant">proc.go:4062</span>
                   .          .   46c890:                             CALL runtime.pidlegetSpinning(SB)                    <span class="unimportant">proc.go:4062</span>
</span>
<span class="line">   4063</span> <span class="livesrc">           .          .           			if pp == nil { </span><span class="asm">                   .          .   46c895:                             TESTQ AX, AX                                         <span class="unimportant">proc.go:4063</span>
                   .          .   46c898:                             JE 0x46c8e9                                          <span class="unimportant">proc.go:4063</span>
</span>
<span class="line">   4064</span> <span class="livesrc">           .          .           				unlock(&amp;sched.lock) </span><span class="asm">                   .          .   46c8e9:                                     NOPL                                         <span class="unimportant">proc.go:4064</span>
</span>
<span class="line">   4065</span> <span class="livesrc">           .          .           				releasem(mp) </span><span class="asm">                   .          .   46c905:                                     NOPL                                         <span class="unimportant">proc.go:4065</span>
</span>
<span class="line">   4066</span> <span class="nop">           .          .           				break </span>
<span class="line">   4067</span> <span class="nop">           .          .           			} </span>
<span class="line">   4068</span> <span class="nop">           .          .            </span>
<span class="line">   4069</span> <span class="livesrc">           .      513kB           			startm(pp, false, true) </span><span class="asm">                   .          .   46c89a:                             XORL BX, BX                                          <span class="unimportant">proc.go:4069</span>
                   .          .   46c89c:                             MOVL $0x1, CX                                        <span class="unimportant">proc.go:4069</span>
                   .      513kB   46c8a1:                             CALL runtime.startm(SB)                              <span class="unimportant">proc.go:4069</span>
</span>
<span class="line">   4070</span> <span class="livesrc">           .          .           			unlock(&amp;sched.lock) </span><span class="asm">                   .          .   46c8a6:                             NOPL                                                 <span class="unimportant">proc.go:4070</span>
</span>
<span class="line">   4071</span> <span class="livesrc">           .          .           			releasem(mp) </span><span class="asm">                   .          .   46c8c2:                             NOPL                                                 <span class="unimportant">proc.go:4071</span>
</span>
<span class="line">   4072</span> <span class="nop">           .          .           		} </span>
<span class="line">   4073</span> <span class="livesrc">           .          .           	} </span><span class="asm">                   .          .   46c923:             ADDQ $0x20, SP                                                       <span class="unimportant">proc.go:4073</span>
                   .          .   46c927:             POPQ BP                                                              <span class="unimportant">proc.go:4073</span>
                   .          .   46c928:             RET                                                                  <span class="unimportant">proc.go:4073</span>
</span>
</pre>
<h2>runtime.injectglist</h2><p class="filename">/home/mikhliuk/go/go1.25.4/src/runtime/proc.go</p>
<pre onclick="pprof_toggle_asm(event)">  Total:           0      513kB (flat, cum) 0.087%
<span class="line">   4075</span> <span class="livesrc">           .          .           	pp := getg().m.p.ptr() </span><span class="asm">                   .          .   447d5f:             MOVQ 0x30(R14), CX                                                   <span class="unimportant">proc.go:4075</span>
                   .          .   447d63:             MOVQ 0xc8(CX), AX                                                    <span class="unimportant">proc.go:4075</span>
</span>
<span class="line">   4076</span> <span class="livesrc">           .          .           	if pp == nil { </span><span class="asm">                   .          .   447d6a:             TESTQ AX, AX                                                         <span class="unimportant">proc.go:4076</span>
                   .          .   447d6d:             JE 0x447d89                                                          <span class="unimportant">proc.go:4076</span>
</span>
<span class="line">   4077</span> <span class="nop">           .          .           		n := q.size </span>
<span class="line">   4078</span> <span class="livesrc">           .          .           		lock(&amp;sched.lock) </span><span class="asm">                   .          .   447d8d:                     NOPL                                                         <span class="unimportant">proc.go:4078</span>
</span>
<span class="line">   4079</span> <span class="livesrc">           .          .           		globrunqputbatch(&amp;q) </span><span class="asm">                   .          .   447da0:                     NOPL                                                         <span class="unimportant">proc.go:4079</span>
</span>
<span class="line">   4080</span> <span class="livesrc">           .          .           		unlock(&amp;sched.lock) </span><span class="asm">                   .          .   447df4:                     NOPL                                                         <span class="unimportant">proc.go:4080</span>
</span>
<span class="line">   4081</span> <span class="livesrc">           .      513kB           		startIdle(n) </span><span class="asm">                   .          .   447e05:                     MOVQ 0xb8f94(IP), CX                                         <span class="unimportant">proc.go:4081</span>
                   .          .   447e0c:                     MOVL 0x24(SP), AX                                            <span class="unimportant">proc.go:4081</span>
                   .          .   447e10:                     LEAQ 0xb8f89(IP), DX                                         <span class="unimportant">proc.go:4081</span>
                   .      513kB   447e17:                     CALL CX                                                      <span class="unimportant">proc.go:4081</span>
</span>
<span class="line">   4082</span> <span class="livesrc">           .          .           		return </span><span class="asm">                   .          .   447e19:                     ADDQ $0x78, SP                                               <span class="unimportant">proc.go:4082</span>
                   .          .   447e1d:                     POPQ BP                                                      <span class="unimportant">proc.go:4082</span>
                   .          .   447e1e:                     RET                                                          <span class="unimportant">proc.go:4082</span>
</span>
<span class="line">   4083</span> <span class="nop">           .          .           	} </span>
<span class="line">   4084</span> <span class="nop">           .          .            </span>
<span class="line">   4085</span> <span class="livesrc">           .          .           	var globq gQueue </span><span class="asm">                   .          .   447d6f:             MOVUPS X15, 0x48(SP)                                                 <span class="unimportant">proc.go:4085</span>
                   .          .   447d75:             MOVL $0x0, 0x58(SP)                                                  <span class="unimportant">proc.go:4085</span>
</span>
<span class="line">   4086</span> <span class="livesrc">           .          .           	npidle := sched.npidle.Load() </span><span class="asm">                   .          .   447d7d:             NOPL                                                                 <span class="unimportant">proc.go:4086</span>
</span>
<span class="line">   4087</span> <span class="livesrc">           .          .           	for ; npidle &gt; 0 &amp;&amp; !q.empty(); npidle-- { </span><span class="asm">                   .          .   447d84:             JMP 0x447e2b                                                         <span class="unimportant">proc.go:4087</span>
                                     ⋮
                   .          .   447e29:             DECL CX                                                              <span class="unimportant">proc.go:4087</span>
                   .          .   447e2b:             TESTL CX, CX                                                         <span class="unimportant">proc.go:4087</span>
                   .          .   447e2d:             JLE 0x447e92                                                         <span class="unimportant">proc.go:4087</span>
                                     ⋮
                   .          .   447e37:             JE 0x447e92                                                          <span class="unimportant">proc.go:4087</span>
</span>
<span class="line">   4088</span> <span class="livesrc">           .          .           		g := q.pop() </span><span class="asm">                   .          .   447e39:                     NOPL                                                         <span class="unimportant">proc.go:4088</span>
</span>
<span class="line">   4089</span> <span class="livesrc">           .          .           		globq.pushBack(g) </span><span class="asm">                   .          .   447e63:                     NOPL                                                         <span class="unimportant">proc.go:4089</span>
</span>
<span class="line">   4090</span> <span class="nop">           .          .           	} </span>
<span class="line">   4091</span> <span class="livesrc">           .          .           	if !globq.empty() { </span><span class="asm">                   .          .   447e98:             JE 0x447f3e                                                          <span class="unimportant">proc.go:4091</span>
</span>
<span class="line">   4092</span> <span class="livesrc">           .          .           		n := globq.size </span><span class="asm">                   .          .   447ea3:                     MOVL 0x58(SP), CX                                            <span class="unimportant">proc.go:4092</span>
                   .          .   447ea7:                     MOVL CX, 0x20(SP)                                            <span class="unimportant">proc.go:4092</span>
</span>
<span class="line">   4093</span> <span class="livesrc">           .          .           		lock(&amp;sched.lock) </span><span class="asm">                   .          .   447eab:                     NOPL                                                         <span class="unimportant">proc.go:4093</span>
</span>
<span class="line">   4094</span> <span class="livesrc">           .          .           		globrunqputbatch(&amp;globq) </span><span class="asm">                   .          .   447ebe:                     NOPL                                                         <span class="unimportant">proc.go:4094</span>
</span>
<span class="line">   4095</span> <span class="livesrc">           .          .           		unlock(&amp;sched.lock) </span><span class="asm">                   .          .   447f12:                     NOPL                                                         <span class="unimportant">proc.go:4095</span>
</span>
<span class="line">   4096</span> <span class="livesrc">           .          .           		startIdle(n) </span><span class="asm">                   .          .   447f25:                     MOVQ 0xb8e74(IP), CX                                         <span class="unimportant">proc.go:4096</span>
                   .          .   447f2c:                     MOVL 0x20(SP), AX                                            <span class="unimportant">proc.go:4096</span>
                   .          .   447f30:                     LEAQ 0xb8e69(IP), DX                                         <span class="unimportant">proc.go:4096</span>
                   .          .   447f37:                     CALL CX                                                      <span class="unimportant">proc.go:4096</span>
</span>
<span class="line">   4097</span> <span class="nop">           .          .           	} </span>
<span class="line">   4098</span> <span class="nop">           .          .            </span>
<span class="line">   4099</span> <span class="livesrc">           .          .           	if runqputbatch(pp, &amp;q); !q.empty() { </span><span class="asm">                   .          .   447f39:             MOVQ 0x70(SP), AX                                                    <span class="unimportant">proc.go:4099</span>
                   .          .   447f3e:             LEAQ 0x30(SP), BX                                                    <span class="unimportant">proc.go:4099</span>
                   .          .   447f43:             CALL runtime.runqputbatch(SB)                                        <span class="unimportant">proc.go:4099</span>
                                     ⋮
                   .          .   447f4e:             JE 0x447fc5                                                          <span class="unimportant">proc.go:4099</span>
</span>
<span class="line">   4100</span> <span class="livesrc">           .          .           		lock(&amp;sched.lock) </span><span class="asm">                   .          .   447f50:                     NOPL                                                         <span class="unimportant">proc.go:4100</span>
</span>
<span class="line">   4101</span> <span class="livesrc">           .          .           		globrunqputbatch(&amp;q) </span><span class="asm">                   .          .   447f63:                     NOPL                                                         <span class="unimportant">proc.go:4101</span>
</span>
<span class="line">   4102</span> <span class="livesrc">           .          .           		unlock(&amp;sched.lock) </span><span class="asm">                   .          .   447fb7:                     NOPL                                                         <span class="unimportant">proc.go:4102</span>
</span>
<span class="line">   4103</span> <span class="nop">           .          .           	} </span>
<span class="line">   4104</span> <span class="nop">           .          .            </span>
<span class="line">   4105</span> <span class="nop">           .          .           	// Some P's might have become idle after we loaded `sched.npidle` </span>
<span class="line">   4106</span> <span class="nop">           .          .           	// but before any goroutines were added to the queue, which could </span>
<span class="line">   4107</span> <span class="nop">           .          .           	// lead to idle P's when there is work available in the global queue. </span>
<span class="line">   4108</span> <span class="nop">           .          .           	// That could potentially last until other goroutines become ready </span>
<span class="line">   4109</span> <span class="nop">           .          .           	// to run. That said, we need to find a way to hedge </span>
<span class="line">   4110</span> <span class="nop">           .          .           	// </span>
<span class="line">   4111</span> <span class="nop">           .          .           	// Calling wakep() here is the best bet, it will do nothing in the </span>
<span class="line">   4112</span> <span class="nop">           .          .           	// common case (no racing on `sched.npidle`), while it could wake one </span>
<span class="line">   4113</span> <span class="nop">           .          .           	// more P to execute G's, which might end up with &gt;1 P's: the first one </span>
<span class="line">   4114</span> <span class="nop">           .          .           	// wakes another P and so forth until there is no more work, but this </span>
<span class="line">   4115</span> <span class="nop">           .          .           	// ought to be an extremely rare case. </span>
<span class="line">   4116</span> <span class="nop">           .          .           	// </span>
<span class="line">   4117</span> <span class="nop">           .          .           	// Also see "Worker thread parking/unparking" comment at the top of the file for details. </span>
<span class="line">   4118</span> <span class="livesrc">           .          .           	wakep() </span><span class="asm">                   .          .   447fc5:             CALL runtime.wakep(SB)                                               <span class="unimportant">proc.go:4118</span>
</span>
<span class="line">   4119</span> <span class="livesrc">           .          .           } </span><span class="asm">                   .          .   447fca:     ADDQ $0x78, SP                                                               <span class="unimportant">proc.go:4119</span>
                   .          .   447fce:     POPQ BP                                                                      <span class="unimportant">proc.go:4119</span>
                   .          .   447fcf:     RET                                                                          <span class="unimportant">proc.go:4119</span>
</span>
<span class="line">   4120</span> <span class="nop">           .          .            </span>
</pre>
<h2>runtime.schedule</h2><p class="filename">/home/mikhliuk/go/go1.25.4/src/runtime/proc.go</p>
<pre onclick="pprof_toggle_asm(event)">  Total:           0     1.50MB (flat, cum)  0.26%
<span class="line">   4122</span> <span class="nop">           .          .           // Never returns. </span>
<span class="line">   4123</span> <span class="livesrc">           .          .           func schedule() { </span><span class="asm">                   .          .   448000:     CMPQ SP, 0x10(R14)                                                           <span class="unimportant">proc.go:4123</span>
                   .          .   448004:     JBE 0x44824a                                                                 <span class="unimportant">proc.go:4123</span>
                   .          .   44800a:     PUSHQ BP                                                                     <span class="unimportant">proc.go:4123</span>
                   .          .   44800b:     MOVQ SP, BP                                                                  <span class="unimportant">proc.go:4123</span>
                   .          .   44800e:     SUBQ $0x28, SP                                                               <span class="unimportant">proc.go:4123</span>
                                     ⋮
                   .          .   44824a:     CALL runtime.morestack_noctxt.abi0(SB)                                       <span class="unimportant">proc.go:4123</span>
                   .          .   44824f:     JMP runtime.schedule(SB)                                                     <span class="unimportant">proc.go:4123</span>
</span>
<span class="line">   4124</span> <span class="livesrc">           .          .           	mp := getg().m </span><span class="asm">                   .          .   448012:             MOVQ 0x30(R14), CX                                                   <span class="unimportant">proc.go:4124</span>
                                     ⋮
                   .          .   448026:             MOVQ CX, 0x18(SP)                                                    <span class="unimportant">proc.go:4124</span>
</span>
<span class="line">   4125</span> <span class="nop">           .          .            </span>
<span class="line">   4126</span> <span class="livesrc">           .          .           	if mp.locks != 0 { </span><span class="asm">                   .          .   448016:             CMPL 0x100(CX), $0x0                                                 <span class="unimportant">proc.go:4126</span>
                   .          .   44801d:             NOPL 0(AX)                                                           <span class="unimportant">proc.go:4126</span>
                   .          .   448020:             JNE 0x448238                                                         <span class="unimportant">proc.go:4126</span>
</span>
<span class="line">   4127</span> <span class="livesrc">           .          .           		throw("schedule: holding locks") </span><span class="asm">                   .          .   448238:                     LEAQ 0xb1969(IP), AX                                         <span class="unimportant">proc.go:4127</span>
                   .          .   44823f:                     MOVL $0x17, BX                                               <span class="unimportant">proc.go:4127</span>
                   .          .   448244:                     CALL runtime.throw(SB)                                       <span class="unimportant">proc.go:4127</span>
                   .          .   448249:                     NOPL                                                         <span class="unimportant">proc.go:4127</span>
</span>
<span class="line">   4128</span> <span class="nop">           .          .           	} </span>
<span class="line">   4129</span> <span class="nop">           .          .            </span>
<span class="line">   4130</span> <span class="livesrc">           .          .           	if mp.lockedg != 0 { </span><span class="asm">                   .          .   44802b:             CMPQ 0x168(CX), $0x0                                                 <span class="unimportant">proc.go:4130</span>
                   .          .   448033:             JE 0x448052                                                          <span class="unimportant">proc.go:4130</span>
</span>
<span class="line">   4131</span> <span class="livesrc">           .          .           		stoplockedm() </span><span class="asm">                   .          .   448035:                     CALL runtime.stoplockedm(SB)                                 <span class="unimportant">proc.go:4131</span>
</span>
<span class="line">   4132</span> <span class="livesrc">           .          .           		execute(mp.lockedg.ptr(), false) // Never returns. </span><span class="asm">                   .          .   44803a:                     MOVQ 0x18(SP), AX                                            <span class="unimportant">proc.go:4132</span>
                   .          .   44803f:                     MOVQ 0x168(AX), AX                                           <span class="unimportant">proc.go:4132</span>
                   .          .   448046:                     XORL BX, BX                                                  <span class="unimportant">proc.go:4132</span>
                   .          .   448048:                     CALL runtime.execute(SB)                                     <span class="unimportant">proc.go:4132</span>
</span>
<span class="line">   4133</span> <span class="nop">           .          .           	} </span>
<span class="line">   4134</span> <span class="nop">           .          .            </span>
<span class="line">   4135</span> <span class="nop">           .          .           	// We should not schedule away from a g that is executing a cgo call, </span>
<span class="line">   4136</span> <span class="nop">           .          .           	// since the cgo call is using the m's g0 stack. </span>
<span class="line">   4137</span> <span class="livesrc">           .          .           	if mp.incgo { </span><span class="asm">                   .          .   44804d:             MOVQ 0x18(SP), CX                                                    <span class="unimportant">proc.go:4137</span>
                   .          .   448052:             CMPB 0x110(CX), $0x0                                                 <span class="unimportant">proc.go:4137</span>
                   .          .   448059:             JE 0x44806f                                                          <span class="unimportant">proc.go:4137</span>
                   .          .   44805b:             NOPL 0(AX)(AX*1)                                                     <span class="unimportant">proc.go:4137</span>
                   .          .   448060:             JMP 0x448227                                                         <span class="unimportant">proc.go:4137</span>
</span>
<span class="line">   4138</span> <span class="livesrc">           .          .           		throw("schedule: in cgo") </span><span class="asm">                   .          .   448227:                     LEAQ 0xafdba(IP), AX                                         <span class="unimportant">proc.go:4138</span>
                   .          .   44822e:                     MOVL $0x10, BX                                               <span class="unimportant">proc.go:4138</span>
                   .          .   448233:                     CALL runtime.throw(SB)                                       <span class="unimportant">proc.go:4138</span>
</span>
<span class="line">   4139</span> <span class="nop">           .          .           	} </span>
<span class="line">   4140</span> <span class="nop">           .          .            </span>
<span class="line">   4141</span> <span class="nop">           .          .           top: </span>
<span class="line">   4142</span> <span class="livesrc">           .          .           	pp := mp.p.ptr() </span><span class="asm">                   .          .   44806a:             MOVQ 0x18(SP), CX                                                    <span class="unimportant">proc.go:4142</span>
                   .          .   44806f:             MOVQ 0xc8(CX), DX                                                    <span class="unimportant">proc.go:4142</span>
                                     ⋮
                   .          .   44810a:             MOVQ 0x18(SP), CX                                                    <span class="unimportant">proc.go:4142</span>
                                     ⋮
                   .          .   44812e:             MOVQ 0x18(SP), CX                                                    <span class="unimportant">proc.go:4142</span>
                                     ⋮
                   .          .   4481bf:             MOVQ 0x18(SP), CX                                                    <span class="unimportant">proc.go:4142</span>
                                     ⋮
                   .          .   4481d7:             MOVQ 0x18(SP), CX                                                    <span class="unimportant">proc.go:4142</span>
                                     ⋮
                   .          .   4481ea:             MOVQ 0x18(SP), CX                                                    <span class="unimportant">proc.go:4142</span>
</span>
<span class="line">   4143</span> <span class="livesrc">           .          .           	pp.preempt = false </span><span class="asm">                   .          .   448076:             TESTB AL, 0(DX)                                                      <span class="unimportant">proc.go:4143</span>
                   .          .   448078:             MOVB $0x0, 0x2518(DX)                                                <span class="unimportant">proc.go:4143</span>
</span>
<span class="line">   4144</span> <span class="nop">           .          .            </span>
<span class="line">   4145</span> <span class="nop">           .          .           	// Safety check: if we are spinning, the run queue should be empty. </span>
<span class="line">   4146</span> <span class="nop">           .          .           	// Check this before calling checkTimers, as that might call </span>
<span class="line">   4147</span> <span class="nop">           .          .           	// goready to put a ready goroutine on the local run queue. </span>
<span class="line">   4148</span> <span class="livesrc">           .          .           	if mp.spinning &amp;&amp; (pp.runnext != 0 || pp.runqhead != pp.runqtail) { </span><span class="asm">                   .          .   44807f:             CMPB 0x10c(CX), $0x0                                                 <span class="unimportant">proc.go:4148</span>
                   .          .   448086:             JE 0x4480ac                                                          <span class="unimportant">proc.go:4148</span>
                   .          .   448088:             CMPQ 0x990(DX), $0x0                                                 <span class="unimportant">proc.go:4148</span>
                   .          .   448090:             JNE 0x448216                                                         <span class="unimportant">proc.go:4148</span>
                   .          .   448096:             MOVL 0x188(DX), SI                                                   <span class="unimportant">proc.go:4148</span>
                   .          .   44809c:             NOPL 0(AX)                                                           <span class="unimportant">proc.go:4148</span>
                   .          .   4480a0:             CMPL 0x18c(DX), SI                                                   <span class="unimportant">proc.go:4148</span>
                   .          .   4480a6:             JNE 0x448216                                                         <span class="unimportant">proc.go:4148</span>
</span>
<span class="line">   4149</span> <span class="livesrc">           .          .           		throw("schedule: spinning with local work") </span><span class="asm">                   .          .   448216:                     LEAQ 0xb458e(IP), AX                                         <span class="unimportant">proc.go:4149</span>
                   .          .   44821d:                     MOVL $0x22, BX                                               <span class="unimportant">proc.go:4149</span>
                   .          .   448222:                     CALL runtime.throw(SB)                                       <span class="unimportant">proc.go:4149</span>
</span>
<span class="line">   4150</span> <span class="nop">           .          .           	} </span>
<span class="line">   4151</span> <span class="nop">           .          .            </span>
<span class="line">   4152</span> <span class="livesrc">           .          .           	gp, inheritTime, tryWakeP := findRunnable() // blocks until work is available </span><span class="asm">                   .          .   4480ac:             CALL runtime.findRunnable(SB)                                        <span class="unimportant">proc.go:4152</span>
                   .          .   4480b1:             MOVQ AX, 0x20(SP)                                                    <span class="unimportant">proc.go:4152</span>
                   .          .   4480b6:             MOVB CL, 0x16(SP)                                                    <span class="unimportant">proc.go:4152</span>
                   .          .   4480ba:             MOVB BL, 0x17(SP)                                                    <span class="unimportant">proc.go:4152</span>
                                     ⋮
                   .          .   4481dc:             MOVZX 0x16(SP), DX                                                   <span class="unimportant">proc.go:4152</span>
                   .          .   4481e1:             TESTL DL, DL                                                         <span class="unimportant">proc.go:4152</span>
</span>
<span class="line">   4153</span> <span class="nop">           .          .            </span>
<span class="line">   4154</span> <span class="nop">           .          .           	// findRunnable may have collected an allp snapshot. The snapshot is </span>
<span class="line">   4155</span> <span class="nop">           .          .           	// only required within findRunnable. Clear it to all GC to collect the </span>
<span class="line">   4156</span> <span class="nop">           .          .           	// slice. </span>
<span class="line">   4157</span> <span class="livesrc">           .          .           	mp.clearAllpSnapshot() </span><span class="asm">                   .          .   4480be:             MOVQ 0x18(SP), AX                                                    <span class="unimportant">proc.go:4157</span>
                   .          .   4480c3:             CALL runtime.(*m).clearAllpSnapshot(SB)                              <span class="unimportant">proc.go:4157</span>
</span>
<span class="line">   4158</span> <span class="nop">           .          .            </span>
<span class="line">   4159</span> <span class="livesrc">           .          .           	if debug.dontfreezetheworld &gt; 0 &amp;&amp; freezing.Load() { </span><span class="asm">                   .          .   4480c8:             CMPL runtime.debug+20(SB), $0x0                                      <span class="unimportant">proc.go:4159</span>
                   .          .   4480cf:             JLE 0x4480f7                                                         <span class="unimportant">proc.go:4159</span>
                                     ⋮
                   .          .   4480d9:             JE 0x4480f7                                                          <span class="unimportant">proc.go:4159</span>
</span>
<span class="line">   4160</span> <span class="nop">           .          .           		// See comment in freezetheworld. We don't want to perturb </span>
<span class="line">   4161</span> <span class="nop">           .          .           		// scheduler state, so we didn't gcstopm in findRunnable, but </span>
<span class="line">   4162</span> <span class="nop">           .          .           		// also don't want to allow new goroutines to run. </span>
<span class="line">   4163</span> <span class="nop">           .          .           		// </span>
<span class="line">   4164</span> <span class="nop">           .          .           		// Deadlock here rather than in the findRunnable loop so if </span>
<span class="line">   4165</span> <span class="nop">           .          .           		// findRunnable is stuck in a loop we don't perturb that </span>
<span class="line">   4166</span> <span class="nop">           .          .           		// either. </span>
<span class="line">   4167</span> <span class="livesrc">           .          .           		lock(&amp;deadlock) </span><span class="asm">                   .          .   4480db:                     NOPL                                                         <span class="unimportant">proc.go:4167</span>
</span>
<span class="line">   4168</span> <span class="livesrc">           .          .           		lock(&amp;deadlock) </span><span class="asm">                   .          .   4480e9:                     NOPL                                                         <span class="unimportant">proc.go:4168</span>
</span>
<span class="line">   4169</span> <span class="nop">           .          .           	} </span>
<span class="line">   4170</span> <span class="nop">           .          .            </span>
<span class="line">   4171</span> <span class="nop">           .          .           	// This thread is going to run a goroutine and is not spinning anymore, </span>
<span class="line">   4172</span> <span class="nop">           .          .           	// so if it was marked as spinning we need to reset it now and potentially </span>
<span class="line">   4173</span> <span class="nop">           .          .           	// start a new spinning M. </span>
<span class="line">   4174</span> <span class="livesrc">           .          .           	if mp.spinning { </span><span class="asm">                   .          .   4480f7:             MOVQ 0x18(SP), CX                                                    <span class="unimportant">proc.go:4174</span>
                   .          .   4480fc:             CMPB 0x10c(CX), $0x0                                                 <span class="unimportant">proc.go:4174</span>
                   .          .   448103:             JE 0x44810f                                                          <span class="unimportant">proc.go:4174</span>
</span>
<span class="line">   4175</span> <span class="livesrc">           .     1.50MB           		resetspinning() </span><span class="asm">                   .     1.50MB   448105:                     CALL runtime.resetspinning(SB)                               <span class="unimportant">proc.go:4175</span>
</span>
<span class="line">   4176</span> <span class="nop">           .          .           	} </span>
<span class="line">   4177</span> <span class="nop">           .          .            </span>
<span class="line">   4178</span> <span class="livesrc">           .          .           	if sched.disable.user &amp;&amp; !schedEnabled(gp) { </span><span class="asm">                   .          .   44810f:             CMPB runtime.sched+136(SB), $0x0                                     <span class="unimportant">proc.go:4178</span>
                   .          .   448116:             JNE 0x44811c                                                         <span class="unimportant">proc.go:4178</span>
                   .          .   448118:             XORL AX, AX                                                          <span class="unimportant">proc.go:4178</span>
                   .          .   44811a:             JMP 0x448133                                                         <span class="unimportant">proc.go:4178</span>
                                     ⋮
                   .          .   44812b:             XORL $0x1, AX                                                        <span class="unimportant">proc.go:4178</span>
                                     ⋮
                   .          .   448133:             TESTL AL, AL                                                         <span class="unimportant">proc.go:4178</span>
                   .          .   448135:             JE 0x4481dc                                                          <span class="unimportant">proc.go:4178</span>
</span>
<span class="line">   4179</span> <span class="nop">           .          .           		// Scheduling of this goroutine is disabled. Put it on </span>
<span class="line">   4180</span> <span class="nop">           .          .           		// the list of pending runnable goroutines for when we </span>
<span class="line">   4181</span> <span class="nop">           .          .           		// re-enable user scheduling and look again. </span>
<span class="line">   4182</span> <span class="livesrc">           .          .           		lock(&amp;sched.lock) </span><span class="asm">                   .          .   44813b:                     NOPL                                                         <span class="unimportant">proc.go:4182</span>
</span>
<span class="line">   4183</span> <span class="livesrc">           .          .           		if schedEnabled(gp) { </span><span class="asm">                   .          .   448157:                     JMP 0x448168                                                 <span class="unimportant">proc.go:4183</span>
                                     ⋮
                   .          .   448168:                     TESTL AL, AL                                                 <span class="unimportant">proc.go:4183</span>
                   .          .   44816a:                     JNE 0x4481c9                                                 <span class="unimportant">proc.go:4183</span>
</span>
<span class="line">   4184</span> <span class="nop">           .          .           			// Something re-enabled scheduling while we </span>
<span class="line">   4185</span> <span class="nop">           .          .           			// were acquiring the lock. </span>
<span class="line">   4186</span> <span class="livesrc">           .          .           			unlock(&amp;sched.lock) </span><span class="asm">                   .          .   4481c9:                             NOPL                                                 <span class="unimportant">proc.go:4186</span>
</span>
<span class="line">   4187</span> <span class="nop">           .          .           		} else { </span>
<span class="line">   4188</span> <span class="livesrc">           .          .           			sched.disable.runnable.pushBack(gp) </span><span class="asm">                   .          .   44816c:                             NOPL                                                 <span class="unimportant">proc.go:4188</span>
</span>
<span class="line">   4189</span> <span class="livesrc">           .          .           			unlock(&amp;sched.lock) </span><span class="asm">                   .          .   4481b1:                             NOPL                                                 <span class="unimportant">proc.go:4189</span>
</span>
<span class="line">   4190</span> <span class="livesrc">           .          .           			goto top </span><span class="asm">                   .          .   4481c4:                             JMP 0x44806f                                         <span class="unimportant">proc.go:4190</span>
</span>
<span class="line">   4191</span> <span class="nop">           .          .           		} </span>
<span class="line">   4192</span> <span class="nop">           .          .           	} </span>
<span class="line">   4193</span> <span class="nop">           .          .            </span>
<span class="line">   4194</span> <span class="nop">           .          .           	// If about to schedule a not-normal goroutine (a GCworker or tracereader), </span>
<span class="line">   4195</span> <span class="nop">           .          .           	// wake a P if there is one. </span>
<span class="line">   4196</span> <span class="livesrc">           .          .           	if tryWakeP { </span><span class="asm">                   .          .   4481e3:             JE 0x4481ef                                                          <span class="unimportant">proc.go:4196</span>
</span>
<span class="line">   4197</span> <span class="livesrc">           .          .           		wakep() </span><span class="asm">                   .          .   4481e5:                     CALL runtime.wakep(SB)                                       <span class="unimportant">proc.go:4197</span>
</span>
<span class="line">   4198</span> <span class="nop">           .          .           	} </span>
<span class="line">   4199</span> <span class="livesrc">           .          .           	if gp.lockedm != 0 { </span><span class="asm">                   .          .   4481ef:             MOVQ 0x20(SP), AX                                                    <span class="unimportant">proc.go:4199</span>
                   .          .   4481f4:             CMPQ 0xd0(AX), $0x0                                                  <span class="unimportant">proc.go:4199</span>
                   .          .   4481fc:             NOPL 0(AX)                                                           <span class="unimportant">proc.go:4199</span>
                   .          .   448200:             JNE 0x448065                                                         <span class="unimportant">proc.go:4199</span>
</span>
<span class="line">   4200</span> <span class="nop">           .          .           		// Hands off own p to the locked m, </span>
<span class="line">   4201</span> <span class="nop">           .          .           		// then blocks waiting for a new p. </span>
<span class="line">   4202</span> <span class="livesrc">           .          .           		startlockedm(gp) </span><span class="asm">                   .          .   448065:                     CALL runtime.startlockedm(SB)                                <span class="unimportant">proc.go:4202</span>
</span>
<span class="line">   4203</span> <span class="nop">           .          .           		goto top </span>
<span class="line">   4204</span> <span class="nop">           .          .           	} </span>
<span class="line">   4205</span> <span class="nop">           .          .            </span>
<span class="line">   4206</span> <span class="livesrc">           .          .           	execute(gp, inheritTime) </span><span class="asm">                   .          .   448206:             MOVZX 0x17(SP), BX                                                   <span class="unimportant">proc.go:4206</span>
                   .          .   44820b:             CALL runtime.execute(SB)                                             <span class="unimportant">proc.go:4206</span>
</span>
<span class="line">   4207</span> <span class="livesrc">           .          .           } </span><span class="asm">                   .          .   448210:     ADDQ $0x28, SP                                                               <span class="unimportant">proc.go:4207</span>
                   .          .   448214:     POPQ BP                                                                      <span class="unimportant">proc.go:4207</span>
                   .          .   448215:     RET                                                                          <span class="unimportant">proc.go:4207</span>
</span>
<span class="line">   4208</span> <span class="nop">           .          .            </span>
<span class="line">   4209</span> <span class="nop">           .          .           // dropg removes the association between m and the current goroutine m-&gt;curg (gp for short). </span>
<span class="line">   4210</span> <span class="nop">           .          .           // Typically a caller sets gp's status away from Grunning and then </span>
<span class="line">   4211</span> <span class="nop">           .          .           // immediately calls dropg to finish the job. The caller is also responsible </span>
<span class="line">   4212</span> <span class="nop">           .          .           // for arranging that gp will be restarted using ready at an </span>
</pre>
<h2>runtime.sysmon</h2><p class="filename">/home/mikhliuk/go/go1.25.4/src/runtime/proc.go</p>
<pre onclick="pprof_toggle_asm(event)">  Total:           0      513kB (flat, cum) 0.087%
<span class="line">   6344</span> <span class="nop">           .          .           			if next := timeSleepUntil(); next &lt; now { </span>
<span class="line">   6345</span> <span class="nop">           .          .           				startm(nil, false, false) </span>
<span class="line">   6346</span> <span class="nop">           .          .           			} </span>
<span class="line">   6347</span> <span class="nop">           .          .           		} </span>
<span class="line">   6348</span> <span class="nop">           .          .           		// Check if we need to update GOMAXPROCS at most once per second. </span>
<span class="line">   6349</span> <span class="livesrc">           .          .           		if debug.updatemaxprocs != 0 &amp;&amp; lastgomaxprocs+1e9 &lt;= now { </span><span class="asm">                   .          .   44d490:                     MOVQ 0x68(SP), AX                                            <span class="unimportant">proc.go:6349</span>
                   .          .   44d495:                     CMPL runtime.debug+72(SB), $0x0                              <span class="unimportant">proc.go:6349</span>
                   .          .   44d49c:                     JE 0x44d4be                                                  <span class="unimportant">proc.go:6349</span>
                   .          .   44d49e:                     MOVQ 0x58(SP), CX                                            <span class="unimportant">proc.go:6349</span>
                   .          .   44d4a3:                     LEAQ 0x3b9aca00(CX), DX                                      <span class="unimportant">proc.go:6349</span>
                   .          .   44d4aa:                     CMPQ AX, DX                                                  <span class="unimportant">proc.go:6349</span>
                   .          .   44d4ad:                     JL 0x44d4c3                                                  <span class="unimportant">proc.go:6349</span>
                                     ⋮
                   .          .   44d4b9:                     MOVQ AX, CX                                                  <span class="unimportant">proc.go:6349</span>
                                     ⋮
                   .          .   44d4be:                     MOVQ 0x58(SP), CX                                            <span class="unimportant">proc.go:6349</span>
                   .          .   44d4c3:                     MOVQ CX, 0x58(SP)                                            <span class="unimportant">proc.go:6349</span>
</span>
<span class="line">   6350</span> <span class="livesrc">           .          .           			sysmonUpdateGOMAXPROCS() </span><span class="asm">                   .          .   44d4af:                             CALL runtime.sysmonUpdateGOMAXPROCS(SB)              <span class="unimportant">proc.go:6350</span>
</span>
<span class="line">   6351</span> <span class="livesrc">           .          .           			lastgomaxprocs = now </span><span class="asm">                   .          .   44d4bc:                             JMP 0x44d4c3                                         <span class="unimportant">proc.go:6351</span>
</span>
<span class="line">   6352</span> <span class="nop">           .          .           		} </span>
<span class="line">   6353</span> <span class="livesrc">           .          .           		if scavenger.sysmonWake.Load() != 0 { </span><span class="asm">                   .          .   44d4ce:                     TESTL DX, DX                                                 <span class="unimportant">proc.go:6353</span>
                   .          .   44d4d0:                     JE 0x44d4e3                                                  <span class="unimportant">proc.go:6353</span>
</span>
<span class="line">   6354</span> <span class="nop">           .          .           			// Kick the scavenger awake if someone requested it. </span>
<span class="line">   6355</span> <span class="livesrc">           .      513kB           			scavenger.wake() </span><span class="asm">                   .          .   44d4d2:                             LEAQ runtime.scavenger(SB), AX                       <span class="unimportant">proc.go:6355</span>
                   .      513kB   44d4d9:                             CALL runtime.(*scavengerState).wake(SB)              <span class="unimportant">proc.go:6355</span>
</span>
<span class="line">   6356</span> <span class="nop">           .          .           		} </span>
<span class="line">   6357</span> <span class="nop">           .          .           		// retake P's blocked in syscalls </span>
<span class="line">   6358</span> <span class="nop">           .          .           		// and preempt long running G's </span>
<span class="line">   6359</span> <span class="livesrc">           .          .           		if retake(now) != 0 { </span><span class="asm">                   .          .   44d4b4:                     MOVQ 0x68(SP), AX                                            <span class="unimportant">proc.go:6359</span>
                                     ⋮
                   .          .   44d4de:                     MOVQ 0x68(SP), AX                                            <span class="unimportant">proc.go:6359</span>
                   .          .   44d4e3:                     CALL runtime.retake(SB)                                      <span class="unimportant">proc.go:6359</span>
                   .          .   44d4e8:                     MOVL AX, 0x24(SP)                                            <span class="unimportant">proc.go:6359</span>
                                     ⋮
                   .          .   44d505:                     MOVL 0x24(SP), DX                                            <span class="unimportant">proc.go:6359</span>
                   .          .   44d509:                     TESTL DX, DX                                                 <span class="unimportant">proc.go:6359</span>
                                     ⋮
                   .          .   44d51b:                     JE 0x44d58e                                                  <span class="unimportant">proc.go:6359</span>
</span>
<span class="line">   6360</span> <span class="nop">           .          .           			idle = 0 </span>
<span class="line">   6361</span> <span class="nop">           .          .           		} else { </span>
<span class="line">   6362</span> <span class="livesrc">           .          .           			idle++ </span><span class="asm">                   .          .   44d374:                             MOVQ 0x60(SP), CX                                    <span class="unimportant">proc.go:6362</span>
                   .          .   44d379:                             MOVQ CX, 0x60(SP)                                    <span class="unimportant">proc.go:6362</span>
                                     ⋮
                   .          .   44d393:                             MOVQ 0x60(SP), CX                                    <span class="unimportant">proc.go:6362</span>
                   .          .   44d398:                             MOVQ CX, 0x60(SP)                                    <span class="unimportant">proc.go:6362</span>
                                     ⋮
                   .          .   44d4fd:                             MOVQ 0x60(SP), CX                                    <span class="unimportant">proc.go:6362</span>
                   .          .   44d502:                             INCQ CX                                              <span class="unimportant">proc.go:6362</span>
</span>
<span class="line">   6363</span> <span class="nop">           .          .           		} </span>
<span class="line">   6364</span> <span class="nop">           .          .           		// check if we need to force a GC </span>
<span class="line">   6365</span> <span class="livesrc">           .          .           		if t := (gcTrigger{kind: gcTriggerTime, now: now}); t.test() &amp;&amp; forcegc.idle.Load() { </span><span class="asm">                   .          .   44d4ec:                     MOVL $0x1, AX                                                <span class="unimportant">proc.go:6365</span>
                   .          .   44d4f1:                     MOVQ 0x68(SP), BX                                            <span class="unimportant">proc.go:6365</span>
                   .          .   44d4f6:                     XORL CX, CX                                                  <span class="unimportant">proc.go:6365</span>
                   .          .   44d4f8:                     CALL runtime.gcTrigger.test(SB)                              <span class="unimportant">proc.go:6365</span>
                                     ⋮
                   .          .   44d519:                     TESTL AL, AL                                                 <span class="unimportant">proc.go:6365</span>
                                     ⋮
                   .          .   44d525:                     JE 0x44d58e                                                  <span class="unimportant">proc.go:6365</span>
</span>
<span class="line">   6366</span> <span class="livesrc">           .          .           			lock(&amp;forcegc.lock) </span><span class="asm">                   .          .   44d527:                             NOPL                                                 <span class="unimportant">proc.go:6366</span>
</span>
<span class="line">   6367</span> <span class="livesrc">           .          .           			forcegc.idle.Store(false) </span><span class="asm">                   .          .   44d535:                             NOPL                                                 <span class="unimportant">proc.go:6367</span>
</span>
<span class="line">   6368</span> <span class="livesrc">           .          .           			var list gList </span><span class="asm">                   .          .   44d542:                             MOVQ $0x0, 0x30(SP)                                  <span class="unimportant">proc.go:6368</span>
                   .          .   44d54b:                             MOVL $0x0, 0x38(SP)                                  <span class="unimportant">proc.go:6368</span>
</span>
<span class="line">   6369</span> <span class="livesrc">           .          .           			list.push(forcegc.g) </span><span class="asm">                   .          .   44d553:                             MOVQ runtime.forcegc+8(SB), CX                       <span class="unimportant">proc.go:6369</span>
</span>
<span class="line">   6370</span> <span class="livesrc">           .          .           			injectglist(&amp;list) </span><span class="asm">                   .          .   44d56f:                             LEAQ 0x30(SP), AX                                    <span class="unimportant">proc.go:6370</span>
                   .          .   44d574:                             CALL runtime.injectglist(SB)                         <span class="unimportant">proc.go:6370</span>
</span>
<span class="line">   6371</span> <span class="livesrc">           .          .           			unlock(&amp;forcegc.lock) </span><span class="asm">                   .          .   44d579:                             NOPL                                                 <span class="unimportant">proc.go:6371</span>
</span>
<span class="line">   6372</span> <span class="nop">           .          .           		} </span>
<span class="line">   6373</span> <span class="livesrc">           .          .           		if debug.schedtrace &gt; 0 &amp;&amp; lasttrace+int64(debug.schedtrace)*1000000 &lt;= now { </span><span class="asm">                   .          .   44d58e:                     MOVL runtime.debug+64(SB), BX                                <span class="unimportant">proc.go:6373</span>
                   .          .   44d594:                     TESTL BX, BX                                                 <span class="unimportant">proc.go:6373</span>
                   .          .   44d596:                     JLE 0x44d5d1                                                 <span class="unimportant">proc.go:6373</span>
                   .          .   44d598:                     MOVSXD BX, BX                                                <span class="unimportant">proc.go:6373</span>
                   .          .   44d59b:                     IMULQ $0xf4240, BX, BX                                       <span class="unimportant">proc.go:6373</span>
                   .          .   44d5a2:                     MOVQ 0x50(SP), SI                                            <span class="unimportant">proc.go:6373</span>
                   .          .   44d5a7:                     ADDQ SI, BX                                                  <span class="unimportant">proc.go:6373</span>
                   .          .   44d5aa:                     MOVQ 0x68(SP), DI                                            <span class="unimportant">proc.go:6373</span>
                   .          .   44d5af:                     CMPQ DI, BX                                                  <span class="unimportant">proc.go:6373</span>
                   .          .   44d5b2:                     JL 0x44d1a7                                                  <span class="unimportant">proc.go:6373</span>
                                     ⋮
                   .          .   44d5c7:                     MOVQ 0x68(SP), SI                                            <span class="unimportant">proc.go:6373</span>
                                     ⋮
                   .          .   44d5d1:                     MOVQ 0x50(SP), SI                                            <span class="unimportant">proc.go:6373</span>
                   .          .   44d5d6:                     JMP 0x44d1a7                                                 <span class="unimportant">proc.go:6373</span>
</span>
<span class="line">   6374</span> <span class="nop">           .          .           			lasttrace = now </span>
<span class="line">   6375</span> <span class="livesrc">           .          .           			schedtrace(debug.scheddetail &gt; 0) </span><span class="asm">                   .          .   44d5b8:                             CMPL runtime.debug+60(SB), $0x0                      <span class="unimportant">proc.go:6375</span>
                   .          .   44d5bf:                             SETG AL                                              <span class="unimportant">proc.go:6375</span>
                   .          .   44d5c2:                             CALL runtime.schedtrace(SB)                          <span class="unimportant">proc.go:6375</span>
                                     ⋮
                   .          .   44d5cc:                             JMP 0x44d1a7                                         <span class="unimportant">proc.go:6375</span>
</span>
<span class="line">   6376</span> <span class="nop">           .          .           		} </span>
<span class="line">   6377</span> <span class="nop">           .          .           		unlock(&amp;sched.sysmonlock) </span>
<span class="line">   6378</span> <span class="nop">           .          .           	} </span>
<span class="line">   6379</span> <span class="nop">           .          .           } </span>
<span class="line">   6380</span> <span class="nop">           .          .            </span>
</pre>
<h2>os.newFile</h2><p class="filename">/home/mikhliuk/go/go1.25.4/src/os/file_unix.go</p>
<pre onclick="pprof_toggle_asm(event)">  Total:       512kB      512kB (flat, cum) 0.086%
<span class="line">    138</span> <span class="nop">           .          .           ) </span>
<span class="line">    139</span> <span class="nop">           .          .            </span>
<span class="line">    140</span> <span class="nop">           .          .           // newFile is like NewFile, but if called from OpenFile or Pipe </span>
<span class="line">    141</span> <span class="nop">           .          .           // (as passed in the kind parameter) it tries to add the file to </span>
<span class="line">    142</span> <span class="nop">           .          .           // the runtime poller. </span>
<span class="line">    143</span> <span class="livesrc">           .          .           func newFile(fd int, name string, kind newFileKind, nonBlocking bool) *File { </span><span class="asm">                   .          .   4a16c0:     CMPQ SP, 0x10(R14)                                                           <span class="unimportant">file_unix.go:143</span>
                   .          .   4a16c4:     JBE 0x4a1881                                                                 <span class="unimportant">file_unix.go:143</span>
                   .          .   4a16ca:     PUSHQ BP                                                                     <span class="unimportant">file_unix.go:143</span>
                   .          .   4a16cb:     MOVQ SP, BP                                                                  <span class="unimportant">file_unix.go:143</span>
                   .          .   4a16ce:     SUBQ $0x30, SP                                                               <span class="unimportant">file_unix.go:143</span>
                                     ⋮
                   .          .   4a1881:     MOVQ AX, 0x8(SP)                                                             <span class="unimportant">file_unix.go:143</span>
                   .          .   4a1886:     MOVQ BX, 0x10(SP)                                                            <span class="unimportant">file_unix.go:143</span>
                   .          .   4a188b:     MOVQ CX, 0x18(SP)                                                            <span class="unimportant">file_unix.go:143</span>
                   .          .   4a1890:     MOVQ DI, 0x20(SP)                                                            <span class="unimportant">file_unix.go:143</span>
                   .          .   4a1895:     MOVB SI, 0x28(SP)                                                            <span class="unimportant">file_unix.go:143</span>
                   .          .   4a189a:     CALL runtime.morestack_noctxt.abi0(SB)                                       <span class="unimportant">file_unix.go:143</span>
                   .          .   4a189f:     MOVQ 0x8(SP), AX                                                             <span class="unimportant">file_unix.go:143</span>
                   .          .   4a18a4:     MOVQ 0x10(SP), BX                                                            <span class="unimportant">file_unix.go:143</span>
                   .          .   4a18a9:     MOVQ 0x18(SP), CX                                                            <span class="unimportant">file_unix.go:143</span>
                   .          .   4a18ae:     MOVQ 0x20(SP), DI                                                            <span class="unimportant">file_unix.go:143</span>
                   .          .   4a18b3:     MOVZX 0x28(SP), SI                                                           <span class="unimportant">file_unix.go:143</span>
                   .          .   4a18b8:     JMP os.newFile(SB)                                                           <span class="unimportant">file_unix.go:143</span>
</span>
<span class="line">    144</span> <span class="livesrc">       512kB      512kB           	f := &amp;File{&amp;file{ </span><span class="asm">                   .          .   4a1703:             LEAQ 0x3fb56(IP), AX                                                 <span class="unimportant">file_unix.go:144</span>
               512kB      512kB   4a170a:             CALL runtime.newobject(SB)                                           <span class="unimportant">file_unix.go:144</span>
                   .          .   4a170f:             MOVQ AX, 0x28(SP)                                                    <span class="unimportant">file_unix.go:144</span>
                   .          .   4a1714:             LEAQ 0x4a125(IP), AX                                                 <span class="unimportant">file_unix.go:144</span>
                   .          .   4a171b:             NOPL 0(AX)(AX*1)                                                     <span class="unimportant">file_unix.go:144</span>
                   .          .   4a1720:             CALL runtime.newobject(SB)                                           <span class="unimportant">file_unix.go:144</span>
                                     ⋮
                   .          .   4a1746:             MOVQ 0x28(SP), DX                                                    <span class="unimportant">file_unix.go:144</span>
                                     ⋮
                   .          .   4a1752:             MOVQ 0x28(SP), DX                                                    <span class="unimportant">file_unix.go:144</span>
                   .          .   4a1757:             MOVQ 0(DX), SI                                                       <span class="unimportant">file_unix.go:144</span>
                                     ⋮
                   .          .   4a1767:             MOVQ AX, 0x8(R11)                                                    <span class="unimportant">file_unix.go:144</span>
                   .          .   4a176b:             MOVQ SI, 0x10(R11)                                                   <span class="unimportant">file_unix.go:144</span>
                                     ⋮
                   .          .   4a177c:             MOVQ AX, 0(DX)                                                       <span class="unimportant">file_unix.go:144</span>
</span>
<span class="line">    145</span> <span class="nop">           .          .           		pfd: poll.FD{ </span>
<span class="line">    146</span> <span class="livesrc">           .          .           			Sysfd:         fd, </span><span class="asm">                   .          .   4a1725:                             MOVQ 0x40(SP), CX                                    <span class="unimportant">file_unix.go:146</span>
                   .          .   4a172a:                             MOVQ CX, 0x10(AX)                                    <span class="unimportant">file_unix.go:146</span>
</span>
<span class="line">    147</span> <span class="livesrc">           .          .           			IsStream:      true, </span><span class="asm">                   .          .   4a172e:                             MOVW $0x101, 0x30(AX)                                <span class="unimportant">file_unix.go:147</span>
</span>
<span class="line">    148</span> <span class="nop">           .          .           			ZeroReadIsEOF: true, </span>
<span class="line">    149</span> <span class="nop">           .          .           		}, </span>
<span class="line">    150</span> <span class="livesrc">           .          .           		name:        name, </span><span class="asm">                   .          .   4a1734:                     MOVQ 0x50(SP), DX                                            <span class="unimportant">file_unix.go:150</span>
                   .          .   4a1739:                     MOVQ DX, 0x40(AX)                                            <span class="unimportant">file_unix.go:150</span>
                   .          .   4a173d:                     CMPL runtime.writeBarrier(SB), $0x0                          <span class="unimportant">file_unix.go:150</span>
                   .          .   4a1744:                     JNE 0x4a1752                                                 <span class="unimportant">file_unix.go:150</span>
                                     ⋮
                   .          .   4a174b:                     MOVQ 0x48(SP), R8                                            <span class="unimportant">file_unix.go:150</span>
                   .          .   4a1750:                     JMP 0x4a176f                                                 <span class="unimportant">file_unix.go:150</span>
                                     ⋮
                   .          .   4a175a:                     CALL runtime.gcWriteBarrier3(SB)                             <span class="unimportant">file_unix.go:150</span>
                   .          .   4a175f:                     MOVQ 0x48(SP), R8                                            <span class="unimportant">file_unix.go:150</span>
                   .          .   4a1764:                     MOVQ R8, 0(R11)                                              <span class="unimportant">file_unix.go:150</span>
                                     ⋮
                   .          .   4a176f:                     MOVQ R8, 0x38(AX)                                            <span class="unimportant">file_unix.go:150</span>
</span>
<span class="line">    151</span> <span class="livesrc">           .          .           		stdoutOrErr: fd == 1 || fd == 2, </span><span class="asm">                   .          .   4a16d2:                     MOVQ AX, 0x40(SP)                                            <span class="unimportant">file_unix.go:151</span>
                   .          .   4a16d7:                     MOVQ DI, 0x58(SP)                                            <span class="unimportant">file_unix.go:151</span>
                   .          .   4a16dc:                     MOVB SI, 0x60(SP)                                            <span class="unimportant">file_unix.go:151</span>
                   .          .   4a16e1:                     MOVQ BX, 0x48(SP)                                            <span class="unimportant">file_unix.go:151</span>
                   .          .   4a16e6:                     MOVQ CX, 0x50(SP)                                            <span class="unimportant">file_unix.go:151</span>
                   .          .   4a16eb:                     CMPQ AX, $0x1                                                <span class="unimportant">file_unix.go:151</span>
                   .          .   4a16ef:                     JNE 0x4a16f8                                                 <span class="unimportant">file_unix.go:151</span>
                   .          .   4a16f1:                     MOVL $0x1, DX                                                <span class="unimportant">file_unix.go:151</span>
                   .          .   4a16f6:                     JMP 0x4a16ff                                                 <span class="unimportant">file_unix.go:151</span>
                   .          .   4a16f8:                     CMPQ AX, $0x2                                                <span class="unimportant">file_unix.go:151</span>
                   .          .   4a16fc:                     SETE DL                                                      <span class="unimportant">file_unix.go:151</span>
                   .          .   4a16ff:                     MOVB DL, 0x27(SP)                                            <span class="unimportant">file_unix.go:151</span>
                                     ⋮
                   .          .   4a1773:                     MOVZX 0x27(SP), SI                                           <span class="unimportant">file_unix.go:151</span>
                   .          .   4a1778:                     MOVB SI, 0x51(AX)                                            <span class="unimportant">file_unix.go:151</span>
                                     ⋮
                   .          .   4a17a6:                     MOVZX 0x60(SP), R8                                           <span class="unimportant">file_unix.go:151</span>
                   .          .   4a17ac:                     TESTL R8, R8                                                 <span class="unimportant">file_unix.go:151</span>
</span>
<span class="line">    152</span> <span class="nop">           .          .           	}} </span>
<span class="line">    153</span> <span class="nop">           .          .            </span>
<span class="line">    154</span> <span class="livesrc">           .          .           	pollable := kind == kindOpenFile || kind == kindPipe || kind == kindSock || nonBlocking </span><span class="asm">                   .          .   4a177f:             MOVQ 0x58(SP), SI                                                    <span class="unimportant">file_unix.go:154</span>
                   .          .   4a1784:             CMPQ SI, $0x1                                                        <span class="unimportant">file_unix.go:154</span>
                   .          .   4a1788:             JE 0x4a1796                                                          <span class="unimportant">file_unix.go:154</span>
                   .          .   4a178a:             CMPQ SI, $0x2                                                        <span class="unimportant">file_unix.go:154</span>
                   .          .   4a178e:             JE 0x4a1796                                                          <span class="unimportant">file_unix.go:154</span>
                   .          .   4a1790:             CMPQ SI, $0x3                                                        <span class="unimportant">file_unix.go:154</span>
                   .          .   4a1794:             JNE 0x4a179d                                                         <span class="unimportant">file_unix.go:154</span>
                   .          .   4a1796:             MOVL $0x1, BX                                                        <span class="unimportant">file_unix.go:154</span>
                   .          .   4a179b:             JMP 0x4a17a2                                                         <span class="unimportant">file_unix.go:154</span>
                   .          .   4a179d:             MOVZX 0x60(SP), BX                                                   <span class="unimportant">file_unix.go:154</span>
                   .          .   4a17a2:             TESTL BL, BL                                                         <span class="unimportant">file_unix.go:154</span>
</span>
<span class="line">    155</span> <span class="nop">           .          .            </span>
<span class="line">    156</span> <span class="nop">           .          .           	// Things like regular files and FIFOs in kqueue on *BSD/Darwin </span>
<span class="line">    157</span> <span class="nop">           .          .           	// may not work properly (or accurately according to its manual). </span>
<span class="line">    158</span> <span class="nop">           .          .           	// As a result, we should avoid adding those to the kqueue-based </span>
<span class="line">    159</span> <span class="nop">           .          .           	// netpoller. Check out #19093, #24164, and #66239 for more contexts. </span>
</pre>
<h2>os.openFileNolog</h2><p class="filename">/home/mikhliuk/go/go1.25.4/src/os/file_unix.go</p>
<pre onclick="pprof_toggle_asm(event)">  Total:           0      512kB (flat, cum) 0.086%
<span class="line">    240</span> <span class="nop">           .          .           // On Unix-like systems, it is "/dev/null"; on Windows, "NUL". </span>
<span class="line">    241</span> <span class="nop">           .          .           const DevNull = "/dev/null" </span>
<span class="line">    242</span> <span class="nop">           .          .            </span>
<span class="line">    243</span> <span class="nop">           .          .           // openFileNolog is the Unix implementation of OpenFile. </span>
<span class="line">    244</span> <span class="nop">           .          .           // Changes here should be reflected in openDirAt and openDirNolog, if relevant. </span>
<span class="line">    245</span> <span class="livesrc">           .          .           func openFileNolog(name string, flag int, perm FileMode) (*File, error) { </span><span class="asm">                   .          .   4a18c0:     CMPQ SP, 0x10(R14)                                                           <span class="unimportant">file_unix.go:245</span>
                   .          .   4a18c4:     JBE 0x4a1a75                                                                 <span class="unimportant">file_unix.go:245</span>
                   .          .   4a18ca:     PUSHQ BP                                                                     <span class="unimportant">file_unix.go:245</span>
                   .          .   4a18cb:     MOVQ SP, BP                                                                  <span class="unimportant">file_unix.go:245</span>
                   .          .   4a18ce:     SUBQ $0x48, SP                                                               <span class="unimportant">file_unix.go:245</span>
                                     ⋮
                   .          .   4a1a75:     MOVQ AX, 0x8(SP)                                                             <span class="unimportant">file_unix.go:245</span>
                   .          .   4a1a7a:     MOVQ BX, 0x10(SP)                                                            <span class="unimportant">file_unix.go:245</span>
                   .          .   4a1a7f:     MOVQ CX, 0x18(SP)                                                            <span class="unimportant">file_unix.go:245</span>
                   .          .   4a1a84:     MOVL DI, 0x20(SP)                                                            <span class="unimportant">file_unix.go:245</span>
                   .          .   4a1a88:     CALL runtime.morestack_noctxt.abi0(SB)                                       <span class="unimportant">file_unix.go:245</span>
                   .          .   4a1a8d:     MOVQ 0x8(SP), AX                                                             <span class="unimportant">file_unix.go:245</span>
                   .          .   4a1a92:     MOVQ 0x10(SP), BX                                                            <span class="unimportant">file_unix.go:245</span>
                   .          .   4a1a97:     MOVQ 0x18(SP), CX                                                            <span class="unimportant">file_unix.go:245</span>
                   .          .   4a1a9c:     MOVL 0x20(SP), DI                                                            <span class="unimportant">file_unix.go:245</span>
                   .          .   4a1aa0:     JMP os.openFileNolog(SB)                                                     <span class="unimportant">file_unix.go:245</span>
</span>
<span class="line">    246</span> <span class="nop">           .          .           	setSticky := false </span>
<span class="line">    247</span> <span class="nop">           .          .           	if !supportsCreateWithStickyBit &amp;&amp; flag&amp;O_CREATE != 0 &amp;&amp; perm&amp;ModeSticky != 0 { </span>
<span class="line">    248</span> <span class="nop">           .          .           		if _, err := Stat(name); IsNotExist(err) { </span>
<span class="line">    249</span> <span class="nop">           .          .           			setSticky = true </span>
<span class="line">    250</span> <span class="nop">           .          .           		} </span>
<span class="line">    251</span> <span class="nop">           .          .           	} </span>
<span class="line">    252</span> <span class="nop">           .          .            </span>
<span class="line">    253</span> <span class="nop">           .          .           	var ( </span>
<span class="line">    254</span> <span class="nop">           .          .           		r int </span>
<span class="line">    255</span> <span class="nop">           .          .           		s poll.SysFile </span>
<span class="line">    256</span> <span class="nop">           .          .           		e error </span>
<span class="line">    257</span> <span class="nop">           .          .           	) </span>
<span class="line">    258</span> <span class="nop">           .          .           	// We have to check EINTR here, per issues 11180 and 39237. </span>
<span class="line">    259</span> <span class="livesrc">           .          .           	ignoringEINTR(func() error { </span><span class="asm">                   .          .   4a18e5:             NOPL                                                                 <span class="unimportant">file_unix.go:259</span>
</span>
<span class="line">    260</span> <span class="livesrc">           .          .           		r, s, e = open(name, flag|syscall.O_CLOEXEC, syscallMode(perm)) </span><span class="asm">                   .          .   4a18e8:                     MOVQ 0x58(SP), AX                                            <span class="unimportant">file_unix.go:260</span>
                   .          .   4a18ed:                     MOVQ 0x68(SP), CX                                            <span class="unimportant">file_unix.go:260</span>
                   .          .   4a18f2:                     MOVQ 0x60(SP), BX                                            <span class="unimportant">file_unix.go:260</span>
                                     ⋮
                   .          .   4a18fb:                     MOVQ CX, DX                                                  <span class="unimportant">file_unix.go:260</span>
                   .          .   4a18fe:                     ORQ $0x80000, DX                                             <span class="unimportant">file_unix.go:260</span>
                                     ⋮
                   .          .   4a191e:                     CMOVNE SI, R8                                                <span class="unimportant">file_unix.go:260</span>
                                     ⋮
                   .          .   4a1932:                     CMOVNE R8, SI                                                <span class="unimportant">file_unix.go:260</span>
                                     ⋮
                   .          .   4a1945:                     CMOVNE SI, R8                                                <span class="unimportant">file_unix.go:260</span>
                   .          .   4a1949:                     MOVQ DX, CX                                                  <span class="unimportant">file_unix.go:260</span>
                   .          .   4a194c:                     MOVL R8, DI                                                  <span class="unimportant">file_unix.go:260</span>
                   .          .   4a194f:                     CALL os.open(SB)                                             <span class="unimportant">file_unix.go:260</span>
                   .          .   4a1954:                     MOVQ CX, 0x30(SP)                                            <span class="unimportant">file_unix.go:260</span>
                   .          .   4a1959:                     MOVQ BX, 0x40(SP)                                            <span class="unimportant">file_unix.go:260</span>
                   .          .   4a195e:                     MOVQ DI, 0x38(SP)                                            <span class="unimportant">file_unix.go:260</span>
                                     ⋮
                   .          .   4a196f:                     MOVQ AX, 0x28(SP)                                            <span class="unimportant">file_unix.go:260</span>
</span>
<span class="line">    261</span> <span class="nop">           .          .           		return e </span>
<span class="line">    262</span> <span class="nop">           .          .           	}) </span>
<span class="line">    263</span> <span class="livesrc">           .          .           	if e != nil { </span><span class="asm">                   .          .   4a1993:             MOVQ 0x30(SP), CX                                                    <span class="unimportant">file_unix.go:263</span>
                                     ⋮
                   .          .   4a19a2:             TESTQ CX, CX                                                         <span class="unimportant">file_unix.go:263</span>
                   .          .   4a19a5:             JE 0x4a1a1c                                                          <span class="unimportant">file_unix.go:263</span>
</span>
<span class="line">    264</span> <span class="livesrc">           .          .           		return nil, &amp;PathError{Op: "open", Path: name, Err: e} </span><span class="asm">                   .          .   4a199d:                     MOVQ 0x38(SP), DI                                            <span class="unimportant">file_unix.go:264</span>
                                     ⋮
                   .          .   4a19a7:                     LEAQ 0x454f2(IP), AX                                         <span class="unimportant">file_unix.go:264</span>
                   .          .   4a19ae:                     CALL runtime.newobject(SB)                                   <span class="unimportant">file_unix.go:264</span>
                   .          .   4a19b3:                     MOVQ $0x4, 0x8(AX)                                           <span class="unimportant">file_unix.go:264</span>
                   .          .   4a19bb:                     LEAQ 0x544f3(IP), CX                                         <span class="unimportant">file_unix.go:264</span>
                   .          .   4a19c2:                     MOVQ CX, 0(AX)                                               <span class="unimportant">file_unix.go:264</span>
                   .          .   4a19c5:                     MOVQ 0x60(SP), CX                                            <span class="unimportant">file_unix.go:264</span>
                   .          .   4a19ca:                     MOVQ CX, 0x18(AX)                                            <span class="unimportant">file_unix.go:264</span>
                   .          .   4a19ce:                     CMPL runtime.writeBarrier(SB), $0x0                          <span class="unimportant">file_unix.go:264</span>
                   .          .   4a19d5:                     JNE 0x4a19e3                                                 <span class="unimportant">file_unix.go:264</span>
                   .          .   4a19d7:                     MOVQ 0x58(SP), DX                                            <span class="unimportant">file_unix.go:264</span>
                   .          .   4a19dc:                     MOVQ 0x38(SP), SI                                            <span class="unimportant">file_unix.go:264</span>
                   .          .   4a19e1:                     JMP 0x4a19f9                                                 <span class="unimportant">file_unix.go:264</span>
                   .          .   4a19e3:                     CALL runtime.gcWriteBarrier2(SB)                             <span class="unimportant">file_unix.go:264</span>
                   .          .   4a19e8:                     MOVQ 0x58(SP), DX                                            <span class="unimportant">file_unix.go:264</span>
                   .          .   4a19ed:                     MOVQ DX, 0(R11)                                              <span class="unimportant">file_unix.go:264</span>
                   .          .   4a19f0:                     MOVQ 0x38(SP), SI                                            <span class="unimportant">file_unix.go:264</span>
                   .          .   4a19f5:                     MOVQ SI, 0x8(R11)                                            <span class="unimportant">file_unix.go:264</span>
                   .          .   4a19f9:                     MOVQ DX, 0x10(AX)                                            <span class="unimportant">file_unix.go:264</span>
                   .          .   4a19fd:                     MOVQ 0x30(SP), DX                                            <span class="unimportant">file_unix.go:264</span>
                   .          .   4a1a02:                     MOVQ DX, 0x20(AX)                                            <span class="unimportant">file_unix.go:264</span>
                   .          .   4a1a06:                     MOVQ SI, 0x28(AX)                                            <span class="unimportant">file_unix.go:264</span>
                   .          .   4a1a0a:                     LEAQ go:itab.*io/fs.PathError,error(SB), BX                  <span class="unimportant">file_unix.go:264</span>
                   .          .   4a1a11:                     MOVQ AX, CX                                                  <span class="unimportant">file_unix.go:264</span>
                   .          .   4a1a14:                     XORL AX, AX                                                  <span class="unimportant">file_unix.go:264</span>
                   .          .   4a1a16:                     ADDQ $0x48, SP                                               <span class="unimportant">file_unix.go:264</span>
                   .          .   4a1a1a:                     POPQ BP                                                      <span class="unimportant">file_unix.go:264</span>
                   .          .   4a1a1b:                     RET                                                          <span class="unimportant">file_unix.go:264</span>
</span>
<span class="line">    265</span> <span class="nop">           .          .           	} </span>
<span class="line">    266</span> <span class="nop">           .          .            </span>
<span class="line">    267</span> <span class="nop">           .          .           	// open(2) itself won't handle the sticky bit on *BSD and Solaris </span>
<span class="line">    268</span> <span class="nop">           .          .           	if setSticky { </span>
<span class="line">    269</span> <span class="nop">           .          .           		setStickyBit(name) </span>
<span class="line">    270</span> <span class="nop">           .          .           	} </span>
<span class="line">    271</span> <span class="nop">           .          .            </span>
<span class="line">    272</span> <span class="nop">           .          .           	// There's a race here with fork/exec, which we are </span>
<span class="line">    273</span> <span class="nop">           .          .           	// content to live with. See ../syscall/exec_unix.go. </span>
<span class="line">    274</span> <span class="nop">           .          .           	if !supportsCloseOnExec { </span>
<span class="line">    275</span> <span class="nop">           .          .           		syscall.CloseOnExec(r) </span>
<span class="line">    276</span> <span class="nop">           .          .           	} </span>
<span class="line">    277</span> <span class="nop">           .          .            </span>
<span class="line">    278</span> <span class="livesrc">           .      512kB           	f := newFile(r, name, kindOpenFile, unix.HasNonblockFlag(flag)) </span><span class="asm">                   .          .   4a198e:             MOVQ 0x28(SP), AX                                                    <span class="unimportant">file_unix.go:278</span>
                                     ⋮
                   .          .   4a1a29:             MOVQ 0x58(SP), BX                                                    <span class="unimportant">file_unix.go:278</span>
                   .          .   4a1a2e:             MOVQ 0x60(SP), CX                                                    <span class="unimportant">file_unix.go:278</span>
                   .          .   4a1a33:             MOVL $0x1, DI                                                        <span class="unimportant">file_unix.go:278</span>
                   .      512kB   4a1a38:             CALL os.newFile(SB)                                                  <span class="unimportant">file_unix.go:278</span>
</span>
<span class="line">    279</span> <span class="livesrc">           .          .           	f.pfd.SysFile = s </span><span class="asm">                   .          .   4a1998:             MOVQ 0x40(SP), BX                                                    <span class="unimportant">file_unix.go:279</span>
                                     ⋮
                   .          .   4a1a3d:             MOVQ 0(AX), DX                                                       <span class="unimportant">file_unix.go:279</span>
                   .          .   4a1a40:             TESTB AL, 0(DX)                                                      <span class="unimportant">file_unix.go:279</span>
                   .          .   4a1a42:             CMPL runtime.writeBarrier(SB), $0x0                                  <span class="unimportant">file_unix.go:279</span>
                   .          .   4a1a49:             JNE 0x4a1a52                                                         <span class="unimportant">file_unix.go:279</span>
                   .          .   4a1a4b:             MOVQ 0x40(SP), DI                                                    <span class="unimportant">file_unix.go:279</span>
                   .          .   4a1a50:             JMP 0x4a1a67                                                         <span class="unimportant">file_unix.go:279</span>
                   .          .   4a1a52:             MOVQ 0x18(DX), SI                                                    <span class="unimportant">file_unix.go:279</span>
                   .          .   4a1a56:             CALL runtime.gcWriteBarrier2(SB)                                     <span class="unimportant">file_unix.go:279</span>
                   .          .   4a1a5b:             MOVQ 0x40(SP), DI                                                    <span class="unimportant">file_unix.go:279</span>
                   .          .   4a1a60:             MOVQ DI, 0(R11)                                                      <span class="unimportant">file_unix.go:279</span>
                   .          .   4a1a63:             MOVQ SI, 0x8(R11)                                                    <span class="unimportant">file_unix.go:279</span>
                   .          .   4a1a67:             MOVQ DI, 0x18(DX)                                                    <span class="unimportant">file_unix.go:279</span>
</span>
<span class="line">    280</span> <span class="livesrc">           .          .           	return f, nil </span><span class="asm">                   .          .   4a1a6b:             XORL BX, BX                                                          <span class="unimportant">file_unix.go:280</span>
                   .          .   4a1a6d:             XORL CX, CX                                                          <span class="unimportant">file_unix.go:280</span>
                   .          .   4a1a6f:             ADDQ $0x48, SP                                                       <span class="unimportant">file_unix.go:280</span>
                   .          .   4a1a73:             POPQ BP                                                              <span class="unimportant">file_unix.go:280</span>
                   .          .   4a1a74:             RET                                                                  <span class="unimportant">file_unix.go:280</span>
</span>
<span class="line">    281</span> <span class="nop">           .          .           } </span>
<span class="line">    282</span> <span class="nop">           .          .            </span>
<span class="line">    283</span> <span class="nop">           .          .           func openDirNolog(name string) (*File, error) { </span>
<span class="line">    284</span> <span class="nop">           .          .           	var ( </span>
<span class="line">    285</span> <span class="nop">           .          .           		r int </span>
</pre>
<h2>runtime.mstart</h2><p class="filename">/home/mikhliuk/go/go1.25.4/src/runtime/asm_amd64.s</p>
<pre onclick="pprof_toggle_asm(event)">  Total:           0        2MB (flat, cum)  0.35%
<span class="line">    390</span> <span class="nop">           .          .           TEXT runtime·asminit(SB),NOSPLIT,$0-0 </span>
<span class="line">    391</span> <span class="nop">           .          .           	// No per-thread init. </span>
<span class="line">    392</span> <span class="nop">           .          .           	RET </span>
<span class="line">    393</span> <span class="nop">           .          .            </span>
<span class="line">    394</span> <span class="nop">           .          .           TEXT runtime·mstart(SB),NOSPLIT|TOPFRAME|NOFRAME,$0 </span>
<span class="line">    395</span> <span class="livesrc">           .        2MB           	CALL	runtime·mstart0(SB) </span><span class="asm" style="display: block;">                   .        2MB   474f40:             CALL runtime.mstart0.abi0(SB)                                        <span class="unimportant">asm_amd64.s:395</span>
</span>
<span class="line">    396</span> <span class="livesrc">           .          .           	RET // not reached </span><span class="asm">                   .          .   474f45:             RET                                                                  <span class="unimportant">asm_amd64.s:396</span>
</span>
<span class="line">    397</span> <span class="nop">           .          .            </span>
<span class="line">    398</span> <span class="nop">           .          .           /* </span>
<span class="line">    399</span> <span class="nop">           .          .            *  go-routine </span>
<span class="line">    400</span> <span class="nop">           .          .            */ </span>
<span class="line">    401</span> <span class="nop">           .          .            </span>
</pre>
<h2>sync.(*WaitGroup).Go.func1</h2><p class="filename">/home/mikhliuk/go/go1.25.4/src/sync/waitgroup.go</p>
<pre onclick="pprof_toggle_asm(event)">  Total:           0    64.15MB (flat, cum) 11.08%
<span class="line">    232</span> <span class="nop">           .          .           // "synchronizes before" the return of any Wait call that it unblocks. </span>
<span class="line">    233</span> <span class="nop">           .          .           // </span>
<span class="line">    234</span> <span class="nop">           .          .           // [the Go memory model]: https://go.dev/ref/mem </span>
<span class="line">    235</span> <span class="nop">           .          .           func (wg *WaitGroup) Go(f func()) { </span>
<span class="line">    236</span> <span class="nop">           .          .           	wg.Add(1) </span>
<span class="line">    237</span> <span class="livesrc">           .          .           	go func() { </span><span class="asm">                   .          .   482e40:             CMPQ SP, 0x10(R14)                                                   <span class="unimportant">waitgroup.go:237</span>
                   .          .   482e44:             JBE 0x482eab                                                         <span class="unimportant">waitgroup.go:237</span>
                   .          .   482e46:             PUSHQ BP                                                             <span class="unimportant">waitgroup.go:237</span>
                   .          .   482e47:             MOVQ SP, BP                                                          <span class="unimportant">waitgroup.go:237</span>
                   .          .   482e4a:             SUBQ $0x20, SP                                                       <span class="unimportant">waitgroup.go:237</span>
                   .          .   482e4e:             MOVQ X15, 0x18(SP)                                                   <span class="unimportant">waitgroup.go:237</span>
                   .          .   482e55:             MOVB $0x0, 0x7(SP)                                                   <span class="unimportant">waitgroup.go:237</span>
                   .          .   482e5a:             MOVQ 0x10(DX), AX                                                    <span class="unimportant">waitgroup.go:237</span>
                   .          .   482e5e:             MOVQ 0x8(DX), CX                                                     <span class="unimportant">waitgroup.go:237</span>
                                     ⋮
                   .          .   482eab:             CALL runtime.morestack.abi0(SB)                                      <span class="unimportant">waitgroup.go:237</span>
                   .          .   482eb0:             JMP sync.(*WaitGroup).Go.func1(SB)                                   <span class="unimportant">waitgroup.go:237</span>
</span>
<span class="line">    238</span> <span class="livesrc">           .          .           		defer wg.Done() </span><span class="asm">                   .          .   482e62:                     LEAQ sync.(*WaitGroup).Go.func1.deferwrap1(SB), BX           <span class="unimportant">waitgroup.go:238</span>
                   .          .   482e69:                     MOVQ BX, 0x8(SP)                                             <span class="unimportant">waitgroup.go:238</span>
                   .          .   482e6e:                     MOVQ CX, 0x10(SP)                                            <span class="unimportant">waitgroup.go:238</span>
                   .          .   482e73:                     LEAQ 0x8(SP), CX                                             <span class="unimportant">waitgroup.go:238</span>
                   .          .   482e78:                     MOVQ CX, 0x18(SP)                                            <span class="unimportant">waitgroup.go:238</span>
                   .          .   482e7d:                     MOVB $0x1, 0x7(SP)                                           <span class="unimportant">waitgroup.go:238</span>
</span>
<span class="line">    239</span> <span class="livesrc">           .    64.15MB           		f() </span><span class="asm">                   .          .   482e82:                     MOVQ 0(AX), CX                                               <span class="unimportant">waitgroup.go:239</span>
                   .          .   482e85:                     MOVQ AX, DX                                                  <span class="unimportant">waitgroup.go:239</span>
                   .    64.15MB   482e88:                     CALL CX                                                      <span class="unimportant">waitgroup.go:239</span>
</span>
<span class="line">    240</span> <span class="livesrc">           .          .           	}() </span><span class="asm">                   .          .   482e8a:             MOVB $0x0, 0x7(SP)                                                   <span class="unimportant">waitgroup.go:240</span>
                   .          .   482e8f:             MOVQ 0x18(SP), DX                                                    <span class="unimportant">waitgroup.go:240</span>
                   .          .   482e94:             MOVQ 0(DX), AX                                                       <span class="unimportant">waitgroup.go:240</span>
                   .          .   482e97:             CALL AX                                                              <span class="unimportant">waitgroup.go:240</span>
                   .          .   482e99:             ADDQ $0x20, SP                                                       <span class="unimportant">waitgroup.go:240</span>
                   .          .   482e9d:             POPQ BP                                                              <span class="unimportant">waitgroup.go:240</span>
                   .          .   482e9e:             RET                                                                  <span class="unimportant">waitgroup.go:240</span>
                   .          .   482e9f:             NOPL                                                                 <span class="unimportant">waitgroup.go:240</span>
                   .          .   482ea0:             CALL runtime.deferreturn(SB)                                         <span class="unimportant">waitgroup.go:240</span>
                   .          .   482ea5:             ADDQ $0x20, SP                                                       <span class="unimportant">waitgroup.go:240</span>
                   .          .   482ea9:             POPQ BP                                                              <span class="unimportant">waitgroup.go:240</span>
                   .          .   482eaa:             RET                                                                  <span class="unimportant">waitgroup.go:240</span>
</span>
<span class="line">    241</span> <span class="nop">           .          .           } </span>
</pre>
<h2>runtime.(*scavengerState).wake</h2><p class="filename">/home/mikhliuk/go/go1.25.4/src/runtime/mgcscavenge.go</p>
<pre onclick="pprof_toggle_asm(event)">  Total:           0      513kB (flat, cum) 0.087%
<span class="line">    431</span> <span class="nop">           .          .           } </span>
<span class="line">    432</span> <span class="nop">           .          .            </span>
<span class="line">    433</span> <span class="nop">           .          .           // wake immediately unparks the scavenger if necessary. </span>
<span class="line">    434</span> <span class="nop">           .          .           // </span>
<span class="line">    435</span> <span class="nop">           .          .           // Safe to run without a P. </span>
<span class="line">    436</span> <span class="livesrc">           .          .           func (s *scavengerState) wake() { </span><span class="asm">                   .          .   428600:     CMPQ SP, 0x10(R14)                                                           <span class="unimportant">mgcscavenge.go:436</span>
                   .          .   428604:     JBE 0x428677                                                                 <span class="unimportant">mgcscavenge.go:436</span>
                   .          .   428606:     PUSHQ BP                                                                     <span class="unimportant">mgcscavenge.go:436</span>
                   .          .   428607:     MOVQ SP, BP                                                                  <span class="unimportant">mgcscavenge.go:436</span>
                   .          .   42860a:     SUBQ $0x18, SP                                                               <span class="unimportant">mgcscavenge.go:436</span>
                                     ⋮
                   .          .   428677:     MOVQ AX, 0x8(SP)                                                             <span class="unimportant">mgcscavenge.go:436</span>
                   .          .   42867c:     NOPL 0(AX)                                                                   <span class="unimportant">mgcscavenge.go:436</span>
                   .          .   428680:     CALL runtime.morestack_noctxt.abi0(SB)                                       <span class="unimportant">mgcscavenge.go:436</span>
                   .          .   428685:     MOVQ 0x8(SP), AX                                                             <span class="unimportant">mgcscavenge.go:436</span>
                   .          .   42868a:     JMP runtime.(*scavengerState).wake(SB)                                       <span class="unimportant">mgcscavenge.go:436</span>
</span>
<span class="line">    437</span> <span class="livesrc">           .          .           	lock(&amp;s.lock) </span><span class="asm">                   .          .   428613:             TESTB AL, 0(AX)                                                      <span class="unimportant">mgcscavenge.go:437</span>
</span>
<span class="line">    438</span> <span class="livesrc">           .          .           	if s.parked { </span><span class="asm">                   .          .   42860e:             MOVQ AX, 0x28(SP)                                                    <span class="unimportant">mgcscavenge.go:438</span>
                                     ⋮
                   .          .   42861b:             MOVQ 0x28(SP), AX                                                    <span class="unimportant">mgcscavenge.go:438</span>
                   .          .   428620:             CMPB 0x1c(AX), $0x0                                                  <span class="unimportant">mgcscavenge.go:438</span>
                   .          .   428624:             JE 0x42866a                                                          <span class="unimportant">mgcscavenge.go:438</span>
</span>
<span class="line">    439</span> <span class="nop">           .          .           		// Unset sysmonWake, since the scavenger is now being awoken. </span>
<span class="line">    440</span> <span class="livesrc">           .          .           		s.sysmonWake.Store(0) </span><span class="asm">                   .          .   428626:                     NOPL                                                         <span class="unimportant">mgcscavenge.go:440</span>
</span>
<span class="line">    441</span> <span class="nop">           .          .            </span>
<span class="line">    442</span> <span class="nop">           .          .           		// s.parked is unset to prevent a double wake-up. </span>
<span class="line">    443</span> <span class="livesrc">           .          .           		s.parked = false </span><span class="asm">                   .          .   42862c:                     MOVB $0x0, 0x1c(AX)                                          <span class="unimportant">mgcscavenge.go:443</span>
</span>
<span class="line">    444</span> <span class="nop">           .          .            </span>
<span class="line">    445</span> <span class="nop">           .          .           		// Ready the goroutine by injecting it. We use injectglist instead </span>
<span class="line">    446</span> <span class="nop">           .          .           		// of ready or goready in order to allow us to run this function </span>
<span class="line">    447</span> <span class="nop">           .          .           		// without a P. injectglist also avoids placing the goroutine in </span>
<span class="line">    448</span> <span class="nop">           .          .           		// the current P's runnext slot, which is desirable to prevent </span>
<span class="line">    449</span> <span class="nop">           .          .           		// the scavenger from interfering with user goroutine scheduling </span>
<span class="line">    450</span> <span class="nop">           .          .           		// too much. </span>
<span class="line">    451</span> <span class="livesrc">           .          .           		var list gList </span><span class="asm">                   .          .   428630:                     MOVQ $0x0, 0x8(SP)                                           <span class="unimportant">mgcscavenge.go:451</span>
                   .          .   428639:                     MOVL $0x0, 0x10(SP)                                          <span class="unimportant">mgcscavenge.go:451</span>
</span>
<span class="line">    452</span> <span class="livesrc">           .          .           		list.push(s.g) </span><span class="asm">                   .          .   428641:                     MOVQ 0x8(AX), CX                                             <span class="unimportant">mgcscavenge.go:452</span>
</span>
<span class="line">    453</span> <span class="livesrc">           .      513kB           		injectglist(&amp;list) </span><span class="asm">                   .          .   42865a:                     LEAQ 0x8(SP), AX                                             <span class="unimportant">mgcscavenge.go:453</span>
                   .          .   42865f:                     NOPL                                                         <span class="unimportant">mgcscavenge.go:453</span>
                   .      513kB   428660:                     CALL runtime.injectglist(SB)                                 <span class="unimportant">mgcscavenge.go:453</span>
</span>
<span class="line">    454</span> <span class="nop">           .          .           	} </span>
<span class="line">    455</span> <span class="livesrc">           .          .           	unlock(&amp;s.lock) </span><span class="asm">                   .          .   42866a:             NOPL                                                                 <span class="unimportant">mgcscavenge.go:455</span>
</span>
<span class="line">    456</span> <span class="livesrc">           .          .           } </span><span class="asm">                   .          .   428671:     ADDQ $0x18, SP                                                               <span class="unimportant">mgcscavenge.go:456</span>
                   .          .   428675:     POPQ BP                                                                      <span class="unimportant">mgcscavenge.go:456</span>
                   .          .   428676:     RET                                                                          <span class="unimportant">mgcscavenge.go:456</span>
</span>
<span class="line">    457</span> <span class="nop">           .          .            </span>
<span class="line">    458</span> <span class="nop">           .          .           // sleep puts the scavenger to sleep based on the amount of time that it worked </span>
<span class="line">    459</span> <span class="nop">           .          .           // in nanoseconds. </span>
<span class="line">    460</span> <span class="nop">           .          .           // </span>
<span class="line">    461</span> <span class="nop">           .          .           // Note that this function should only be called by the scavenger. </span>
</pre>
<h2>runtime.gcMarkDone</h2><p class="filename">/home/mikhliuk/go/go1.25.4/src/runtime/sema.go</p>
<pre onclick="pprof_toggle_asm(event)">  Total:           0   512.05kB (flat, cum) 0.086%
<span class="line">    138</span> <span class="nop">           .          .           	semaMutexProfile </span>
<span class="line">    139</span> <span class="nop">           .          .           ) </span>
<span class="line">    140</span> <span class="nop">           .          .            </span>
<span class="line">    141</span> <span class="nop">           .          .           // Called from runtime. </span>
<span class="line">    142</span> <span class="nop">           .          .           func semacquire(addr *uint32) { </span>
<span class="line">    143</span> <span class="livesrc">           .   512.05kB           	semacquire1(addr, false, 0, 0, waitReasonSemacquire) </span><span class="asm">                   .          .   41f75b:             LEAQ runtime.work+380(SB), AX                                        <span class="unimportant">sema.go:143</span>
                   .          .   41f762:             XORL BX, BX                                                          <span class="unimportant">sema.go:143</span>
                   .          .   41f764:             XORL CX, CX                                                          <span class="unimportant">sema.go:143</span>
                   .          .   41f766:             XORL DI, DI                                                          <span class="unimportant">sema.go:143</span>
                   .          .   41f768:             MOVL $0x13, SI                                                       <span class="unimportant">sema.go:143</span>
                   .   512.05kB   41f76d:             CALL runtime.semacquire1(SB)                                         <span class="unimportant">sema.go:143</span>
                                     ⋮
                   .          .   41f829:             LEAQ runtime.worldsema(SB), AX                                       <span class="unimportant">sema.go:143</span>
                   .          .   41f830:             XORL BX, BX                                                          <span class="unimportant">sema.go:143</span>
                   .          .   41f832:             XORL CX, CX                                                          <span class="unimportant">sema.go:143</span>
                   .          .   41f834:             XORL DI, DI                                                          <span class="unimportant">sema.go:143</span>
                   .          .   41f836:             MOVL $0x13, SI                                                       <span class="unimportant">sema.go:143</span>
                   .          .   41f83b:             NOPL 0(AX)(AX*1)                                                     <span class="unimportant">sema.go:143</span>
                   .          .   41f840:             CALL runtime.semacquire1(SB)                                         <span class="unimportant">sema.go:143</span>
</span>
<span class="line">    144</span> <span class="nop">           .          .           } </span>
</pre>
<h2>runtime.semacquire1</h2><p class="filename">/home/mikhliuk/go/go1.25.4/src/runtime/sema.go</p>
<pre onclick="pprof_toggle_asm(event)">  Total:           0   512.05kB (flat, cum) 0.086%
<span class="line">    145</span> <span class="nop">           .          .            </span>
<span class="line">    146</span> <span class="livesrc">           .          .           func semacquire1(addr *uint32, lifo bool, profile semaProfileFlags, skipframes int, reason waitReason) { </span><span class="asm">                   .          .   4523e0:     CMPQ SP, 0x10(R14)                                                           <span class="unimportant">sema.go:146</span>
                   .          .   4523e4:     JBE 0x4526f7                                                                 <span class="unimportant">sema.go:146</span>
                   .          .   4523ea:     PUSHQ BP                                                                     <span class="unimportant">sema.go:146</span>
                   .          .   4523eb:     MOVQ SP, BP                                                                  <span class="unimportant">sema.go:146</span>
                   .          .   4523ee:     SUBQ $0x58, SP                                                               <span class="unimportant">sema.go:146</span>
</span>
<span class="line">    147</span> <span class="livesrc">           .          .           	gp := getg() </span><span class="asm">                   .          .   4523f2:             MOVQ 0x30(R14), DX                                                   <span class="unimportant">sema.go:147</span>
</span>
<span class="line">    148</span> <span class="livesrc">           .          .           	if gp != gp.m.curg { </span><span class="asm">                   .          .   4523f6:             MOVQ R14, R8                                                         <span class="unimportant">sema.go:148</span>
                   .          .   4523f9:             NOPL 0(AX)                                                           <span class="unimportant">sema.go:148</span>
                   .          .   452400:             CMPQ 0xb8(DX), R8                                                    <span class="unimportant">sema.go:148</span>
                   .          .   452407:             JNE 0x4526e5                                                         <span class="unimportant">sema.go:148</span>
                                     ⋮
                   .          .   45241d:             MOVQ AX, R9                                                          <span class="unimportant">sema.go:148</span>
                                     ⋮
                   .          .   452434:             MOVQ AX, 0x68(SP)                                                    <span class="unimportant">sema.go:148</span>
                   .          .   452439:             MOVB BL, 0x70(SP)                                                    <span class="unimportant">sema.go:148</span>
                   .          .   45243d:             MOVQ CX, 0x78(SP)                                                    <span class="unimportant">sema.go:148</span>
                   .          .   452442:             MOVQ DI, 0x80(SP)                                                    <span class="unimportant">sema.go:148</span>
                   .          .   45244a:             MOVB SI, 0x88(SP)                                                    <span class="unimportant">sema.go:148</span>
                                     ⋮
                   .          .   452475:             MOVQ DX, SI                                                          <span class="unimportant">sema.go:148</span>
</span>
<span class="line">    149</span> <span class="nop">           .          .           		throw("semacquire not on the G stack") </span>
<span class="line">    150</span> <span class="nop">           .          .           	} </span>
<span class="line">    151</span> <span class="nop">           .          .            </span>
<span class="line">    152</span> <span class="nop">           .          .           	// Easy case. </span>
<span class="line">    153</span> <span class="livesrc">           .          .           	if cansemacquire(addr) { </span><span class="asm">                   .          .   45240d:             NOPL                                                                 <span class="unimportant">sema.go:153</span>
</span>
<span class="line">    154</span> <span class="livesrc">           .          .           		return </span><span class="asm">                   .          .   45242e:                     ADDQ $0x58, SP                                               <span class="unimportant">sema.go:154</span>
                   .          .   452432:                     POPQ BP                                                      <span class="unimportant">sema.go:154</span>
                   .          .   452433:                     RET                                                          <span class="unimportant">sema.go:154</span>
</span>
<span class="line">    155</span> <span class="nop">           .          .           	} </span>
<span class="line">    156</span> <span class="nop">           .          .            </span>
<span class="line">    157</span> <span class="nop">           .          .           	// Harder case: </span>
<span class="line">    158</span> <span class="nop">           .          .           	//	increment waiter count </span>
<span class="line">    159</span> <span class="nop">           .          .           	//	try cansemacquire one more time, return if succeeded </span>
<span class="line">    160</span> <span class="nop">           .          .           	//	enqueue itself as a waiter </span>
<span class="line">    161</span> <span class="nop">           .          .           	//	sleep </span>
<span class="line">    162</span> <span class="nop">           .          .           	//	(waiter descriptor is dequeued by signaler) </span>
<span class="line">    163</span> <span class="livesrc">           .   512.05kB           	s := acquireSudog() </span><span class="asm">                   .   512.05kB   452452:             CALL runtime.acquireSudog(SB)                                        <span class="unimportant">sema.go:163</span>
                   .          .   452457:             MOVQ AX, 0x40(SP)                                                    <span class="unimportant">sema.go:163</span>
                                     ⋮
                   .          .   452468:             MOVQ AX, BX                                                          <span class="unimportant">sema.go:163</span>
</span>
<span class="line">    164</span> <span class="livesrc">           .          .           	root := semtable.rootFor(addr) </span><span class="asm">                   .          .   452498:             NOPL                                                                 <span class="unimportant">sema.go:164</span>
</span>
<span class="line">    165</span> <span class="nop">           .          .           	t0 := int64(0) </span>
<span class="line">    166</span> <span class="livesrc">           .          .           	s.releasetime = 0 </span><span class="asm">                   .          .   452499:             MOVUPS X15, 0x20(BX)                                                 <span class="unimportant">sema.go:166</span>
</span>
<span class="line">    167</span> <span class="nop">           .          .           	s.acquiretime = 0 </span>
<span class="line">    168</span> <span class="livesrc">           .          .           	s.ticket = 0 </span><span class="asm">                   .          .   45249e:             MOVL $0x0, 0x30(BX)                                                  <span class="unimportant">sema.go:168</span>
</span>
<span class="line">    169</span> <span class="livesrc">           .          .           	if profile&amp;semaBlockProfile != 0 &amp;&amp; blockprofilerate &gt; 0 { </span><span class="asm">                   .          .   4524b5:             MOVQ 0x78(SP), DI                                                    <span class="unimportant">sema.go:169</span>
                   .          .   4524ba:             BTL $0x0, DI                                                         <span class="unimportant">sema.go:169</span>
                   .          .   4524be:             NOPW                                                                 <span class="unimportant">sema.go:169</span>
                   .          .   4524c0:             JAE 0x452519                                                         <span class="unimportant">sema.go:169</span>
                   .          .   4524c2:             CMPQ runtime.blockprofilerate(SB), $0x0                              <span class="unimportant">sema.go:169</span>
                   .          .   4524ca:             JA 0x4524d1                                                          <span class="unimportant">sema.go:169</span>
                   .          .   4524cc:             XORL R8, R8                                                          <span class="unimportant">sema.go:169</span>
                   .          .   4524cf:             JMP 0x45251c                                                         <span class="unimportant">sema.go:169</span>
</span>
<span class="line">    170</span> <span class="livesrc">           .          .           		t0 = cputicks() </span><span class="asm">                   .          .   4524d1:                     CALL runtime.cputicks.abi0(SB)                               <span class="unimportant">sema.go:170</span>
                   .          .   4524d6:                     XORPS X15, X15                                               <span class="unimportant">sema.go:170</span>
                   .          .   4524da:                     MOVQ FS:0xfffffff8, R14                                      <span class="unimportant">sema.go:170</span>
                   .          .   4524e3:                     MOVQ 0(SP), AX                                               <span class="unimportant">sema.go:170</span>
</span>
<span class="line">    171</span> <span class="livesrc">           .          .           		s.releasetime = -1 </span><span class="asm">                   .          .   4524e7:                     MOVQ 0x40(SP), CX                                            <span class="unimportant">sema.go:171</span>
                   .          .   4524ec:                     MOVQ $-0x1, 0x28(CX)                                         <span class="unimportant">sema.go:171</span>
                                     ⋮
                   .          .   452517:                     JMP 0x45251c                                                 <span class="unimportant">sema.go:171</span>
                   .          .   452519:                     XORL R8, R8                                                  <span class="unimportant">sema.go:171</span>
</span>
<span class="line">    172</span> <span class="nop">           .          .           	} </span>
<span class="line">    173</span> <span class="livesrc">           .          .           	if profile&amp;semaMutexProfile != 0 &amp;&amp; mutexprofilerate &gt; 0 { </span><span class="asm">                   .          .   452508:             MOVQ 0x78(SP), DI                                                    <span class="unimportant">sema.go:173</span>
                                     ⋮
                   .          .   45251c:             BTL $0x1, DI                                                         <span class="unimportant">sema.go:173</span>
                   .          .   452520:             JAE 0x452566                                                         <span class="unimportant">sema.go:173</span>
                   .          .   452522:             CMPQ runtime.mutexprofilerate(SB), $0x0                              <span class="unimportant">sema.go:173</span>
                   .          .   45252a:             JBE 0x452566                                                         <span class="unimportant">sema.go:173</span>
</span>
<span class="line">    174</span> <span class="livesrc">           .          .           		if t0 == 0 { </span><span class="asm">                   .          .   45252c:                     TESTQ R8, R8                                                 <span class="unimportant">sema.go:174</span>
                   .          .   45252f:                     JNE 0x452562                                                 <span class="unimportant">sema.go:174</span>
</span>
<span class="line">    175</span> <span class="livesrc">           .          .           			t0 = cputicks() </span><span class="asm">                   .          .   452531:                             CALL runtime.cputicks.abi0(SB)                       <span class="unimportant">sema.go:175</span>
                   .          .   452536:                             XORPS X15, X15                                       <span class="unimportant">sema.go:175</span>
                   .          .   45253a:                             MOVQ FS:0xfffffff8, R14                              <span class="unimportant">sema.go:175</span>
                   .          .   452543:                             MOVQ 0(SP), R8                                       <span class="unimportant">sema.go:175</span>
                   .          .   452547:                             LEAQ runtime.semtable(SB), AX                        <span class="unimportant">sema.go:175</span>
</span>
<span class="line">    176</span> <span class="nop">           .          .           		} </span>
<span class="line">    177</span> <span class="livesrc">           .          .           		s.acquiretime = t0 </span><span class="asm">                   .          .   4524fe:                     MOVQ 0x40(SP), BX                                            <span class="unimportant">sema.go:177</span>
                                     ⋮
                   .          .   452558:                     MOVQ 0x40(SP), BX                                            <span class="unimportant">sema.go:177</span>
                                     ⋮
                   .          .   452562:                     MOVQ R8, 0x20(BX)                                            <span class="unimportant">sema.go:177</span>
</span>
<span class="line">    178</span> <span class="nop">           .          .           	} </span>
<span class="line">    179</span> <span class="nop">           .          .           	for { </span>
<span class="line">    180</span> <span class="livesrc">           .          .           		lockWithRank(&amp;root.lock, lockRankRoot) </span><span class="asm">                   .          .   4524f4:                     MOVQ 0x30(SP), CX                                            <span class="unimportant">sema.go:180</span>
                                     ⋮
                   .          .   45254e:                     MOVQ 0x30(SP), CX                                            <span class="unimportant">sema.go:180</span>
                                     ⋮
                   .          .   452574:                     MOVQ 0x30(SP), CX                                            <span class="unimportant">sema.go:180</span>
                   .          .   452579:                     LEAQ 0(CX)(AX*1), DX                                         <span class="unimportant">sema.go:180</span>
                   .          .   45257d:                     MOVQ DX, 0x48(SP)                                            <span class="unimportant">sema.go:180</span>
</span>
<span class="line">    181</span> <span class="nop">           .          .           		// Add ourselves to nwait to disable "easy case" in semrelease. </span>
<span class="line">    182</span> <span class="livesrc">           .          .           		root.nwait.Add(1) </span><span class="asm">                   .          .   452597:                     NOPL                                                         <span class="unimportant">sema.go:182</span>
</span>
<span class="line">    183</span> <span class="nop">           .          .           		// Check cansemacquire to avoid missed wakeup. </span>
<span class="line">    184</span> <span class="livesrc">           .          .           		if cansemacquire(addr) { </span><span class="asm">                   .          .   4525b6:                     JNE 0x452665                                                 <span class="unimportant">sema.go:184</span>
</span>
<span class="line">    185</span> <span class="nop">           .          .           			root.nwait.Add(-1) </span>
<span class="line">    186</span> <span class="nop">           .          .           			unlock(&amp;root.lock) </span>
<span class="line">    187</span> <span class="nop">           .          .           			break </span>
<span class="line">    188</span> <span class="nop">           .          .           		} </span>
<span class="line">    189</span> <span class="nop">           .          .           		// Any semrelease after the cansemacquire knows we're waiting </span>
<span class="line">    190</span> <span class="nop">           .          .           		// (we set nwait above), so go to sleep. </span>
<span class="line">    191</span> <span class="livesrc">           .          .           		root.queue(addr, s, lifo) </span><span class="asm">                   .          .   4524f9:                     MOVQ 0x38(SP), DX                                            <span class="unimportant">sema.go:191</span>
                                     ⋮
                   .          .   452553:                     MOVQ 0x38(SP), DX                                            <span class="unimportant">sema.go:191</span>
                                     ⋮
                   .          .   4525bc:                     MOVQ 0x38(SP), AX                                            <span class="unimportant">sema.go:191</span>
                   .          .   4525c1:                     MOVQ CX, BX                                                  <span class="unimportant">sema.go:191</span>
                   .          .   4525c4:                     MOVQ 0x40(SP), CX                                            <span class="unimportant">sema.go:191</span>
                   .          .   4525c9:                     MOVZX 0x70(SP), DI                                           <span class="unimportant">sema.go:191</span>
                   .          .   4525ce:                     CALL runtime.(*semaRoot).queue(SB)                           <span class="unimportant">sema.go:191</span>
</span>
<span class="line">    192</span> <span class="livesrc">           .          .           		goparkunlock(&amp;root.lock, reason, traceBlockSync, 4+skipframes) </span><span class="asm">                   .          .   4525d3:                     MOVQ 0x80(SP), SI                                            <span class="unimportant">sema.go:192</span>
                   .          .   4525db:                     ADDQ $0x4, SI                                                <span class="unimportant">sema.go:192</span>
</span>
<span class="line">    193</span> <span class="livesrc">           .          .           		if s.ticket != 0 || cansemacquire(addr) { </span><span class="asm">                   .          .   4525fd:                     MOVQ 0x40(SP), AX                                            <span class="unimportant">sema.go:193</span>
                   .          .   452602:                     CMPL 0x30(AX), $0x0                                          <span class="unimportant">sema.go:193</span>
                   .          .   452606:                     JE 0x452617                                                  <span class="unimportant">sema.go:193</span>
                                     ⋮
                   .          .   452615:                     JMP 0x45262f                                                 <span class="unimportant">sema.go:193</span>
                                     ⋮
                   .          .   452627:                     JMP 0x45262c                                                 <span class="unimportant">sema.go:193</span>
                                     ⋮
                   .          .   45262c:                     SETNE DL                                                     <span class="unimportant">sema.go:193</span>
                   .          .   45262f:                     TESTL DL, DL                                                 <span class="unimportant">sema.go:193</span>
                   .          .   452631:                     JE 0x45256d                                                  <span class="unimportant">sema.go:193</span>
                   .          .   452637:                     JMP 0x45267b                                                 <span class="unimportant">sema.go:193</span>
</span>
<span class="line">    194</span> <span class="nop">           .          .           			break </span>
<span class="line">    195</span> <span class="nop">           .          .           		} </span>
<span class="line">    196</span> <span class="nop">           .          .           	} </span>
<span class="line">    197</span> <span class="livesrc">           .          .           	if s.releasetime &gt; 0 { </span><span class="asm">                   .          .   45260d:             MOVQ AX, BX                                                          <span class="unimportant">sema.go:197</span>
                   .          .   452610:             MOVL $0x1, DX                                                        <span class="unimportant">sema.go:197</span>
                                     ⋮
                   .          .   452629:             MOVQ AX, BX                                                          <span class="unimportant">sema.go:197</span>
</span>
<span class="line">    198</span> <span class="livesrc">           .          .           		blockevent(s.releasetime-t0, 3+skipframes) </span><span class="asm">                   .          .   45250d:                     MOVQ AX, R8                                                  <span class="unimportant">sema.go:198</span>
                   .          .   452510:                     LEAQ runtime.semtable(SB), AX                                <span class="unimportant">sema.go:198</span>
                                     ⋮
                   .          .   452566:                     MOVQ R8, 0x28(SP)                                            <span class="unimportant">sema.go:198</span>
                   .          .   45256b:                     JMP 0x452579                                                 <span class="unimportant">sema.go:198</span>
                   .          .   45256d:                     LEAQ runtime.semtable(SB), AX                                <span class="unimportant">sema.go:198</span>
</span>
<span class="line">    199</span> <span class="nop">           .          .           	} </span>
<span class="line">    200</span> <span class="nop">           .          .           	releaseSudog(s) </span>
</pre>
<h2>runtime.gcBgMarkWorker</h2><p class="filename">/home/mikhliuk/go/go1.25.4/src/runtime/mgc.go</p>
<pre onclick="pprof_toggle_asm(event)">  Total:           0   512.05kB (flat, cum) 0.086%
<span class="line">   1561</span> <span class="nop">           .          .           			} </span>
<span class="line">   1562</span> <span class="nop">           .          .           			casgstatus(gp, _Gwaiting, _Grunning) </span>
<span class="line">   1563</span> <span class="nop">           .          .           		}) </span>
<span class="line">   1564</span> <span class="nop">           .          .            </span>
<span class="line">   1565</span> <span class="nop">           .          .           		// Account for time and mark us as stopped. </span>
<span class="line">   1566</span> <span class="livesrc">           .          .           		now := nanotime() </span><span class="asm">                   .          .   42133e:                     NOPL                                                         <span class="unimportant">mgc.go:1566</span>
                   .          .   42133f:                     NOPL                                                         <span class="unimportant">mgc.go:1566</span>
</span>
<span class="line">   1567</span> <span class="livesrc">           .          .           		duration := now - startTime </span><span class="asm">                   .          .   421367:                     MOVQ 0x38(SP), AX                                            <span class="unimportant">mgc.go:1567</span>
                   .          .   42136c:                     MOVQ CX, DX                                                  <span class="unimportant">mgc.go:1567</span>
                   .          .   42136f:                     SUBQ AX, DX                                                  <span class="unimportant">mgc.go:1567</span>
                   .          .   421372:                     MOVQ DX, 0x40(SP)                                            <span class="unimportant">mgc.go:1567</span>
</span>
<span class="line">   1568</span> <span class="livesrc">           .          .           		gcController.markWorkerStop(pp.gcMarkWorkerMode, duration) </span><span class="asm">                   .          .   421352:                     MOVQ 0x58(SP), AX                                            <span class="unimportant">mgc.go:1568</span>
                   .          .   421357:                     MOVQ 0x1238(AX), BX                                          <span class="unimportant">mgc.go:1568</span>
                                     ⋮
                   .          .   421377:                     LEAQ runtime.gcController(SB), AX                            <span class="unimportant">mgc.go:1568</span>
                   .          .   42137e:                     MOVQ DX, CX                                                  <span class="unimportant">mgc.go:1568</span>
                   .          .   421381:                     CALL runtime.(*gcControllerState).markWorkerStop(SB)         <span class="unimportant">mgc.go:1568</span>
</span>
<span class="line">   1569</span> <span class="livesrc">           .          .           		if trackLimiterEvent { </span><span class="asm">                   .          .   421304:                     MOVB DL, 0x23(SP)                                            <span class="unimportant">mgc.go:1569</span>
                                     ⋮
                   .          .   421386:                     MOVZX 0x23(SP), AX                                           <span class="unimportant">mgc.go:1569</span>
                   .          .   42138b:                     TESTL AL, AL                                                 <span class="unimportant">mgc.go:1569</span>
                   .          .   42138d:                     JE 0x4213a9                                                  <span class="unimportant">mgc.go:1569</span>
</span>
<span class="line">   1570</span> <span class="livesrc">           .          .           			pp.limiterEvent.stop(limiterEventIdleMarkWork, now) </span><span class="asm">                   .          .   42138f:                             MOVQ 0x58(SP), AX                                    <span class="unimportant">mgc.go:1570</span>
                   .          .   421394:                             ADDQ $0x1230, AX                                     <span class="unimportant">mgc.go:1570</span>
                   .          .   42139a:                             MOVL $0x1, BX                                        <span class="unimportant">mgc.go:1570</span>
                   .          .   42139f:                             MOVQ 0x30(SP), CX                                    <span class="unimportant">mgc.go:1570</span>
                   .          .   4213a4:                             CALL runtime.(*limiterEvent).stop(SB)                <span class="unimportant">mgc.go:1570</span>
</span>
<span class="line">   1571</span> <span class="nop">           .          .           		} </span>
<span class="line">   1572</span> <span class="livesrc">           .          .           		if pp.gcMarkWorkerMode == gcMarkWorkerFractionalMode { </span><span class="asm">                   .          .   4213a9:                     MOVQ 0x58(SP), DX                                            <span class="unimportant">mgc.go:1572</span>
                   .          .   4213ae:                     CMPQ 0x1238(DX), $0x2                                        <span class="unimportant">mgc.go:1572</span>
                   .          .   4213b6:                     JNE 0x4213c6                                                 <span class="unimportant">mgc.go:1572</span>
</span>
<span class="line">   1573</span> <span class="livesrc">           .          .           			atomic.Xaddint64(&amp;pp.gcFractionalMarkTime, duration) </span><span class="asm">                   .          .   4213b8:                             MOVQ 0x40(SP), R8                                    <span class="unimportant">mgc.go:1573</span>
                   .          .   4213bd:                             LOCK XADDQ R8, 0x1228(DX)                            <span class="unimportant">mgc.go:1573</span>
</span>
<span class="line">   1574</span> <span class="nop">           .          .           		} </span>
<span class="line">   1575</span> <span class="nop">           .          .            </span>
<span class="line">   1576</span> <span class="nop">           .          .           		// Was this the last worker and did we run out </span>
<span class="line">   1577</span> <span class="nop">           .          .           		// of work? </span>
<span class="line">   1578</span> <span class="livesrc">           .          .           		incnwait := atomic.Xadd(&amp;work.nwait, +1) </span><span class="asm">                   .          .   4213c6:                     MOVL $0x1, R8                                                <span class="unimportant">mgc.go:1578</span>
                   .          .   4213cc:                     LEAQ runtime.work+288(SB), R9                                <span class="unimportant">mgc.go:1578</span>
                   .          .   4213d3:                     LOCK XADDL R8, 0(R9)                                         <span class="unimportant">mgc.go:1578</span>
                   .          .   4213d8:                     INCL R8                                                      <span class="unimportant">mgc.go:1578</span>
                                     ⋮
                   .          .   42148a:                     MOVL R8, 0x24(SP)                                            <span class="unimportant">mgc.go:1578</span>
</span>
<span class="line">   1579</span> <span class="livesrc">           .          .           		if incnwait &gt; work.nproc { </span><span class="asm">                   .          .   4213db:                     MOVL runtime.work+272(SB), R9                                <span class="unimportant">mgc.go:1579</span>
                   .          .   4213e2:                     CMPL R9, R8                                                  <span class="unimportant">mgc.go:1579</span>
                   .          .   4213e5:                     JB 0x42148a                                                  <span class="unimportant">mgc.go:1579</span>
                                     ⋮
                   .          .   42148f:                     MOVL R9, 0x2c(SP)                                            <span class="unimportant">mgc.go:1579</span>
</span>
<span class="line">   1580</span> <span class="livesrc">           .          .           			println("runtime: p.gcMarkWorkerMode=", pp.gcMarkWorkerMode, </span><span class="asm">                   .          .   421494:                             MOVQ 0x1238(DX), AX                                  <span class="unimportant">mgc.go:1580</span>
                   .          .   42149b:                             MOVQ AX, 0x48(SP)                                    <span class="unimportant">mgc.go:1580</span>
                   .          .   4214a0:                             CALL runtime.printlock(SB)                           <span class="unimportant">mgc.go:1580</span>
                   .          .   4214a5:                             LEAQ 0xd9c9c(IP), AX                                 <span class="unimportant">mgc.go:1580</span>
                   .          .   4214ac:                             MOVL $0x1d, BX                                       <span class="unimportant">mgc.go:1580</span>
                   .          .   4214b1:                             CALL runtime.printstring(SB)                         <span class="unimportant">mgc.go:1580</span>
                   .          .   4214b6:                             MOVQ 0x48(SP), AX                                    <span class="unimportant">mgc.go:1580</span>
                   .          .   4214bb:                             NOPL 0(AX)(AX*1)                                     <span class="unimportant">mgc.go:1580</span>
                   .          .   4214c0:                             CALL runtime.printint(SB)                            <span class="unimportant">mgc.go:1580</span>
                   .          .   4214c5:                             LEAQ 0xd5f42(IP), AX                                 <span class="unimportant">mgc.go:1580</span>
                   .          .   4214cc:                             MOVL $0xd, BX                                        <span class="unimportant">mgc.go:1580</span>
                   .          .   4214d1:                             CALL runtime.printstring(SB)                         <span class="unimportant">mgc.go:1580</span>
                   .          .   4214d6:                             MOVL 0x24(SP), AX                                    <span class="unimportant">mgc.go:1580</span>
                   .          .   4214da:                             CALL runtime.printuint(SB)                           <span class="unimportant">mgc.go:1580</span>
                   .          .   4214df:                             LEAQ 0xd5f1b(IP), AX                                 <span class="unimportant">mgc.go:1580</span>
                   .          .   4214e6:                             MOVL $0xd, BX                                        <span class="unimportant">mgc.go:1580</span>
                   .          .   4214eb:                             CALL runtime.printstring(SB)                         <span class="unimportant">mgc.go:1580</span>
                   .          .   4214f0:                             MOVL 0x2c(SP), AX                                    <span class="unimportant">mgc.go:1580</span>
                   .          .   4214f4:                             CALL runtime.printuint(SB)                           <span class="unimportant">mgc.go:1580</span>
                   .          .   4214f9:                             CALL runtime.printnl(SB)                             <span class="unimportant">mgc.go:1580</span>
                   .          .   4214fe:                             NOPW                                                 <span class="unimportant">mgc.go:1580</span>
                   .          .   421500:                             CALL runtime.printunlock(SB)                         <span class="unimportant">mgc.go:1580</span>
</span>
<span class="line">   1581</span> <span class="nop">           .          .           				"work.nwait=", incnwait, "work.nproc=", work.nproc) </span>
<span class="line">   1582</span> <span class="livesrc">           .          .           			throw("work.nwait &gt; work.nproc") </span><span class="asm">                   .          .   421505:                             LEAQ 0xd85cd(IP), AX                                 <span class="unimportant">mgc.go:1582</span>
                   .          .   42150c:                             MOVL $0x17, BX                                       <span class="unimportant">mgc.go:1582</span>
                   .          .   421511:                             CALL runtime.throw(SB)                               <span class="unimportant">mgc.go:1582</span>
</span>
<span class="line">   1583</span> <span class="nop">           .          .           		} </span>
<span class="line">   1584</span> <span class="nop">           .          .            </span>
<span class="line">   1585</span> <span class="nop">           .          .           		// We'll releasem after this point and thus this P may run </span>
<span class="line">   1586</span> <span class="nop">           .          .           		// something else. We must clear the worker mode to avoid </span>
<span class="line">   1587</span> <span class="nop">           .          .           		// attributing the mode to a different (non-worker) G in </span>
<span class="line">   1588</span> <span class="nop">           .          .           		// tracev2.GoStart. </span>
<span class="line">   1589</span> <span class="livesrc">           .          .           		pp.gcMarkWorkerMode = gcMarkWorkerNotWorker </span><span class="asm">                   .          .   4213eb:                     MOVQ $0x0, 0x1238(DX)                                        <span class="unimportant">mgc.go:1589</span>
                   .          .   4213f6:                     NOPW 0(AX)(AX*1)                                             <span class="unimportant">mgc.go:1589</span>
                   .          .   4213ff:                     NOPL                                                         <span class="unimportant">mgc.go:1589</span>
</span>
<span class="line">   1590</span> <span class="nop">           .          .            </span>
<span class="line">   1591</span> <span class="nop">           .          .           		// If this worker reached a background mark completion </span>
<span class="line">   1592</span> <span class="nop">           .          .           		// point, signal the main GC goroutine. </span>
<span class="line">   1593</span> <span class="livesrc">           .          .           		if incnwait == work.nproc &amp;&amp; !gcMarkWorkAvailable(nil) { </span><span class="asm">                   .          .   421400:                     CMPL runtime.work+272(SB), R8                                <span class="unimportant">mgc.go:1593</span>
                   .          .   421407:                     JNE 0x42120e                                                 <span class="unimportant">mgc.go:1593</span>
                                     ⋮
                   .          .   42142d:                     JMP 0x421440                                                 <span class="unimportant">mgc.go:1593</span>
                   .          .   42142f:                     XORL AX, AX                                                  <span class="unimportant">mgc.go:1593</span>
                   .          .   421431:                     JMP 0x421440                                                 <span class="unimportant">mgc.go:1593</span>
                   .          .   421433:                     MOVL $0x1, AX                                                <span class="unimportant">mgc.go:1593</span>
                   .          .   421438:                     NOPL 0(AX)(AX*1)                                             <span class="unimportant">mgc.go:1593</span>
                   .          .   421440:                     TESTL AL, AL                                                 <span class="unimportant">mgc.go:1593</span>
                   .          .   421442:                     JNE 0x42120e                                                 <span class="unimportant">mgc.go:1593</span>
</span>
<span class="line">   1594</span> <span class="nop">           .          .           			// We don't need the P-local buffers here, allow </span>
<span class="line">   1595</span> <span class="nop">           .          .           			// preemption because we may schedule like a regular </span>
<span class="line">   1596</span> <span class="nop">           .          .           			// goroutine in gcMarkDone (block on locks, etc). </span>
<span class="line">   1597</span> <span class="livesrc">           .          .           			releasem(node.m.ptr()) </span><span class="asm">                   .          .   421448:                             MOVQ 0x60(SP), AX                                    <span class="unimportant">mgc.go:1597</span>
                   .          .   42144d:                             MOVQ 0x18(AX), CX                                    <span class="unimportant">mgc.go:1597</span>
</span>
<span class="line">   1598</span> <span class="livesrc">           .          .           			node.m.set(nil) </span><span class="asm">                   .          .   421479:                             NOPL                                                 <span class="unimportant">mgc.go:1598</span>
</span>
<span class="line">   1599</span> <span class="nop">           .          .            </span>
<span class="line">   1600</span> <span class="livesrc">           .   512.05kB           			gcMarkDone() </span><span class="asm">                   .          .   42147e:                             NOPW                                                 <span class="unimportant">mgc.go:1600</span>
                   .   512.05kB   421480:                             CALL runtime.gcMarkDone(SB)                          <span class="unimportant">mgc.go:1600</span>
                   .          .   421485:                             JMP 0x42120e                                         <span class="unimportant">mgc.go:1600</span>
</span>
<span class="line">   1601</span> <span class="nop">           .          .           		} </span>
<span class="line">   1602</span> <span class="nop">           .          .           	} </span>
<span class="line">   1603</span> <span class="nop">           .          .           } </span>
<span class="line">   1604</span> <span class="nop">           .          .            </span>
<span class="line">   1605</span> <span class="nop">           .          .           // gcMarkWorkAvailable reports whether executing a mark worker </span>
</pre>
<h2>main.main</h2><p class="filename">/home/mikhliuk/go/go1.25.4/src/os/file.go</p>
<pre onclick="pprof_toggle_asm(event)">  Total:           0      512kB (flat, cum) 0.086%
<span class="line">    385</span> <span class="nop">           .          .           // Open opens the named file for reading. If successful, methods on </span>
<span class="line">    386</span> <span class="nop">           .          .           // the returned file can be used for reading; the associated file </span>
<span class="line">    387</span> <span class="nop">           .          .           // descriptor has mode [O_RDONLY]. </span>
<span class="line">    388</span> <span class="nop">           .          .           // If there is an error, it will be of type [*PathError]. </span>
<span class="line">    389</span> <span class="nop">           .          .           func Open(name string) (*File, error) { </span>
<span class="line">    390</span> <span class="livesrc">           .          .           	return OpenFile(name, O_RDONLY, 0) </span><span class="asm">                   .          .   4c9a68:             XORL CX, CX                                                          <span class="unimportant">file.go:390</span>
                   .          .   4c9a6a:             XORL DI, DI                                                          <span class="unimportant">file.go:390</span>
                   .          .   4c9a6c:             CALL os.OpenFile(SB)                                                 <span class="unimportant">file.go:390</span>
                                     ⋮
                   .          .   4c9a7a:             MOVQ AX, 0x80(SP)                                                    <span class="unimportant">file.go:390</span>
</span>
<span class="line">    391</span> <span class="nop">           .          .           } </span>
<span class="line">    392</span> <span class="nop">           .          .            </span>
<span class="line">    393</span> <span class="nop">           .          .           // Create creates or truncates the named file. If the file already exists, </span>
<span class="line">    394</span> <span class="nop">           .          .           // it is truncated. If the file does not exist, it is created with mode 0o666 </span>
<span class="line">    395</span> <span class="nop">           .          .           // (before umask). If successful, methods on the returned File can </span>
<span class="line">    396</span> <span class="nop">           .          .           // be used for I/O; the associated file descriptor has mode [O_RDWR]. </span>
<span class="line">    397</span> <span class="nop">           .          .           // The directory containing the file must already exist. </span>
<span class="line">    398</span> <span class="nop">           .          .           // If there is an error, it will be of type [*PathError]. </span>
<span class="line">    399</span> <span class="nop">           .          .           func Create(name string) (*File, error) { </span>
<span class="line">    400</span> <span class="livesrc">           .      512kB           	return OpenFile(name, O_RDWR|O_CREATE|O_TRUNC, 0666) </span><span class="asm">                   .          .   4c99c9:             LEAQ 0x2e3f8(IP), AX                                                 <span class="unimportant">file.go:400</span>
                   .          .   4c99d0:             MOVL $0x10, BX                                                       <span class="unimportant">file.go:400</span>
                   .          .   4c99d5:             MOVL $0x242, CX                                                      <span class="unimportant">file.go:400</span>
                   .          .   4c99da:             MOVL $0x1b6, DI                                                      <span class="unimportant">file.go:400</span>
                   .          .   4c99df:             NOPL                                                                 <span class="unimportant">file.go:400</span>
                   .      512kB   4c99e0:             CALL os.OpenFile(SB)                                                 <span class="unimportant">file.go:400</span>
</span>
<span class="line">    401</span> <span class="nop">           .          .           } </span>
<span class="line">    402</span> <span class="nop">           .          .            </span>
<span class="line">    403</span> <span class="nop">           .          .           // OpenFile is the generalized open call; most users will use Open </span>
<span class="line">    404</span> <span class="nop">           .          .           // or Create instead. It opens the named file with specified flag </span>
</pre>
<h2>os.OpenFile</h2><p class="filename">/home/mikhliuk/go/go1.25.4/src/os/file.go</p>
<pre onclick="pprof_toggle_asm(event)">  Total:           0      512kB (flat, cum) 0.086%
<span class="line">    406</span> <span class="nop">           .          .           // is passed, it is created with mode perm (before umask); </span>
<span class="line">    407</span> <span class="nop">           .          .           // the containing directory must exist. If successful, </span>
<span class="line">    408</span> <span class="nop">           .          .           // methods on the returned File can be used for I/O. </span>
<span class="line">    409</span> <span class="nop">           .          .           // If there is an error, it will be of type [*PathError]. </span>
<span class="line">    410</span> <span class="livesrc">           .          .           func OpenFile(name string, flag int, perm FileMode) (*File, error) { </span><span class="asm">                   .          .   4a0dc0:     CMPQ SP, 0x10(R14)                                                           <span class="unimportant">file.go:410</span>
                   .          .   4a0dc4:     JBE 0x4a0e27                                                                 <span class="unimportant">file.go:410</span>
                   .          .   4a0dc6:     PUSHQ BP                                                                     <span class="unimportant">file.go:410</span>
                   .          .   4a0dc7:     MOVQ SP, BP                                                                  <span class="unimportant">file.go:410</span>
                   .          .   4a0dca:     SUBQ $0x20, SP                                                               <span class="unimportant">file.go:410</span>
                                     ⋮
                   .          .   4a0e27:     MOVQ AX, 0x8(SP)                                                             <span class="unimportant">file.go:410</span>
                   .          .   4a0e2c:     MOVQ BX, 0x10(SP)                                                            <span class="unimportant">file.go:410</span>
                   .          .   4a0e31:     MOVQ CX, 0x18(SP)                                                            <span class="unimportant">file.go:410</span>
                   .          .   4a0e36:     MOVL DI, 0x20(SP)                                                            <span class="unimportant">file.go:410</span>
                   .          .   4a0e3a:     CALL runtime.morestack_noctxt.abi0(SB)                                       <span class="unimportant">file.go:410</span>
                   .          .   4a0e3f:     MOVQ 0x8(SP), AX                                                             <span class="unimportant">file.go:410</span>
                   .          .   4a0e44:     MOVQ 0x10(SP), BX                                                            <span class="unimportant">file.go:410</span>
                   .          .   4a0e49:     MOVQ 0x18(SP), CX                                                            <span class="unimportant">file.go:410</span>
                   .          .   4a0e4e:     MOVL 0x20(SP), DI                                                            <span class="unimportant">file.go:410</span>
                   .          .   4a0e52:     JMP os.OpenFile(SB)                                                          <span class="unimportant">file.go:410</span>
</span>
<span class="line">    411</span> <span class="livesrc">           .          .           	testlog.Open(name) </span><span class="asm">                   .          .   4a0de1:             CALL internal/testlog.Open(SB)                                       <span class="unimportant">file.go:411</span>
</span>
<span class="line">    412</span> <span class="livesrc">           .      512kB           	f, err := openFileNolog(name, flag, perm) </span><span class="asm" style="">                   .          .   4a0de6:             MOVQ 0x30(SP), AX                                                    <span class="unimportant">file.go:412</span>
                   .          .   4a0deb:             MOVQ 0x38(SP), BX                                                    <span class="unimportant">file.go:412</span>
                   .          .   4a0df0:             MOVQ 0x40(SP), CX                                                    <span class="unimportant">file.go:412</span>
                   .          .   4a0df5:             MOVL 0x48(SP), DI                                                    <span class="unimportant">file.go:412</span>
                   .      512kB   4a0df9:             CALL os.openFileNolog(SB)                                            <span class="unimportant">file.go:412</span>
                   .          .   4a0dfe:             NOPW                                                                 <span class="unimportant">file.go:412</span>
</span>
<span class="line">    413</span> <span class="livesrc">           .          .           	if err != nil { </span><span class="asm">                   .          .   4a0dce:             MOVQ BX, 0x38(SP)                                                    <span class="unimportant">file.go:413</span>
                   .          .   4a0dd3:             MOVQ AX, 0x30(SP)                                                    <span class="unimportant">file.go:413</span>
                   .          .   4a0dd8:             MOVQ CX, 0x40(SP)                                                    <span class="unimportant">file.go:413</span>
                   .          .   4a0ddd:             MOVL DI, 0x48(SP)                                                    <span class="unimportant">file.go:413</span>
                                     ⋮
                   .          .   4a0e00:             TESTQ BX, BX                                                         <span class="unimportant">file.go:413</span>
                   .          .   4a0e03:             JE 0x4a0e0d                                                          <span class="unimportant">file.go:413</span>
</span>
<span class="line">    414</span> <span class="livesrc">           .          .           		return nil, err </span><span class="asm">                   .          .   4a0e05:                     XORL AX, AX                                                  <span class="unimportant">file.go:414</span>
                   .          .   4a0e07:                     ADDQ $0x20, SP                                               <span class="unimportant">file.go:414</span>
                   .          .   4a0e0b:                     POPQ BP                                                      <span class="unimportant">file.go:414</span>
                   .          .   4a0e0c:                     RET                                                          <span class="unimportant">file.go:414</span>
</span>
<span class="line">    415</span> <span class="nop">           .          .           	} </span>
<span class="line">    416</span> <span class="livesrc">           .          .           	f.appendMode = flag&amp;O_APPEND != 0 </span><span class="asm">                   .          .   4a0e0d:             MOVQ 0(AX), DX                                                       <span class="unimportant">file.go:416</span>
                   .          .   4a0e10:             MOVQ 0x40(SP), SI                                                    <span class="unimportant">file.go:416</span>
                   .          .   4a0e15:             BTL $0xa, SI                                                         <span class="unimportant">file.go:416</span>
                   .          .   4a0e19:             SETB 0x52(DX)                                                        <span class="unimportant">file.go:416</span>
</span>
<span class="line">    417</span> <span class="nop">           .          .            </span>
<span class="line">    418</span> <span class="livesrc">           .          .           	return f, nil </span><span class="asm">                   .          .   4a0e1d:             XORL BX, BX                                                          <span class="unimportant">file.go:418</span>
                   .          .   4a0e1f:             XORL CX, CX                                                          <span class="unimportant">file.go:418</span>
                   .          .   4a0e21:             ADDQ $0x20, SP                                                       <span class="unimportant">file.go:418</span>
                   .          .   4a0e25:             POPQ BP                                                              <span class="unimportant">file.go:418</span>
                   .          .   4a0e26:             RET                                                                  <span class="unimportant">file.go:418</span>
</span>
<span class="line">    419</span> <span class="nop">           .          .           } </span>
<span class="line">    420</span> <span class="nop">           .          .            </span>
<span class="line">    421</span> <span class="nop">           .          .           var errPathEscapes = errors.New("path escapes from parent") </span>
<span class="line">    422</span> <span class="nop">           .          .            </span>
<span class="line">    423</span> <span class="nop">           .          .           // openDir opens a file which is assumed to be a directory. As such, it skips </span>
</pre>

  </div>
<script>


function initPanAndZoom(svg, clickHandler) {
  'use strict';

  
  const IDLE = 0;
  const MOUSEPAN = 1;
  const TOUCHPAN = 2;
  const TOUCHZOOM = 3;
  let mode = IDLE;

  
  let currentScale = 1.0;
  const initWidth = svg.viewBox.baseVal.width;
  const initHeight = svg.viewBox.baseVal.height;

  
  let panLastX = 0;      
  let panLastY = 0;      
  let moved = false;     
  let touchid = null;    

  
  let touchid2 = null;     
  let initGap = 1.0;       
  let initScale = 1.0;     
  let centerPoint = null;  

  
  function toSvg(x, y) {
    const p = svg.createSVGPoint();
    p.x = x;
    p.y = y;
    let m = svg.getCTM();
    if (m == null) m = svg.getScreenCTM(); 
    return p.matrixTransform(m.inverse());
  }

  
  
  function rescale(s, u) {
    
    if (s < 0.2) s = 0.2;
    if (s > 10.0) s = 10.0;

    currentScale = s;

    
    
    
    const vb = svg.viewBox;
    const w1 = vb.baseVal.width;
    const w2 = initWidth / s;
    const h1 = vb.baseVal.height;
    const h2 = initHeight / s;
    vb.baseVal.width = w2;
    vb.baseVal.height = h2;

    
    
    
    
    
    
    
    vb.baseVal.x = u.x - (u.x - vb.baseVal.x) * (w2 / w1);
    vb.baseVal.y = u.y - (u.y - vb.baseVal.y) * (h2 / h1);
  }

  function handleWheel(e) {
    if (e.deltaY == 0) return;
    
    rescale(currentScale * (e.deltaY < 0 ? 1.1 : (1/1.1)),
            toSvg(e.offsetX, e.offsetY));
  }

  function setMode(m) {
    mode = m;
    touchid = null;
    touchid2 = null;
  }

  function panStart(x, y) {
    moved = false;
    panLastX = x;
    panLastY = y;
  }

  function panMove(x, y) {
    let dx = x - panLastX;
    let dy = y - panLastY;
    if (Math.abs(dx) <= 2 && Math.abs(dy) <= 2) return; 

    moved = true;
    panLastX = x;
    panLastY = y;

    
    const swidth = svg.clientWidth || svg.parentNode.clientWidth;
    const sheight = svg.clientHeight || svg.parentNode.clientHeight;

    
    dx *= (svg.viewBox.baseVal.width / swidth);
    dy *= (svg.viewBox.baseVal.height / sheight);

    svg.viewBox.baseVal.x -= dx;
    svg.viewBox.baseVal.y -= dy;
  }

  function handleScanStart(e) {
    if (e.button != 0) return; 
    setMode(MOUSEPAN);
    panStart(e.clientX, e.clientY);
    e.preventDefault();
    svg.addEventListener('mousemove', handleScanMove);
  }

  function handleScanMove(e) {
    if (e.buttons == 0) {
      
      setMode(IDLE);
      svg.removeEventListener('mousemove', handleScanMove);
      return;
    }
    if (mode == MOUSEPAN) panMove(e.clientX, e.clientY);
  }

  function handleScanEnd(e) {
    if (mode == MOUSEPAN) panMove(e.clientX, e.clientY);
    setMode(IDLE);
    svg.removeEventListener('mousemove', handleScanMove);
    if (!moved) clickHandler(e.target);
  }

  
  function findTouch(tlist, id) {
    for (const t of tlist) {
      if (t.identifier == id) return t;
    }
    return null;
  }

  
  function touchGap(t1, t2) {
    const dx = t1.clientX - t2.clientX;
    const dy = t1.clientY - t2.clientY;
    return Math.hypot(dx, dy);
  }

  function handleTouchStart(e) {
    if (mode == IDLE && e.changedTouches.length == 1) {
      
      const t = e.changedTouches[0];
      setMode(TOUCHPAN);
      touchid = t.identifier;
      panStart(t.clientX, t.clientY);
      e.preventDefault();
    } else if (mode == TOUCHPAN && e.touches.length == 2) {
      
      setMode(TOUCHZOOM);
      const t1 = e.touches[0];
      const t2 = e.touches[1];
      touchid = t1.identifier;
      touchid2 = t2.identifier;
      initScale = currentScale;
      initGap = touchGap(t1, t2);
      centerPoint = toSvg((t1.clientX + t2.clientX) / 2,
                          (t1.clientY + t2.clientY) / 2);
      e.preventDefault();
    }
  }

  function handleTouchMove(e) {
    if (mode == TOUCHPAN) {
      const t = findTouch(e.changedTouches, touchid);
      if (t == null) return;
      if (e.touches.length != 1) {
        setMode(IDLE);
        return;
      }
      panMove(t.clientX, t.clientY);
      e.preventDefault();
    } else if (mode == TOUCHZOOM) {
      
      const t1 = findTouch(e.touches, touchid);
      const t2 = findTouch(e.touches, touchid2);
      if (t1 == null || t2 == null) return;
      const gap = touchGap(t1, t2);
      rescale(initScale * gap / initGap, centerPoint);
      e.preventDefault();
    }
  }

  function handleTouchEnd(e) {
    if (mode == TOUCHPAN) {
      const t = findTouch(e.changedTouches, touchid);
      if (t == null) return;
      panMove(t.clientX, t.clientY);
      setMode(IDLE);
      e.preventDefault();
      if (!moved) clickHandler(t.target);
    } else if (mode == TOUCHZOOM) {
      setMode(IDLE);
      e.preventDefault();
    }
  }

  svg.addEventListener('mousedown', handleScanStart);
  svg.addEventListener('mouseup', handleScanEnd);
  svg.addEventListener('touchstart', handleTouchStart);
  svg.addEventListener('touchmove', handleTouchMove);
  svg.addEventListener('touchend', handleTouchEnd);
  svg.addEventListener('wheel', handleWheel, true);
}

function initMenus() {
  'use strict';

  let activeMenu = null;
  let activeMenuHdr = null;

  function cancelActiveMenu() {
    if (activeMenu == null) return;
    activeMenu.style.display = 'none';
    activeMenu = null;
    activeMenuHdr = null;
  }

  
  for (const menu of document.getElementsByClassName('submenu')) {
    const hdr = menu.parentElement;
    if (hdr == null) return;
    if (hdr.classList.contains('disabled')) return;
    function showMenu(e) {
      
      
      if (e.target.parentElement != hdr) return;
      activeMenu = menu;
      activeMenuHdr = hdr;
      menu.style.display = 'block';
    }
    hdr.addEventListener('mousedown', showMenu);
    hdr.addEventListener('touchstart', showMenu);
  }

  
  for (const t of ['mousedown', 'touchstart']) {
    document.addEventListener(t, (e) => {
      
      
      if (activeMenuHdr != e.target.closest('.menu-item')) {
        cancelActiveMenu();
      }
    }, { passive: true, capture: true });
  }

  
  document.addEventListener('mouseup', (e) => {
    if (activeMenu == e.target.closest('.submenu')) {
      cancelActiveMenu();
    }
  }, { passive: true, capture: true });
}

function sendURL(method, url, done) {
  fetch(url.toString(), {method: method})
      .then((response) => { done(response.ok); })
      .catch((error) => { done(false); });
}


function initConfigManager() {
  'use strict';

  
  function elem(id) {
    const result = document.getElementById(id);
    if (!result) console.warn('element ' + id + ' not found');
    return result;
  }
  const overlay = elem('dialog-overlay');
  const saveDialog = elem('save-dialog');
  const saveInput = elem('save-name');
  const saveError = elem('save-error');
  const delDialog = elem('delete-dialog');
  const delPrompt = elem('delete-prompt');
  const delError = elem('delete-error');

  let currentDialog = null;
  let currentDeleteTarget = null;

  function showDialog(dialog) {
    if (currentDialog != null) {
      overlay.style.display = 'none';
      currentDialog.style.display = 'none';
    }
    currentDialog = dialog;
    if (dialog != null) {
      overlay.style.display = 'block';
      dialog.style.display = 'block';
    }
  }

  function cancelDialog(e) {
    showDialog(null);
  }

  
  function showSaveDialog(e) {
    saveError.innerText = '';
    showDialog(saveDialog);
    saveInput.focus();
  }

  
  function commitSave(e) {
    const name = saveInput.value;
    const url = new URL(document.URL);
    
    url.pathname = new URL('./saveconfig', document.URL).pathname;
    url.searchParams.set('config', name);
    saveError.innerText = '';
    sendURL('POST', url, (ok) => {
      if (!ok) {
        saveError.innerText = 'Save failed';
      } else {
        showDialog(null);
        location.reload();  
      }
    });
  }

  function handleSaveInputKey(e) {
    if (e.key === 'Enter') commitSave(e);
  }

  function deleteConfig(e, elem) {
    e.preventDefault();
    const config = elem.dataset.config;
    delPrompt.innerText = 'Delete ' + config + '?';
    currentDeleteTarget = elem;
    showDialog(delDialog);
  }

  function commitDelete(e, elem) {
    if (!currentDeleteTarget) return;
    const config = currentDeleteTarget.dataset.config;
    const url = new URL('./deleteconfig', document.URL);
    url.searchParams.set('config', config);
    delError.innerText = '';
    sendURL('DELETE', url, (ok) => {
      if (!ok) {
        delError.innerText = 'Delete failed';
        return;
      }
      showDialog(null);
      
      if (currentDeleteTarget && currentDeleteTarget.parentElement) {
        currentDeleteTarget.parentElement.remove();
      }
    });
  }

  
  function bind(event, elem, fn) {
    if (elem == null) return;
    elem.addEventListener(event, fn);
    if (event == 'click') {
      
      elem.addEventListener('touchstart', fn);
    }
  }

  bind('click', elem('save-config'), showSaveDialog);
  bind('click', elem('save-cancel'), cancelDialog);
  bind('click', elem('save-confirm'), commitSave);
  bind('keydown', saveInput, handleSaveInputKey);

  bind('click', elem('delete-cancel'), cancelDialog);
  bind('click', elem('delete-confirm'), commitDelete);

  
  for (const del of Array.from(document.getElementsByClassName('menu-delete-btn'))) {
    bind('click', del, (e) => {
      deleteConfig(e, del);
    });
  }
}






function viewer(baseUrl, nodes, options) {
  'use strict';

  
  const search = document.getElementById('search');
  const graph0 = document.getElementById('graph0');
  const svg = (graph0 == null ? null : graph0.parentElement);
  const toptable = document.getElementById('toptable');

  let regexpActive = false;
  let selected = new Map();
  let origFill = new Map();
  let searchAlarm = null;
  let buttonsEnabled = true;

  
  function getSelection() {
    if (selected.size > 0) {
      return selected;
    } else if (options && options.current) {
      return options.current();
    }
    return new Map();
  }

  function handleDetails(e) {
    e.preventDefault();
    const detailsText = document.getElementById('detailsbox');
    if (detailsText != null) {
      if (detailsText.style.display === 'block') {
        detailsText.style.display = 'none';
      } else {
        detailsText.style.display = 'block';
      }
    }
  }

  function handleKey(e) {
    if (e.keyCode != 13) return;
    setHrefParams(window.location, function (params) {
      params.set('f', search.value);
    });
    e.preventDefault();
  }

  function handleSearch() {
    
    if (searchAlarm != null) {
      clearTimeout(searchAlarm);
    }
    searchAlarm = setTimeout(selectMatching, 300);

    regexpActive = true;
    updateButtons();
  }

  function selectMatching() {
    searchAlarm = null;
    let re = null;
    if (search.value != '') {
      try {
        re = new RegExp(search.value);
      } catch (e) {
        
        return;
      }
    }

    function match(text) {
      return re != null && re.test(text);
    }

    
    selected.forEach(function(v, n) {
      if (!match(nodes[n])) {
        unselect(n);
      }
    })

    
    if (nodes) {
      for (let n = 0; n < nodes.length; n++) {
        if (!selected.has(n) && match(nodes[n])) {
          select(n);
        }
      }
    }

    updateButtons();
  }

  function toggleSvgSelect(elem) {
    
    while (elem != null && elem.parentElement != graph0) {
      elem = elem.parentElement;
    }
    if (!elem) return;

    
    regexpActive = false;

    const n = nodeId(elem);
    if (n < 0) return;
    if (selected.has(n)) {
      unselect(n);
    } else {
      select(n);
    }
    updateButtons();
  }

  function unselect(n) {
    if (setNodeHighlight(n, false)) selected.delete(n);
  }

  function select(n, elem) {
    if (setNodeHighlight(n, true)) selected.set(n, true);
  }

  function nodeId(elem) {
    const id = elem.id;
    if (!id) return -1;
    if (!id.startsWith('node')) return -1;
    const n = parseInt(id.slice(4), 10);
    if (isNaN(n)) return -1;
    if (n < 0 || n >= nodes.length) return -1;
    return n;
  }

  
  function setNodeHighlight(n, set) {
    if (options && options.hiliter) return options.hiliter(n, set);

    const elem = document.getElementById('node' + n);
    if (!elem) return false;

    
    if (elem.nodeName == 'TR') {
      elem.classList.toggle('hilite', set);
      return true;
    }

    
    const p = findPolygon(elem);
    if (p != null) {
      if (set) {
        origFill.set(p, p.style.fill);
        p.style.fill = '#ccccff';
      } else if (origFill.has(p)) {
        p.style.fill = origFill.get(p);
      }
    }

    return true;
  }

  function findPolygon(elem) {
    if (elem.localName == 'polygon') return elem;
    for (const c of elem.children) {
      const p = findPolygon(c);
      if (p != null) return p;
    }
    return null;
  }

  function setSampleIndexLink(si) {
    const elem = document.getElementById('sampletype-' + si);
    if (elem != null) {
      setHrefParams(elem, function (params) {
        params.set("si", si);
      });
    }
  }

  
  
  function makeSearchLinkDynamic(id) {
    const elem = document.getElementById(id);
    if (elem == null) return;

    
    
    let param = 'f';
    if (id == 'ignore') param = 'i';
    if (id == 'hide') param = 'h';
    if (id == 'show') param = 's';
    if (id == 'show-from') param = 'sf';

    
    elem.addEventListener('mouseenter', updater);
    elem.addEventListener('touchstart', updater);

    function updater() {
      
      
      let re = regexpActive
          ? search.value
          : Array.from(getSelection().keys()).map(key => pprofQuoteMeta(nodes[key])).join('|');

      setHrefParams(elem, function (params) {
        if (re != '') {
          
          if (param != 'f' && param != 's' && param != 'sf' && params.has(param)) {
            const old = params.get(param);
            if (old != '') {
              re += '|' + old;
            }
          }
          params.set(param, re);
        } else {
          params.delete(param);
        }
      });
    }
  }

  function setHrefParams(elem, paramSetter) {
    let url = new URL(elem.href);
    url.hash = '';

    
    const params = url.searchParams;
    for (const p of new URLSearchParams(window.location.search)) {
      params.set(p[0], p[1]);
    }

    
    paramSetter(params);

    elem.href = url.toString();
  }

  function handleTopClick(e) {
    
    let elem = e.target;
    while (elem != null && elem.nodeName != 'TR') {
      elem = elem.parentElement;
    }
    if (elem == null || elem.children.length < 6) return;

    e.preventDefault();
    const tr = elem;
    const td = elem.children[5];
    if (td.nodeName != 'TD') return;
    const name = td.innerText;
    const index = nodes.indexOf(name);
    if (index < 0) return;

    
    regexpActive = false;

    if (selected.has(index)) {
      unselect(index, elem);
    } else {
      select(index, elem);
    }
    updateButtons();
  }

  function updateButtons() {
    const enable = (search.value != '' || getSelection().size != 0);
    if (buttonsEnabled == enable) return;
    buttonsEnabled = enable;
    for (const id of ['focus', 'ignore', 'hide', 'show', 'show-from']) {
      const link = document.getElementById(id);
      if (link != null) {
        link.classList.toggle('disabled', !enable);
      }
    }
  }

  
  updateButtons();

  
  initMenus();
  if (svg != null) {
    initPanAndZoom(svg, toggleSvgSelect);
  }
  if (toptable != null) {
    toptable.addEventListener('mousedown', handleTopClick);
    toptable.addEventListener('touchstart', handleTopClick);
  }

  const ids = ['topbtn', 'graphbtn',
               'flamegraph',
               'peek', 'list',
               'disasm', 'focus', 'ignore', 'hide', 'show', 'show-from'];
  ids.forEach(makeSearchLinkDynamic);

  const sampleIDs = ['alloc_objects', 'alloc_space', 'inuse_objects', 'inuse_space', ];
  sampleIDs.forEach(setSampleIndexLink);

  
  function addAction(id, action) {
    const btn = document.getElementById(id);
    if (btn != null) {
      btn.addEventListener('click', action);
      btn.addEventListener('touchstart', action);
    }
  }

  addAction('details', handleDetails);
  initConfigManager();

  search.addEventListener('input', handleSearch);
  search.addEventListener('keydown', handleKey);

  
  const main = document.getElementById('bodycontainer');
  if (main) {
    main.focus();
  }
}


function pprofQuoteMeta(str) {
  return '^' + str.replace(/([\\\.?+*\[\](){}|^$])/g, '\\$1') + '$';
}
</script>

<script>viewer(new URL(window.location.href), null);</script>


</body></html>